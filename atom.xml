<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>聪明叉的博客</title>
  <icon>https://www.gravatar.com/avatar/02d936e1da44a12f925b6966f43a0d9a</icon>
  <subtitle>成为更好的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://smarxpan.github.io/"/>
  <updated>2018-12-20T13:05:23.239Z</updated>
  <id>http://smarxpan.github.io/</id>
  
  <author>
    <name>聪明叉</name>
    <email>smarxpan@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GraphQL学习：Github GraphQL API v4初探</title>
    <link href="http://smarxpan.github.io/2018/12/20/Github%20GraphQL%20API%20v4%E5%88%9D%E6%8E%A2/"/>
    <id>http://smarxpan.github.io/2018/12/20/Github GraphQL API v4初探/</id>
    <published>2018-12-20T12:58:11.000Z</published>
    <updated>2018-12-20T13:05:23.239Z</updated>
    
    <content type="html"><![CDATA[<p>查看GithubAPI的时候，发现github API升级成了V4，并且叫<a href="https://developer.github.com/v4/" target="_blank" rel="noopener">GraphQL API v4</a>。不禁大吃一惊，这是个什么东东。</p><h2 id="什么是GraphQL"><a href="#什么是GraphQL" class="headerlink" title="什么是GraphQL"></a>什么是GraphQL</h2><p>GraphQL（Graph Query Language）：GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。</p><blockquote><p>GraphQL是一门语言，专门用于API查询。可以类比到SQL，这种类型的语言学名叫DSL（domain-specific language），译作领域专用语言</p></blockquote><p>为什么Github选用GraphQL呢？因为GraphQL具有以下好处：</p><ul><li>更大的灵活性</li><li>精确定义所需数据的能力（GraphQL拥有强类型）</li><li>仅仅会返回你需要的数据（避免数据冗余）</li><li>GraphQL允许您通过一次调用替换多个REST请求以获取指定的数据</li></ul><p>放一张来自图说明下工作过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/graphql_data_sources.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>看起来与原本的REST API没什么两样。</p><p>是的，大致的工作流程就是如此，不过GraphQL作为一门语言，其中有许多的概念和语法。但是我不想纯粹做官方文档的copyer，而是作为官方文档的一个导学，具体的概念和语法可以去</p><blockquote><p><a href="http://graphql.cn/learn/" target="_blank" rel="noopener">GraphQL中文网</a>学习。</p></blockquote><p>相信你也不爱一下子看到超多陌生概念，我们还行边用边学吧</p><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>github提供了<a href="https://developer.github.com/v4/explorer/" target="_blank" rel="noopener">GraphQL Explorer</a>来辅助GraphQL学习</p><h3 id="一个小小案例"><a href="#一个小小案例" class="headerlink" title="一个小小案例"></a>一个小小案例</h3><p>打开<a href="https://developer.github.com/v4/explorer/" target="_blank" rel="noopener">GraphQL Explorer</a>这里我们先来运行下面的代码：</p><pre><code>query {   viewer {     login  }}</code></pre><p>这段代码可以查询你github的用户名，注意，请先登录。</p><p>我运行的结果：</p><pre><code>{  &quot;data&quot;: {    &quot;viewer&quot;: {      &quot;login&quot;: &quot;smarxpan&quot;    }  }}</code></pre><p>这里你可能会产生疑惑，为什么接口可以这样请求，到底发生了什么魔法？</p><p>打开抓包软件，我们来抓个包看看。</p><p>上面的请求，实际上发送的内容仍旧是个json：</p><pre><code>{    &quot;query&quot;: &quot;query { \n  viewer { \n    login\n  }\n}&quot;,    &quot;variables&quot;: {}}</code></pre><p>这里没有什么魔法，我们看到那段代码的内容作为query参数的值发送给了服务端，服务端按照语法对其进行解析，然后返回给我们需要的值。</p><h3 id="小小案例的具体解释"><a href="#小小案例的具体解释" class="headerlink" title="小小案例的具体解释"></a>小小案例的具体解释</h3><pre><code>query {   viewer {     login  }}</code></pre><p>这一小段的第一句：<code>query</code></p><p>GraphQL中有两种操作：query和mutation。query代表查询，mutation是变更。查询就是请求数据，而变更，对应REST API的POST/PATCH/DELETE。</p><p>这两种操作使用的请求方式均为post，get请求在GraphQL不常用。</p><p>query的结构类似：</p><pre><code>query {  JSON objects to return}</code></pre><p>其内部定义的是要返回数据的json结构。</p><h2 id="学习和使用指引"><a href="#学习和使用指引" class="headerlink" title="学习和使用指引"></a>学习和使用指引</h2><p>最佳的示例当然是<a href="https://developer.github.com/v4/guides/" target="_blank" rel="noopener">《Github GraphQL Guides》</a>，其中有示例、可运行，里面的每段代码都可点击到explorer里运行。</p><p>语法学习还是推荐GraphQL中文网：<a href="http://graphql.cn/learn" target="_blank" rel="noopener">《GraphQL 入门》</a></p><p>还有一篇博客我觉得特别棒，是Leetcode工作的一位大神的<a href="http://jerryzou.com/posts/10-questions-about-graphql/" target="_blank" rel="noopener">《阻碍你使用 GraphQL 的十个问题》</a></p><p>而真正使用到工作中，当然少不了库的使用</p><p><a href="http://graphql.cn/code/#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%93" target="_blank" rel="noopener">GraphQL服务端库</a></p><p><a href="http://graphql.cn/code/#graphql-%E5%AE%A2%E6%88%B7%E7%AB%AF" target="_blank" rel="noopener">GraphQL客户端库</a></p><p>目前主流的开发语言均有具体实现，取决于你使用的是哪一种语言，选择自己的开发库用起来。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>新技术无疑是让人兴奋的，GraphQL确实解决了不少痛点，如果项目没什么历史包袱可以搞一搞。Github作为世界上最大的同性交友网站，其在API上使用该语言相信会带动业界的进步，学就完了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看GithubAPI的时候，发现github API升级成了V4，并且叫&lt;a href=&quot;https://developer.github.com/v4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GraphQL API v4&lt;/a&gt;。不禁大吃一惊，
      
    
    </summary>
    
    
      <category term="编程" scheme="http://smarxpan.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>理解Python协程(Coroutine)</title>
    <link href="http://smarxpan.github.io/2018/12/13/%E7%90%86%E8%A7%A3Python%E5%8D%8F%E7%A8%8B/"/>
    <id>http://smarxpan.github.io/2018/12/13/理解Python协程/</id>
    <published>2018-12-13T07:15:30.000Z</published>
    <updated>2018-12-18T01:53:39.810Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#理解python的协程coroutine">理解Python的协程(Coroutine)</a><ul><li><a href="#生成器generator">生成器(Generator)</a><ul><li><a href="#yield表达式的使用"><code>yield</code>表达式的使用</a></li><li><a href="#生产者和消费者模型">生产者和消费者模型</a></li><li><a href="#yield-from表达式"><code>yield from</code>表达式</a></li></ul></li><li><a href="#协程coroutine">协程(Coroutine)</a><ul><li><a href="#asynciocoroutine"><code>@asyncio.coroutine</code></a></li><li><a href="#asyncawait"><code>async</code>/<code>await</code></a></li></ul></li><li><a href="#总结">总结</a></li><li><a href="#参考链接">参考链接</a></li></ul></li></ul><!-- /code_chunk_output --><p>由于GIL的存在，导致Python多线程性能甚至比单线程更糟。</p><blockquote><p>GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。[1]即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。</p></blockquote><p>于是出现了协程（Coroutine）这么个东西。</p><blockquote><p>协程: 协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行.</p></blockquote><p>协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。对于IO密集型任务非常适用，如果是cpu密集型，推荐多进程+协程的方式。</p><p>在Python3.4之前，官方没有对协程的支持，存在一些三方库的实现，比如gevent和Tornado。3.4之后就内置了asyncio标准库，官方真正实现了协程这一特性。</p><p>而Python对协程的支持，是通过Generator实现的，协程是遵循某些规则的生成器。因此，我们在了解协程之前，我们先要学习生成器。</p><h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器(Generator)"></a>生成器(Generator)</h2><p>我们这里主要讨论<code>yield</code>和<code>yield from</code>这两个表达式，这两个表达式和协程的实现息息相关。</p><ul><li>Python2.5中引入<code>yield</code>表达式，参见<a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="noopener">PEP342</a></li><li>Python3.3中增加<code>yield from</code>语法，参见<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">PEP380</a>，</li></ul><p>方法中包含<code>yield</code>表达式后，Python会将其视作generator对象，不再是普通的方法。</p><h3 id="yield表达式的使用"><a href="#yield表达式的使用" class="headerlink" title="yield表达式的使用"></a><code>yield</code>表达式的使用</h3><p>我们先来看该表达式的具体使用：</p><pre><code>def test():    print(&quot;generator start&quot;)    n = 1    while True:        yield_expression_value = yield n        print(&quot;yield_expression_value = %d&quot; % yield_expression_value)        n += 1# ①创建generator对象generator = test()print(type(generator))print(&quot;\n---------------\n&quot;)# ②启动generatornext_result = generator.__next__()print(&quot;next_result = %d&quot; % next_result)print(&quot;\n---------------\n&quot;)# ③发送值给yield表达式send_result = generator.send(666)print(&quot;send_result = %d&quot; % send_result)</code></pre><p>执行结果：</p><pre><code>&lt;class &apos;generator&apos;&gt;---------------generator startnext_result = 1---------------yield_expression_value = 666send_result = 2</code></pre><p>方法说明：</p><ul><li><p><code>__next__()</code>方法: 作用是启动或者恢复generator的执行，相当于send(None)</p></li><li><p><code>send(value)</code>方法：作用是发送值给yield表达式。启动generator则是调用send(None)</p></li></ul><p>执行结果的说明：</p><ul><li><p>①创建generator对象：包含yield表达式的函数将不再是一个函数，调用之后将会返回generator对象</p></li><li><p>②启动generator：使用生成器之前需要先调用<code>__next__</code>或者<code>send(None)</code>，否则将报错。启动generator后，代码将执行到<code>yield</code>出现的位置，也就是执行到<code>yield n</code>，然后将n传递到<code>generator.__next__()</code>这行的返回值。（注意，生成器执行到<code>yield n</code>后将暂停在这里，直到下一次生成器被启动）</p></li><li><p>③发送值给yield表达式：调用send方法可以发送值给yield表达式，同时恢复生成器的执行。生成器从上次中断的位置继续向下执行，然后遇到下一个<code>yield</code>，生成器再次暂停，切换到主函数打印出send_result。</p></li></ul><p>理解这个demo的关键是：生成器启动或恢复执行一次，将会在<code>yield</code>处暂停。上面的第②步仅仅执行到了<code>yield n</code>，并没有执行到赋值语句，到了第③步，生成器恢复执行才给<code>yield_expression_value</code>赋值。</p><h3 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h3><p>上面的例子中，代码中断–&gt;切换执行，体现出了协程的部分特点。</p><p>我们再举一个生产者、消费者的例子，这个例子来自<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000" target="_blank" rel="noopener">廖雪峰的Python教程</a>：</p><blockquote><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p></blockquote><blockquote><p>现在改用协程，生产者生产消息后，直接通过<code>yield</code>跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。</p></blockquote><pre><code>def consumer():    print(&quot;[CONSUMER] start&quot;)    r = &apos;start&apos;    while True:        n = yield r        if not n:            print(&quot;n is empty&quot;)            continue        print(&quot;[CONSUMER] Consumer is consuming %s&quot; % n)        r = &quot;200 ok&quot;def producer(c):    # 启动generator    start_value = c.send(None)    print(start_value)    n = 0    while n &lt; 3:        n += 1        print(&quot;[PRODUCER] Producer is producing %d&quot; % n)        r = c.send(n)        print(&apos;[PRODUCER] Consumer return: %s&apos; % r)    # 关闭generator    c.close()# 创建生成器c = consumer()# 传入generatorproducer(c)</code></pre><p>执行结果：</p><pre><code>[CONSUMER] startstart[PRODUCER] producer is producing 1[CONSUMER] consumer is consuming 1[PRODUCER] Consumer return: 200 ok[PRODUCER] producer is producing 2[CONSUMER] consumer is consuming 2[PRODUCER] Consumer return: 200 ok[PRODUCER] producer is producing 3[CONSUMER] consumer is consuming 3[PRODUCER] Consumer return: 200 ok</code></pre><blockquote><p>注意到<code>consumer</code>函数是一个<code>generator</code>，把一个<code>consumer</code>传入<code>produce</code>后：</p></blockquote><blockquote><ol><li>首先调用<code>c.send(None)</code>启动生成器；</li><li>然后，一旦生产了东西，通过<code>c.send(n)</code>切换到consumer执行；</li><li><code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回；</li><li><code>produce</code>拿到<code>consumer</code>处理的结果，继续生产下一条消息；</li><li><code>produce</code>决定不生产了，通过<code>c.close()</code>关闭<code>consumer</code>，整个过程结束。</li></ol></blockquote><blockquote><p>整个流程无锁，由一个线程执行，<code>produce</code>和<code>consumer</code>协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p></blockquote><h3 id="yield-from表达式"><a href="#yield-from表达式" class="headerlink" title="yield from表达式"></a><code>yield from</code>表达式</h3><p>Python3.3版本新增<code>yield from</code>语法，新语法用于将一个生成器部分操作委托给另一个生成器。此外，允许子生成器（即yield from后的“参数”）返回一个值，该值可供委派生成器（即包含yield from的生成器）使用。并且在委派生成器中，可对子生成器进行优化。</p><p>我们先来看最简单的应用，例如：</p><pre><code># 子生成器def test(n):    i = 0    while i &lt; n:        yield i        i += 1# 委派生成器def test_yield_from(n):    print(&quot;test_yield_from start&quot;)    yield from test(n)    print(&quot;test_yield_from end&quot;)for i in test_yield_from(3):    print(i)</code></pre><p>输出：</p><pre><code>test_yield_from start012test_yield_from end</code></pre><p>这里我们仅仅给这个生成器添加了一些打印，如果是正式的代码中，你可以添加正常的执行逻辑。</p><p>如果上面的<code>test_yield_from</code>函数中有两个<code>yield from</code>语句，将串行执行。比如将上面的<code>test_yield_from</code>函数改写成这样：</p><pre><code>def test_yield_from(n):    print(&quot;test_yield_from start&quot;)    yield from test(n)    print(&quot;test_yield_from doing&quot;)    yield from test(n)    print(&quot;test_yield_from end&quot;)</code></pre><p>将输出：</p><pre><code>test_yield_from start012test_yield_from doing012test_yield_from end</code></pre><p>在这里，<code>yield from</code>起到的作用相当于下面写法的简写形式</p><pre><code>for item in test(n):    yield item</code></pre><p>看起来这个<code>yield from</code>也没做什么大不了的事，其实它还帮我们处理了异常之类的。具体可以看stackoverflow上的这个问题：<a href="https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3" target="_blank" rel="noopener">In practice, what are the main uses for the new “yield from” syntax in Python 3.3?</a></p><h2 id="协程-Coroutine"><a href="#协程-Coroutine" class="headerlink" title="协程(Coroutine)"></a>协程(Coroutine)</h2><ul><li>Python3.4开始，新增了asyncio相关的API，语法使用<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>和</code>yield from`实现协程</li><li>Python3.5中引入<code>async</code>/<code>await</code>语法，参见<a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="noopener">PEP492</a></li></ul><p>我们先来看Python3.4的实现。</p><h3 id="asyncio-coroutine"><a href="#asyncio-coroutine" class="headerlink" title="`@asyncio.coroutine`"></a><a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`</h3><p>Python3.4中，使用<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`装饰的函数称为协程。不过没有从语法层面进行严格约束。</p><blockquote><p>对装饰器不了解的小伙伴可以看我的上一篇博客–<a href="https://www.jianshu.com/p/ee82b941772a" target="_blank" rel="noopener">《理解Python装饰器》</a></p></blockquote><p>对于Python原生支持的协程来说，Python对协程和生成器做了一些区分，便于消除这两个不同但相关的概念的歧义：</p><ul><li>标记了<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>装饰器的函数称为协程函数，</code>iscoroutinefunction()`方法返回True</li><li>调用协程函数返回的对象称为协程对象，<code>iscoroutine()</code>函数返回True</li></ul><p>举个栗子，我们给上面<code>yield from</code>的demo中添加<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`：</p><pre><code>import asyncio...@asyncio.coroutinedef test_yield_from(n):    ...# 是否是协程函数print(asyncio.iscoroutinefunction(test_yield_from))# 是否是协程对象print(asyncio.iscoroutine(test_yield_from(3)))</code></pre><p>毫无疑问输出结果是True。</p><p>可以看下<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`的源码中查看其做了什么，我将其源码简化下，大致如下：</p><pre><code>import functoolsimport typesimport inspectdef coroutine(func):    # 判断是否是生成器    if inspect.isgeneratorfunction(func):        coro = func    else:        # 将普通函数变成generator        @functools.wraps(func)        def coro(*args, **kw):            res = func(*args, **kw)            res = yield from res            return res    # 将generator转换成coroutine    wrapper = types.coroutine(coro)    # For iscoroutinefunction().    wrapper._is_coroutine = True    return wrapper</code></pre><p>将这个装饰器标记在一个生成器上，就会将其转换成coroutine。</p><p>然后，我们来实际使用下<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>和</code>yield from`：</p><pre><code>import asyncio@asyncio.coroutinedef compute(x, y):    print(&quot;Compute %s + %s ...&quot; % (x, y))    yield from asyncio.sleep(1.0)    return x + y@asyncio.coroutinedef print_sum(x, y):    result = yield from compute(x, y)    print(&quot;%s + %s = %s&quot; % (x, y, result))loop = asyncio.get_event_loop()print(&quot;start&quot;)# 中断调用，直到协程执行结束loop.run_until_complete(print_sum(1, 2))print(&quot;end&quot;)loop.close()</code></pre><p>执行结果：</p><pre><code>startCompute 1 + 2 ...1 + 2 = 3end</code></pre><p><code>print_sum</code>这个协程中调用了子协程<code>compute</code>，它将等待<code>compute</code>执行结束才返回结果。</p><p>这个demo点调用流程如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://docs.python.org/3.4/_images/tulip_coro.png" alt="tulip_coro.png" title="">                </div>                <div class="image-caption">tulip_coro.png</div>            </figure><p>EventLoop将会把<code>print_sum</code>封装成Task对象</p><p>流程图展示了这个demo的控制流程，不过没有展示其全部细节。比如其中“暂停”的1s，实际上创建了一个future对象, 然后通过<code>BaseEventLoop.call_later()</code>在1s后唤醒这个任务。</p><p>值得注意的是，<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`将在Python3.10版本中移除。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async</code>/<code>await</code></h3><p>Python3.5开始引入<code>async</code>/<code>await</code>语法（<a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener">PEP 492</a>），用来简化协程的使用并且便于理解。</p><p><code>async</code>/<code>await</code>实际上只是<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>和</code>yield from`的语法糖：</p><ul><li>把<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>替换为</code>async`</li><li>把<code>yield from</code>替换为<code>await</code></li></ul><p>即可。</p><p>比如上面的例子：</p><pre><code>import asyncioasync def compute(x, y):    print(&quot;Compute %s + %s ...&quot; % (x, y))    await asyncio.sleep(1.0)    return x + yasync def print_sum(x, y):    result = await compute(x, y)    print(&quot;%s + %s = %s&quot; % (x, y, result))loop = asyncio.get_event_loop()print(&quot;start&quot;)loop.run_until_complete(print_sum(1, 2))print(&quot;end&quot;)loop.close()</code></pre><p>我们再来看一个asyncio中Future的例子：</p><pre><code>import asynciofuture = asyncio.Future()async def coro1():    print(&quot;wait 1 second&quot;)    await asyncio.sleep(1)    print(&quot;set_result&quot;)    future.set_result(&apos;data&apos;)async def coro2():    result = await future    print(result)loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait([    coro1()    coro2()]))loop.close()</code></pre><p>输出结果：</p><pre><code>wait 1 second(大约等待1秒)set_resultdata</code></pre><p>这里await后面跟随的future对象，协程中yield from或者await后面可以调用future对象，其作用是：暂停协程，直到future执行结束或者返回result或抛出异常。</p><p>而在我们的例子中，<code>await future</code>必须要等待<code>future.set_result(&#39;data&#39;)</code>后才能够结束。将<code>coro2()</code>作为第二个协程可能体现得不够明显，可以将协程的调用改成这样：</p><pre><code>loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait([    # coro1(),    coro2(),    coro1()]))loop.close()</code></pre><p>输出的结果仍旧与上面相同。</p><p>其实，<code>async</code>这个关键字的用法不止能用在函数上，还有<code>async with</code>异步上下文管理器，<code>async for</code>异步迭代器. 对这些感兴趣且觉得有用的可以网上找找资料，这里限于篇幅就不过多展开了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文就生成器和协程做了一些学习、探究和总结，不过并没有做过多深入深入的研究。权且作为入门到一个笔记，之后将会尝试自己实现一下异步API，希望有助于理解学习。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/" target="_blank" rel="noopener">Python协程 https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/</a></p><p><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf" target="_blank" rel="noopener">http://www.dabeaz.com/coroutines/Coroutines.pdf</a></p><p><a href="https://eastlakeside.gitbooks.io/interpy-zh/content/Coroutines/" target="_blank" rel="noopener">Coroutines</a></p><p><a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="noopener">How the heck does async/await work in Python 3.5</a></p><p><a href="https://docs.python.org/release/3.4.0/library/asyncio-task.html#coroutines" target="_blank" rel="noopener">Python3.4协程文档</a></p><p><a href="https://docs.python.org/3.5/library/asyncio-task.html#coroutines" target="_blank" rel="noopener">Python3.5协程文档</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000" target="_blank" rel="noopener">廖雪峰的Python教程–协程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;
&lt;!-- code_chunk_output --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#理解python的协程corout
      
    
    </summary>
    
    
      <category term="Python" scheme="http://smarxpan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>理解Python装饰器(Decorator)</title>
    <link href="http://smarxpan.github.io/2018/12/05/%E7%90%86%E8%A7%A3Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://smarxpan.github.io/2018/12/05/理解Python装饰器/</id>
    <published>2018-12-05T07:15:30.000Z</published>
    <updated>2018-12-17T11:14:00.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解Python装饰器-Decorator"><a href="#理解Python装饰器-Decorator" class="headerlink" title="理解Python装饰器(Decorator)"></a>理解Python装饰器(Decorator)</h2><p>Python装饰器看起来类似Java中的注解，然鹅和注解并不相同，不过同样能够实现面向切面编程。</p><p>想要理解Python中的装饰器，不得不先理解闭包（closure）这一概念。</p><p>看看维基百科中的解释：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p></blockquote><p>官方的解释总是不说人话，but–talk is cheap，show me the code: </p><pre><code># print_msg是外围函数def print_msg():    msg = &quot;I&apos;m closure&quot;    # printer是嵌套函数    def printer():        print(msg)    return printer# 这里获得的就是一个闭包closure = print_msg()# 输出 I&apos;m closureclosure()</code></pre><p><code>msg</code>是一个局部变量，在<code>print_msg</code>函数执行之后应该就不会存在了。但是嵌套函数引用了这个变量，将这个局部变量封闭在了嵌套函数中，这样就形成了一个闭包。</p><p>结合这个例子再看维基百科的解释，就清晰明了多了。闭包就是引用了自有变量的函数，这个函数保存了执行的上下文，可以脱离原本的作用域独立存在。</p><p>下面来看看Python中的装饰器。</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>一个普通的装饰器一般是这样：</p><pre><code>import functoolsdef log(func):    @functools.wraps(func)    def wrapper(*args, **kwargs):        print(&apos;call %s():&apos; % func.__name__)        print(&apos;args = {}&apos;.format(*args))        return func(*args, **kwargs)    return wrapper</code></pre><p>这样就定义了一个打印出方法名及其参数的装饰器。</p><p>调用之：</p><pre><code>@logdef test(p):    print(test.__name__ + &quot; param: &quot; + p)test(&quot;I&apos;m a param&quot;)</code></pre><p>输出：</p><pre><code>call test():args = I&apos;m a paramtest param: I&apos;m a param</code></pre><p>装饰器在使用时，用了<code>@</code>语法，让人有些困扰。其实，装饰器只是个方法，与下面的调用方式没有区别：</p><pre><code>def test(p):    print(test.__name__ + &quot; param: &quot; + p)wrapper = log(test)wrapper(&quot;I&apos;m a param&quot;)</code></pre><p><code>@</code>语法只是将函数传入装饰器函数，并无神奇之处。</p><p>值得注意的是<a href="mailto:`@functools.wraps" target="_blank" rel="noopener">`@functools.wraps</a>(func)<code>，这是python提供的装饰器。它能把原函数的元信息拷贝到装饰器里面的 func 函数中。函数的元信息包括docstring、__name__、参数列表等等。可以尝试去除</code>@functools.wraps(func)<code>，你会发现</code>test.<strong>name</strong>`的输出变成了wrapper。</p><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>装饰器允许传入参数，一个携带了参数的装饰器将有三层函数，如下所示：</p><pre><code>import functoolsdef log_with_param(text):    def decorator(func):        @functools.wraps(func)        def wrapper(*args, **kwargs):            print(&apos;call %s():&apos; % func.__name__)            print(&apos;args = {}&apos;.format(*args))            print(&apos;log_param = {}&apos;.format(text))            return func(*args, **kwargs)        return wrapper    return decorator@log_with_param(&quot;param&quot;)def test_with_param(p):    print(test_with_param.__name__)</code></pre><p>看到这个代码是不是又有些疑问，内层的decorator函数的参数func是怎么传进去的？和上面一般的装饰器不大一样啊。</p><p>其实道理是一样的，将其<code>@</code>语法去除，恢复函数调用的形式一看就明白了：</p><pre><code># 传入装饰器的参数，并接收返回的decorator函数decorator = log_with_param(&quot;param&quot;)# 传入test_with_param函数wrapper = decorator(test_with_param)# 调用装饰器函数wrapper(&quot;I&apos;m a param&quot;)</code></pre><p>输出结果与正常使用装饰器相同：</p><pre><code>call test_with_param():args = I&apos;m a paramlog_param = paramtest_with_param</code></pre><p>至此，装饰器这个有点费解的特性也没什么神秘了。</p><p>装饰器这一语法体现了Python中函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，非常的灵活与强大。</p><p>Python中引入了很多函数式编程的特性，需要好好学习与体会。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;理解Python装饰器-Decorator&quot;&gt;&lt;a href=&quot;#理解Python装饰器-Decorator&quot; class=&quot;headerlink&quot; title=&quot;理解Python装饰器(Decorator)&quot;&gt;&lt;/a&gt;理解Python装饰器(Decorator)
      
    
    </summary>
    
    
      <category term="Python" scheme="http://smarxpan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>理解Python中的元类(metaclass)</title>
    <link href="http://smarxpan.github.io/2018/11/30/%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB(metaclass)/"/>
    <id>http://smarxpan.github.io/2018/11/30/理解Python中的元类(metaclass)/</id>
    <published>2018-11-30T07:15:30.000Z</published>
    <updated>2018-12-14T13:01:20.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解Python中的元类-metaclass"><a href="#理解Python中的元类-metaclass" class="headerlink" title="理解Python中的元类(metaclass)"></a>理解Python中的元类(metaclass)</h1><p>这篇文章基本上是<a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">What are metaclasses in Python?</a>最高赞答案的翻译，同时我简化了一点东西，加了点自己的demo。可以直接去看原文。</p><h2 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h2><p>在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：</p><pre><code>&gt;&gt;&gt; class ObjectCreator(object):...       pass...&gt;&gt;&gt; my_object = ObjectCreator()&gt;&gt;&gt; print(my_object)&lt;__main__.ObjectCreator object at 0x8974f2c&gt;</code></pre><p>但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象.</p><p>下面这段代码：</p><pre><code>class ObjectCreator(object):      pass</code></pre><p>将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是你可以对它做如下的操作：</p><ol><li>你可以将它赋值给一个变量</li><li>你可以拷贝它</li><li>你可以为它增加属性</li><li>你可以将它作为函数参数进行传递</li></ol><p>下面是示例：</p><pre><code>&gt;&gt;&gt; print ObjectCreator     # 你可以打印一个类，因为它其实也是一个对象&lt;class &apos;__main__.ObjectCreator&apos;&gt;&gt;&gt;&gt; def echo(o):…       print o…&gt;&gt;&gt; echo(ObjectCreator)                 # 你可以将类做为参数传给函数&lt;class &apos;__main__.ObjectCreator&apos;&gt;&gt;&gt;&gt; print hasattr(ObjectCreator, &apos;new_attribute&apos;)Fasle&gt;&gt;&gt; ObjectCreator.new_attribute = &apos;foo&apos; #  你可以为类增加属性&gt;&gt;&gt; print hasattr(ObjectCreator, &apos;new_attribute&apos;)True&gt;&gt;&gt; print ObjectCreator.new_attributefoo&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量&gt;&gt;&gt; print ObjectCreatorMirror()&lt;__main__.ObjectCreator object at 0x8997b4c&gt;</code></pre><h2 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h2><p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可</p><pre><code>&gt;&gt;&gt; def choose_class(name):…       if name == &apos;foo&apos;:…           class Foo(object):…               pass…           return Foo     # 返回的是类，不是类的实例…       else:…           class Bar(object):…               pass…           return Bar…&gt;&gt;&gt; MyClass = choose_class(&apos;foo&apos;)&gt;&gt;&gt; print MyClass              # 函数返回的是类，不是类的实例&lt;class &apos;__main__&apos;.Foo&gt;&gt;&gt;&gt; print MyClass()            # 你可以通过这个类创建类实例，也就是对象&lt;__main__.Foo object at 0x89c6d4c&gt;</code></pre><p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。</p><p>type能动态的创建类，type可以接受一个类的描述作为参数，然后返回一个类。</p><pre><code>type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</code></pre><p>比如下面的代码：</p><pre><code>&gt;&gt;&gt; MyShinyClass = type(&apos;MyShinyClass&apos;, (), {})  # 返回一个类对象&gt;&gt;&gt; print MyShinyClass&lt;class &apos;__main__.MyShinyClass&apos;&gt;&gt;&gt;&gt; print MyShinyClass()  #  创建一个该类的实例&lt;__main__.MyShinyClass object at 0x8997cec&gt;</code></pre><p>type 接受一个字典来为类定义属性，因此：</p><pre><code>&gt;&gt;&gt; class Foo(object):…       bar = True</code></pre><p>等同于：</p><pre><code>Foo = type(&apos;Foo&apos;, (), {&apos;bar&apos;:True})</code></pre><p>在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。</p><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”。type就是Python的内建元类，当然了，你也可以创建自己的元类。</p><p>元类本身而言，它们其实是很简单的：</p><p>1)   拦截类的创建</p><p>2)   修改类</p><p>3)   返回修改之后的类</p><h2 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h2><p>元类的主要目的就是为了当创建类时能够自动地改变类。</p><p>Python 3中创建元类的语法:</p><pre><code>class NothingMetaclass(type):    def __new__(mcs, name, bases, namespace):         # 什么都没做，你可以在这里做点什么        return type.__new__(mcs, name, bases, namespace)class Foo(object, metaclass=NothingMetaclass):    pass</code></pre><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h3><ol><li>new是一个静态方法,而init是一个实例方法.</li><li>new方法会返回一个创建的实例,而init什么都不返回.</li><li>只有在new返回一个cls的实例时后面的init才能被调用.</li><li>当创建一个新实例时调用new,初始化一个实例时用init.</li></ol><p>看一个例子</p><pre><code># 请记住，&apos;type&apos;实际上是一个类，就像&apos;str&apos;和&apos;int&apos;一样# 所以，你可以从type继承class MetaA(type):    # __new__ 是在__init__之前被调用的特殊方法    # __new__是用来创建对象并返回之的方法    # 而__init__只是用来将传入的参数初始化给对象    # 你很少用到__new__，除非你希望能够控制对象的创建    # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__    # 如果你希望的话，你也可以在__init__中做些事情    # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用    def __new__(cls, name, bases, dct):        print(&apos;MetaA.__new__&apos;)        # 这种方式不会调用__init__方法        # return type(name, bases, dct)        # 这种方式会调用__init__        return type.__new__(cls, name, bases, dct)    def __init__(cls, name, bases, dct):        print(&apos;MetaA.__init__&apos;)class A(object, metaclass=MetaA):    passprint(A())</code></pre><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h3><pre><code>class ListMetaclass(type):    # 元类会自动将你通常传给‘type’的参数作为自己的参数传入    # mcs表示元类    # name表示创建类的类名（在这里创建类就是继承Model类的子类User）    # bases表示创建类继承的所有父类    # namespace表示创建类的所有属性和方法（以键值对的字典的形式）    def __new__(mcs, name, bases, namespace):        namespace[&apos;add&apos;] = lambda self, value: self.append(value)        return type.__new__(mcs, name, bases, namespace)# 通过metaclass，给该类动态添加了add方法class MyList(list, metaclass=ListMetaclass):    passl = MyList()l.add(1)print(l)</code></pre><h2 id="究竟为什么要使用元类？"><a href="#究竟为什么要使用元类？" class="headerlink" title="究竟为什么要使用元类？"></a>究竟为什么要使用元类？</h2><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：</p><blockquote><p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters</p></blockquote><p>元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义</p><pre><code>class Person(models.Model):    name = models.CharField(max_length=30)    age = models.IntegerField()</code></pre><p>然后可以通过简单点API操作数据库。其背后的魔法就是定义了元类，并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。</p><h3 id="一个简单的orm-demo"><a href="#一个简单的orm-demo" class="headerlink" title="一个简单的orm demo"></a>一个简单的orm demo</h3><pre><code>class Field:    def __init__(self, name, column_type):        self.name = name        self.column_type = column_type    def __str__(self):        return &apos;&lt;%s:%s&gt;&apos; % (self.__class__.__name__, self.name)class StringField(Field):    def __init__(self, name):        super(StringField, self).__init__(name, &apos;varchar(100)&apos;)class IntegerField(Field):    def __init__(self, name):        super(IntegerField, self).__init__(name, &apos;bigint&apos;)class ModelMetaclass(type):    def __new__(mcs, name, bases, attrs):        if name == &apos;Model&apos;:            return type.__new__(mcs, name, bases, attrs)        print(&quot;Found Model: %s&quot; % name)        mapping = dict()        fields = list()        # 将属性保存到mapping中        for k, v in attrs.items():            if isinstance(v, Field):                print(&apos;Found mapping : %s ==&gt; %s&apos; % (k, v))                mapping[k] = v                fields.append(k)        # 将Model中的Field删除        for k in mapping.keys():            attrs.pop(k)        attrs[&apos;__fields__&apos;] = list(map(lambda f: &apos;`%s`&apos; % f, fields))        attrs[&apos;__mapping__&apos;] = mapping        attrs[&apos;__table__&apos;] = name        return type.__new__(mcs, name, bases, attrs)class Model(dict, metaclass=ModelMetaclass):    def __init__(self, **kwargs):        super(Model, self).__init__(kwargs)    def __getattr__(self, key):        try:            return self[key]        except KeyError:            raise AttributeError(r&quot;&apos;Model&apos; object has no attribute &apos;%s&apos;&quot; % key)    def __setattr__(self, key, value):        self[key] = value    def save(self):        fields = []        params = []        args = []        for k, v in self.__mapping__.items():            print(&quot;%s------%s&quot; % (k, v))            fields.append(v.name)            params.append(&apos;?&apos;)            args.append(getattr(self, k, None))        sql = &apos;insert into %s (%s) values (%s)&apos; % (self.__table__, &apos;,&apos;.join(self.__fields__), &apos;,&apos;.join(params))        print(&apos;SQL: %s&apos; % sql)        print(&apos;ARGS: %s&apos; % str(args))class User(Model):    # 定义类的属性到列的映射：    id = IntegerField(&apos;id&apos;)    name = StringField(&apos;username&apos;)    email = StringField(&apos;email&apos;)    password = StringField(&apos;password&apos;)u = User(id=12345, name=&apos;Michael&apos;, email=&apos;test@orm.org&apos;, password=&apos;my-pwd&apos;)u.save()</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：</p><p>1）Monkey patching</p><p>2) 类装饰器</p><p>当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理解Python中的元类-metaclass&quot;&gt;&lt;a href=&quot;#理解Python中的元类-metaclass&quot; class=&quot;headerlink&quot; title=&quot;理解Python中的元类(metaclass)&quot;&gt;&lt;/a&gt;理解Python中的元类(metacl
      
    
    </summary>
    
    
      <category term="Python" scheme="http://smarxpan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Android应用冷启动时间优化探究</title>
    <link href="http://smarxpan.github.io/2018/08/29/Android%E5%BA%94%E7%94%A8%E5%86%B7%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96%E6%8E%A2%E7%A9%B6/"/>
    <id>http://smarxpan.github.io/2018/08/29/Android应用冷启动时间优化探究/</id>
    <published>2018-08-29T12:48:33.000Z</published>
    <updated>2018-12-17T11:11:44.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android应用冷启动时间优化探究"><a href="#Android应用冷启动时间优化探究" class="headerlink" title="Android应用冷启动时间优化探究"></a>Android应用冷启动时间优化探究</h1><h2 id="启动时间过长原因探究"><a href="#启动时间过长原因探究" class="headerlink" title="启动时间过长原因探究"></a>启动时间过长原因探究</h2><p>因应用三网融合SDK点击后启动时间过长，因此探究其冷启动时间过长的原因。</p><p>编写了一个Demo，demo的启动Activity为<code>com.zhexin.paymergesdk.MainActivity</code></p><p>使用以下命令启动应用：</p><pre><code>adb shell am start -S -W com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN</code></pre><p>此命令可统计启动时间</p><p>最初Demo是正常接入SDK，执行命令后的输出结果为：</p><pre><code>Stopping: com.outfit7.mytalkingtomfreeStarting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity }Status: okActivity: com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivityThisTime: 7260TotalTime: 7260WaitTime: 7282Complete</code></pre><p>冷启动时间为7260ms，黑/白屏时间过长。</p><p>因我这边自己写的代码都是在子线程中运行，因此怀疑是咪咕或者联通SDK的初始化时间过长导致，下面注释掉咪咕的初始化。</p><p>咪咕的初始化代码是：</p><pre><code>System.loadLibrary(&quot;megjb&quot;);</code></pre><p>将其注释掉之后，安装Demo后再次运行命令，输出结果为：</p><pre><code>Stopping: com.outfit7.mytalkingtomfreeStarting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity }Status: okActivity: com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivityThisTime: 3404TotalTime: 3404WaitTime: 3447Complete</code></pre><p>看到冷启动时间明显少了一半以上，已经确定了咪咕是个大毒瘤。</p><p>然后，再确认联通SDK的影响。</p><p>联通SDK的初始化是要求必须继承他们都Application–<code>com.unicom.shield.UnicomApplicationWrapper</code></p><p>将这个Application替换为普通的Application，安装后再次执行命令，输出结果为：</p><pre><code>Stopping: com.outfit7.mytalkingtomfreeStarting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity }Status: okActivity: com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivityThisTime: 593TotalTime: 593WaitTime: 610Complete</code></pre><p>OK，案件告破，的确是咪咕和小沃这两个大毒瘤导致的。</p><h2 id="解决方案探究"><a href="#解决方案探究" class="headerlink" title="解决方案探究"></a>解决方案探究</h2><p>下面该思考解决方案了，可是这两个都要求在Application中调用，而且咪咕还要求调用它的首屏Activity，基本上正规方式是没什么办法解决了，只能思考奇技淫巧，让这个问题看起来像是解决了。</p><ol><li><p>修改启动Activity的主题</p><p> Activity可以设置theme属性，而theme属性中可以设置windowBackground，具体步骤如下：</p><ul><li><p>在drawable目录中创建xml文件，文件内容是</p><pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:opacity=&quot;opaque&quot;&gt;    &lt;!-- The background color, preferably the same as your normal theme --&gt;    &lt;item android:drawable=&quot;@android:color/white&quot; /&gt;    &lt;!-- 引入想要显示的静态图片，这里我随便弄了张 --&gt;    &lt;item&gt;        &lt;bitmap            android:gravity=&quot;center&quot;            android:src=&quot;@drawable/logo&quot; /&gt;    &lt;/item&gt;&lt;/layer-list&gt;</code></pre></li><li><p>在styles.xml中添加新的style</p><pre><code>&lt;style name=&quot;AppTheme.Launcher&quot; parent=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;&gt;    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/background_test&lt;/item&gt;&lt;/style&gt;</code></pre></li><li><p>给咪咕的启动Activity配置theme</p><pre><code>&lt;activity    android:name=&quot;cn.cmgame.billing.api.GameOpenActivity&quot;    android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;    android:screenOrientation=&quot;sensor&quot;    android:theme=&quot;@style/AppTheme.Launcher&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;    &lt;/intent-filter&gt;    &lt;!-- 设置咪咕启动界面为首Activity --&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.CHINAMOBILE_OMS_GAME&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.CHINAMOBILE_GAMES&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>效果可参见我附件的Demo</p></li></ul></li><li><p>将游戏的退出改成调用home键</p><p> 这个操作看似和冷启动优化无关，其实这样做的目的是给用户一个假象：用户按返回键退出，但是实际上并没退出，app处于后台，下次点击图标时直接唤起</p><p> 这样将冷启动变成了热启动，也算是优化了用户体验（虽然这样比较流氓）。</p><p> 具体是将调用返回键的地方改为调用home键，代码如下：</p><pre><code>@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) {    if (keyCode == KeyEvent.KEYCODE_BACK) {        Intent intent = new Intent(Intent.ACTION_MAIN);        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        intent.addCategory(Intent.CATEGORY_HOME);        startActivity(intent);        return true;    }    return super.onKeyDown(keyCode, event);}</code></pre><p> 这样做的应用很多，游戏应该很少，因为游戏的耗电、内存占用决定了其很难在后台常驻。</p></li></ol><p>以上，接入三网支付SDK的游戏需要给咪咕的首屏设置theme</p><p>我在使用时发现，咪咕首屏在调用我方首屏时，设置的background会一闪而逝，因此建议将background的图片设置为咪咕的logo图片，这样不显得突兀</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="https://developer.android.com/topic/performance/vitals/launch-time" target="_blank" rel="noopener">https://developer.android.com/topic/performance/vitals/launch-time</a></p></blockquote><blockquote><p><a href="https://github.com/DanluTeam/ColdStart" target="_blank" rel="noopener">https://github.com/DanluTeam/ColdStart</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android应用冷启动时间优化探究&quot;&gt;&lt;a href=&quot;#Android应用冷启动时间优化探究&quot; class=&quot;headerlink&quot; title=&quot;Android应用冷启动时间优化探究&quot;&gt;&lt;/a&gt;Android应用冷启动时间优化探究&lt;/h1&gt;&lt;h2 id=&quot;启
      
    
    </summary>
    
    
      <category term="Android" scheme="http://smarxpan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>游戏接入运营商三网Android SDK整理</title>
    <link href="http://smarxpan.github.io/2018/02/07/%E8%BF%90%E8%90%A5%E5%95%86%E4%B8%89%E7%BD%91sdk%E6%8E%A5%E5%85%A5%E6%95%B4%E7%90%86/"/>
    <id>http://smarxpan.github.io/2018/02/07/运营商三网sdk接入整理/</id>
    <published>2018-02-07T07:15:30.000Z</published>
    <updated>2018-12-15T03:43:57.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏接入运营商三网Android-SDK整理"><a href="#游戏接入运营商三网Android-SDK整理" class="headerlink" title="游戏接入运营商三网Android SDK整理"></a>游戏接入运营商三网Android SDK整理</h1><p>记录下坑爹的三网支付运营商接入。</p><h2 id="融合支付"><a href="#融合支付" class="headerlink" title="融合支付"></a>融合支付</h2><p>移动、联通和电信都提供了三网融合支付。但是运营商提供的融合支付仅支持他们自有渠道，外放渠道均不支持。如需要使用wostore和爱游戏渠道，单接他们的短代sdk即可。</p><p>因此需要自行融合三网支付接入游戏。</p><h3 id="咪咕的特殊之处（需验证是否符合需求）"><a href="#咪咕的特殊之处（需验证是否符合需求）" class="headerlink" title="咪咕的特殊之处（需验证是否符合需求）"></a>咪咕的特殊之处（需验证是否符合需求）</h3><p>Q. 三网融合计费功能集成。</p><ol><li>26005 SDK已经集成移动，电信，联通三家运营商的统一计费功能，能够满足一次集 成，运营商话费支付全覆盖的业务场景。无需自行集成三家运营商的计费SDK。</li><li>三网融合计费功能需在业务平台进行申请后才能够使用。( 暂时没有对合作伙伴开放申请)</li></ol><h3 id="联通"><a href="#联通" class="headerlink" title="联通"></a>联通</h3><p>联通沃商店提供的SDK中，自带有测试用计费文件(Multimode_UniPay_payinfo.jar包含计费文件），如果CP做成的版本是为在沃商店上线使用的，只需要在代码中，将支付接口中计费点编号与Cp开发者社区里面的审核过的计费点编号对应好，打包成APK后，自测通过，即可提交开发者社区，开发者社区会自动为CP替换正式的计费文件。<br>如果CP使用SDK的三网支付能力，必须到开发者社区进行打包。如果CP自己下载计费点文件，自行打包，移动支付能力将不能使用<br>渠道外放单网包，只有联通话费能力，电信、移动卡支付会跳转到沃币支付是正常的。打包方式：到社区》渠道商打包，下载外渠道商用计费文件替换payinfo.jar自行打包即可</p><p>不使用sdk自带第三方支付，如何配置？</p><p>A：</p><pre><code>&lt;meta-data android:name=&quot;wostore_billing_otherpay&quot;&gt;&lt;/meta-data&gt; android:value=&quot;false&quot;/&gt;</code></pre><p>设置为false，并且支付宝的相关jar可以不加入工程libs目录</p><h3 id="爱游戏融合"><a href="#爱游戏融合" class="headerlink" title="爱游戏融合"></a>爱游戏融合</h3><p>融合只要在接入段自测联通即可，咪咕计费嵌入游戏后为测试计费点，提交包体，爱游戏OPEN系统送咪咕完成计费加固后，咪咕计费点正式生效。</p><p><a href="http://open.play.cn/dev/wiki/p1?page=1" target="_blank" rel="noopener">http://open.play.cn/dev/wiki/p1?page=1</a></p><h3 id="migu"><a href="#migu" class="headerlink" title="migu"></a>migu</h3><p>Q. 如果 不接入联通支付 或 自行拟合三网包 ，联通相关的文件和配置可以 省略吗?<br>可以省略，但是如果有后续三网融合计费的业务需求，建议保留。<br>如果不接入联通、电信支付，可以删除如下文件和配置:</p><ol><li>SDK/AndroidManifest.xml.activity.txt中联通相关配置，如下: </li></ol><pre><code>&lt;service android:name=&quot;com.unicom.channel.paysecurity.TouchPayService&quot;</code></pre><p>/&gt;<br>            <activity android:name="com.unicom.channel.paysecurity.SecurityActivity" android:configchanges="screenSize|orientation" android:exported="true" android:theme="@android:style/Theme.Translucent.NoTitleBar"><br>                 </activity></p><ol start="2"><li><p>SDK/AndroidManifest.xml.permision.txt中联通相关配置，如下:</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt; &lt;!-- 联通pay --&gt;</code></pre></li><li>SDK\libs\armeabi目录下libsmsprotocol.so、libunipaychsec.so两个文件</li><li><p>SDK\assets目录<br>下feeInfo.dat、unicom_channel_classez.jar、unicom_channel_resource.dat 三个文件</p><p>咪咕游戏SDK和Baidu、360等其他SDK融合时的不兼容，如何解决?</p></li><li>开一个空的Activity，在这个Activity中完成其他SDK的初始化接口调用;</li><li>然后再加载咪咕的so文件(System.loadLibrary(“”megjb”“););</li><li>同时在Activity 跳转到GameOpenActivity中;</li><li>GameOpenActivity 会跳转到 cn.cmgame.demo.MainActivity ——在string.xml中<br>的”g_class_name”指定的游戏Activity——中调用咪咕的初始化接口。 (避免两个初始化的接口在同一个Activity中调用)</li></ol><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><ol><li><p>计费文件</p><p> 先上传游戏，获取爱游戏的计费文件</p><p> 沃商店的计费文件比较特殊，上传游戏之后就可以获取，但是每个渠道的</p></li><li><p>渠道打包</p><p> 先提交通过审核一个通用包，再进行单独渠道包的上传</p></li><li><p>计费能力申报顺序</p><p> 爱游戏和联通并行–&gt;获取爱游戏和联通计费能力后–&gt;融合爱游戏和联通到咪咕后台上传打包</p></li></ol><h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><pre><code>#---------------爱游戏短代--------------keep class cn.egame.terminal.**{*;}#---------------爱游戏短代-------------#---------------联通短代----------------libraryjars  libs/Multimode_UniPay_base.jar-libraryjars  libs/miniapay.jar-libraryjars  libs/alipaysdk.jar-libraryjars  libs/MobileSecSdk.jar-libraryjars  libs/utdid4all-1.0.4.jar-keep class com.unipay.account.**{*;}-keep class com.unicom.dcLoader.**{*;}-keep class com.unicom.wostore.unipay.paysecurity.**{*;}-keep class com.wow.shell.**{*;}-keep class cn.egame.terminal.miniapay.**{*;}-keep class egame.terminal.feesmslib.jni.**{*;}-keep class com.alipay.sdk.**{*;}-keep class com.alipay.auth.**{*;}-keep class com.alipay.android.app.**{*;}#---------------联通短代---------------</code></pre><h2 id="支付和初始化API及配置相关"><a href="#支付和初始化API及配置相关" class="headerlink" title="支付和初始化API及配置相关"></a>支付和初始化API及配置相关</h2><h3 id="联通-1"><a href="#联通-1" class="headerlink" title="联通"></a>联通</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol><li>继承UnicomApplicationWrapper</li><li><p>初始化</p><pre><code>public void initPayContext(Activity activity, UnipayPayResultListener listener)</code></pre></li></ol><h4 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h4><p>单机</p><pre><code>Utils.getInstances().pay(Context mContext,   String number,UnipayPayResultListener listener);</code></pre><p>联网</p><pre><code>Utils.getInstances().payOnline (Context mContext,  String number,   String monthType,  String orderid,UnipayPayResultListener listener);</code></pre><h4 id="支付回调（listener）"><a href="#支付回调（listener）" class="headerlink" title="支付回调（listener）"></a>支付回调（listener）</h4><pre><code>public class mCallback implements UnipayPayResultListener{        public void PayResult(String paycode, int flag, int flag2, String error) {            // flag为支付回调结果，flag2为回调类型，error为当前结果描述，paycode是完整的计费点编码            switch (flag) {            case 1://success                //此处放置支付请求已提交的相关处理代码                break;            case 2://fail                //此处放置支付请求失败的相关处理代码                break;            case 3://cancel                //此处放置支付请求被取消的相关处理代码                break;            default:                break;        }}flag2参数，请参考如下定义：SMS_SEND = 5;VAC_SEND = 8;MONTH_SEND = 11;UNMONTH_SEND = 12;DX_SMS_SEND = 13;SUBCOMMIT_VAC = 20; // VAC支付提交SUCCESS_SMS = 21; // 短代支付成功SUBCOMMIT_WEBALIPAY = 22; // WEB支付宝提交SUCCESS_KALIPAY = 23; // 支付宝快捷支付成功SUBCOMMIT_SZF = 24; // 神州付提交SUCCESS_EXCHANGECODE = 25; // 兑换成功CANCEL_FIRSTPAGE = 26; // 第一次确认支付取消CANCEL_VACPAYPAGE = 27; // VAC支付页面取消CANCEL_OTHERPAYPAGE = 28; // 其他支付页面取消CANCEL_CHANGECODE = 29; // 兑换码页面取消CANCEL_VACYZM = 30; // 话费验证码页面取消CANCEL_CHINAMOBILE = 31;SUCCESS_POINTPAY = 32; // 沃币支付成功SUBCOMMIT_ANCI = 35;UNSUBCOMMIT_ANCI = 36;SUBCOMMIT_BANKCARD = 37;SUBCOMMIT_WEIXINPAY = 38;SUBCOMMIT_QQPAY = 39;</code></pre><h3 id="咪咕"><a href="#咪咕" class="headerlink" title="咪咕"></a>咪咕</h3><h4 id="获取运营商"><a href="#获取运营商" class="headerlink" title="获取运营商"></a>获取运营商</h4><pre><code>IOperatorCallback operatorCallback = new IOperatorCallback() {             @Override            public void onResult(int resultCode) { switch (resultCode) {                case IsOperator.CMCC://移动                break;                case IsOperator.CUCC://联通                break;                case IsOperator.CTCC://电信                break;                case IsOperator.UNKNOWN://未知状态             break;             }}};   GameInterface.CheckOperator(this, operatorCallback);</code></pre><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>application中加载so：</p><pre><code>System.loadLibrary(&quot;megjb&quot;);</code></pre><p>设置咪咕为首屏Activity</p><p>游戏Activity中调用初始化</p><pre><code> void GameInterface.initializeApp(Activity main, String loginNo, ILoginCallbackcallback);</code></pre><h4 id="支付-1"><a href="#支付-1" class="headerlink" title="支付"></a>支付</h4><pre><code>IPayCallback billingCallback = new IPayCallback() {Overridepublic void onResult(int resultCode, String billingIndex, Object arg) {        // 游戏业务收到付费结果后的处理逻辑        switch (resultCode) {            case BillingResult.SUCCESS: //成功                break;            case BillingResult.FAILED://失败                break; ......};void GameInterface.doBilling(Context context, int propsType, String billingIndex, String cpParam, IPayCallback billingCallback);</code></pre><p>只有成功和失败，没有错误代码</p><h3 id="爱游戏"><a href="#爱游戏" class="headerlink" title="爱游戏"></a>爱游戏</h3><pre><code>&lt;meta-data android:name=&quot;EGAME_IAPPPAY&quot; android:value=&quot;false&quot; /&gt;&lt;meta-data android:name=&quot;EGAME_ALIPAY&quot; android:value=&quot;false&quot; /&gt;&lt;meta-data android:name=&quot;EGAME_UNIPAY&quot; android:value=&quot;false&quot; /&gt;&lt;meta-data android:name=&quot;EGAME_NOWWECHATPAY&quot; android:value=&quot;false&quot; /&gt;&lt;meta-data android:name=&quot;EGAME_BESTPAY&quot; android:value=&quot;false&quot; /&gt;&lt;meta-data android:name=&quot;EGAME_CARDPSWD&quot;  android:value=&quot;false&quot;/&gt;&lt;meta-data android:name=&quot;EGAME_HUAFEI_CARD&quot; android:value=&quot;false&quot;/&gt;</code></pre><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><p>activity中初始化</p><pre><code>EgamePay.init(this);</code></pre><h4 id="支付-2"><a href="#支付-2" class="headerlink" title="支付"></a>支付</h4><pre><code>HashMap payParams=new HashMap();payParams.put(EgamePay.PAY_PARAMS_KEY_TOOLS_ALIAS, &quot;TOOL888&quot;);EgamePay.pay(Activity activity, Map payParams,EgamePayListener listener);</code></pre><h4 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h4><pre><code>错误代码    错误描述-2    未获得到实例，init重复调用，或与pay方法调用间隔过短-10    外部SDK无法读取，检查工程及打好的apk的assets/egame文件夹内是否缺少文件-11    打开输出文件错误,外部SDK无法解包-12    MD5校验错误-13    文件拷贝错误-14    无法初始化实例-20    sdk初始化异常-100    Activity对象为空-101    feeInfo.dat计费文件未找到或者数据读取异常-102    无法读取当前应用信息-103    应用信息校验失败，请检查包名及app_name是否和申报一致(注：信息更新后需要重新下载计费配置文件)-104    非电信用户-106    计费金额错误-108    无可用计费通道-109    manifest配置错误-200    初始化失败，无法进行计费-201    计费回调对象为空-202    计费道具别名错误-203    渠道ID数据异常-204    SERVICE_CODE数据异常-205    自定义参数格式异常-206    计费方法调用过快-207    计费短信发送失败,检查手机及卡-209    :第3方支付失败，请检查对应第3方资源及manifest中相关注册是否遗漏，以及检查是否混淆-300    获取计费流水号网络异常-301    获取计费流水号数据异常，检查open平台游戏状态是否正常-111    未使用最新SDK资源，检查so及jar包【针对4.1.6及以上】</code></pre><h2 id="客户端功能划分"><a href="#客户端功能划分" class="headerlink" title="客户端功能划分"></a>客户端功能划分</h2><pre><code>[46000] MCC:460 MNC:00 China China Mobile[46002] MCC:460 MNC:02 China China Mobile[46007] MCC:460 MNC:07 China China Mobile[46003] MCC:460 MNC:03 China China Telecom[46005] MCC:460 MNC:05 China China Telecom</code></pre><ol><li><p>接口请求</p><p> 计费策略接口和日志接口。</p><p> 接口内容已写完。</p></li><li><p>接入计费逻辑</p><p> 其中包括接入三网计费，同时隐藏了一个计费文件，这个计费文件保存了我方计费点查询到运营商计费点的信息。这个计费文件需要从后台导出，放在游戏中。</p><p> 接入计费逻辑的时候要考虑好接入过程。</p><p> 计费逻辑已完成</p></li><li><p>本地计费策略的缓存和处理</p><p> 包括计费策略的缓存和更新。缓存即存储到本地数据库。根据每次触发计费，处理策略的更新。</p><p> 每次计费成功，需要更新本地的计费策略。</p><p> 开始时设置一个计时器，用来处理计费策略的更新。</p></li></ol><ol start="4"><li>日志接口十分重要，需要思考好所有日志的类型–尽量细分。</li></ol><p>初始化接口删除cellId,localAeraCode,meid</p><p>初始化时需将策略放入缓存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;游戏接入运营商三网Android-SDK整理&quot;&gt;&lt;a href=&quot;#游戏接入运营商三网Android-SDK整理&quot; class=&quot;headerlink&quot; title=&quot;游戏接入运营商三网Android SDK整理&quot;&gt;&lt;/a&gt;游戏接入运营商三网Android SDK
      
    
    </summary>
    
    
      <category term="Android" scheme="http://smarxpan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2自定义拦截器和ConverterFactory实现客户端与服务端加密通信</title>
    <link href="http://smarxpan.github.io/2017/12/06/Retrofit2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8CConverterFactory%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/"/>
    <id>http://smarxpan.github.io/2017/12/06/Retrofit2自定义拦截器和ConverterFactory实现客户端与服务端加密通信/</id>
    <published>2017-12-06T13:05:21.000Z</published>
    <updated>2018-12-17T12:11:38.295Z</updated>
    
    <content type="html"><![CDATA[<p>网络请求框架使用的retrofit，客户端与服务端之间需要加密通信并且请求需要gzip压缩。为完成这一需求，需要拦截请求和响应。特此记录下修改请求的过程，希望可以帮助有需要的人。</p><h3 id="处理request"><a href="#处理request" class="headerlink" title="处理request"></a>处理request</h3><p>retrofit2使用okhttp3.x，请求上的处理只需要给okhttp添加拦截器即可</p><p>这里与服务端通信相互之间对称加密，并且需要开启gzip压缩，因此这里定义了三个拦截器完成这一需求</p><ol><li><p>修改请求头</p><pre><code>public class RequestHeaderInterceptor implements Interceptor {    @Override    public Response intercept(Chain chain) throws IOException {        Request originalRequest = chain.request();        Request updateRequest = originalRequest.newBuilder()                .header(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;)                .header(&quot;Accept&quot;, &quot;*/*&quot;)                .header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)                .build();        return chain.proceed(updateRequest);    }}</code></pre></li><li><p>加密请求内容</p><pre><code>public class RequestEncryptInterceptor implements Interceptor {    @Override    public Response intercept(Chain chain) throws IOException {        Request request = chain.request();        RequestBody body = request.body();        Buffer buffer = new Buffer();        body.writeTo(buffer);        Charset charset = Charset.forName(&quot;UTF-8&quot;);        MediaType contentType = body.contentType();        if (contentType != null) {            charset = contentType.charset(charset);        }        String paramsStr = buffer.readString(charset);        try {            paramsStr = EncryptUtils.encryptParams(paramsStr);        } catch (Exception e) {            LogUtils.e(e);        }        RequestBody requestBody = RequestBody.create(MediaType.parse(&quot;text/plain; charset=utf-8&quot;), paramsStr);        request = request.newBuilder()                .post(requestBody)                .build();        return chain.proceed(request);    }}</code></pre></li><li><p>启用Gzip压缩</p><pre><code>public class GzipRequsetInterceptor implements Interceptor {    @Override    public Response intercept(Chain chain) throws IOException {        Request originalRequest = chain.request();        if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) {            return chain.proceed(originalRequest);        }        Request compressedRequest = originalRequest.newBuilder()                .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)                .method(originalRequest.method(), gzip(originalRequest.body()))                .build();        return chain.proceed(compressedRequest);    }    private RequestBody gzip(final RequestBody body) {        return new RequestBody() {            @Override            public MediaType contentType() {                return body.contentType();            }            @Override            public long contentLength() throws IOException {                return -1;            }            @Override            public void writeTo(BufferedSink sink) throws IOException {                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));                body.writeTo(gzipSink);                gzipSink.close();            }        };    }}</code></pre></li></ol><h3 id="处理response"><a href="#处理response" class="headerlink" title="处理response"></a>处理response</h3><p>对response处理需要未retrofit设置自定义的<code>ConverterFactory</code>，因客户端与服务端使用json通信，因此我们参考官方提供<code>GsonConverterFactory</code>编写</p><p>自定义<code>GsonConverterFactory</code>，其实相对于原版只修改了<code>responseBodyConverter</code>方法的内容，<code>requestBodyConverter</code>依旧用的原版内容。</p><blockquote><p>注意,<code>GsonRequestBodyConverter</code>类的修饰符不是public，需要将其代码拷贝出来</p></blockquote><pre><code>public final class CustomGsonConverterFactory extends Converter.Factory {    private final Gson gson;    public static CustomGsonConverterFactory create() {        return create(new Gson());    }    @SuppressWarnings(&quot;ConstantConditions&quot;) // Guarding public API nullability.    public static CustomGsonConverterFactory create(Gson gson) {        if (gson == null) throw new NullPointerException(&quot;gson == null&quot;);        return new CustomGsonConverterFactory(gson);    }    private CustomGsonConverterFactory(Gson gson) {        this.gson = gson;    }    @Override    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));        return new CustomGsonResponseConverter&lt;&gt;(gson, adapter);    }    @Override    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));        return new GsonRequestBodyConverter&lt;&gt;(gson, adapter);    }}</code></pre><p>修改GsonResponseConverter，使其解密后再处理内容。</p><blockquote><p>注意：这里预处理json的过程并非通用步骤，因我的json格式是    <code>{      &quot;code&quot;: 0,      &quot;message&quot;: &quot;success&quot;,      &quot;data&quot;: {          ...      }    }</code>这样的，如果你的不同请换一种方式。</p></blockquote><pre><code>class CustomGsonResponseConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; {    private final Gson gson;    private final TypeAdapter&lt;T&gt; adapter;    CustomGsonResponseConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) {        this.gson = gson;        this.adapter = adapter;    }    @Override    public T convert(ResponseBody value) throws IOException {        try {            String originalBody = value.string();            // 解密            String body = EncryptUtils.decryptParams(originalBody);            // 获取json中的code，对json进行预处理            JSONObject json = new JSONObject(body);            int code = json.optInt(&quot;code&quot;);            // 当code不为0时，设置data为{}，这样转化就不会出错了            if (code != 0) {                json.put(&quot;data&quot;, new JSONObject());                body = json.toString();            }            return adapter.fromJson(body);        } catch (Exception e) {            throw new RuntimeException(e.getMessage());        } finally {            value.close();        }    }</code></pre><p>这里也贴一下原版的<code>GsonRequestBodyConverter</code>：</p><pre><code>class GsonRequestBodyConverter&lt;T&gt; implements Converter&lt;T, RequestBody&gt; {  private static final MediaType MEDIA_TYPE = MediaType.parse(&quot;application/json; charset=UTF-8&quot;);  private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);  private final Gson gson;  private final TypeAdapter&lt;T&gt; adapter;  GsonRequestBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) {    this.gson = gson;    this.adapter = adapter;  }  @Override public RequestBody convert(T value) throws IOException {    Buffer buffer = new Buffer();    Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8);    JsonWriter jsonWriter = gson.newJsonWriter(writer);    adapter.write(jsonWriter, value);    jsonWriter.close();    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());  }}</code></pre><p>这样<code>build.gradle</code>中就可以删掉引入的<code>GsonConverterFactory</code>了</p><h3 id="整合使用"><a href="#整合使用" class="headerlink" title="整合使用"></a>整合使用</h3><p>使用方式如下</p><pre><code>Retrofit retrofit = new Retrofit.Builder()                .client(getOkHttpClient())                .addConverterFactory(CustomGsonConverterFactory.create())                .baseUrl(BASE_URL)                .build();</code></pre><p>其中，okhttpClient方法：</p><pre><code>@NonNullprivate OkHttpClient getOkHttpClient() {    OkHttpClient.Builder okHttpClientBuilder = new OkHttpClient.Builder();    okHttpClientBuilder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS)            .writeTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS)            .readTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS)            .addInterceptor(new RequestHeaderInterceptor())            .addInterceptor(new RequestEncryptInterceptor())            .addInterceptor(new GzipRequsetInterceptor());    return okHttpClientBuilder.build();}</code></pre><p>就酱</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络请求框架使用的retrofit，客户端与服务端之间需要加密通信并且请求需要gzip压缩。为完成这一需求，需要拦截请求和响应。特此记录下修改请求的过程，希望可以帮助有需要的人。&lt;/p&gt;
&lt;h3 id=&quot;处理request&quot;&gt;&lt;a href=&quot;#处理request&quot; cla
      
    
    </summary>
    
    
      <category term="Android" scheme="http://smarxpan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6/7和Ubuntu安装shadowsocks-libev及使用</title>
    <link href="http://smarxpan.github.io/2017/05/03/CentOS6-7%E5%92%8CUbuntu%E5%AE%89%E8%A3%85shadowsocks-libv/"/>
    <id>http://smarxpan.github.io/2017/05/03/CentOS6-7和Ubuntu安装shadowsocks-libv/</id>
    <published>2017-05-03T07:15:30.000Z</published>
    <updated>2019-01-03T02:44:05.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CentOS6-7安装"><a href="#CentOS6-7安装" class="headerlink" title="CentOS6/7安装"></a>CentOS6/7安装</h2><ol><li><p>安装Fedora软件源</p><pre><code>cd /etc/yum.repos.d/wget https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-6/librehat-shadowsocks-epel-6.repo</code></pre></li><li><p>update</p><pre><code>sudo yum update</code></pre></li><li><p>安装</p><pre><code>sudo yum install shadowsocks-libev</code></pre></li></ol><h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><pre><code>sudo apt-get install software-properties-common -ysudo add-apt-repository ppa:max-c-lv/shadowsocks-libev -ysudo apt-get updatesudo apt install shadowsocks-libev</code></pre><h2 id="通用源码安装-针对无法直接安装的系统"><a href="#通用源码安装-针对无法直接安装的系统" class="headerlink" title="通用源码安装(针对无法直接安装的系统)"></a>通用源码安装(针对无法直接安装的系统)</h2><ol><li><p>通过git下载源码（请先安装git）</p><pre><code>git clone https://github.com/shadowsocks/shadowsocks-libev.gitcd shadowsocks-libevgit submodule update --init --recursive</code></pre></li><li><p>编译安装</p><p> 安装依赖</p><pre><code># Installation of basic build dependencies## Debian / Ubuntusudo apt-get install --no-install-recommends gettext build-essential autoconf libtool libpcre3-dev asciidoc xmlto libev-dev libc-ares-dev automake libmbedtls-dev libsodium-dev## CentOS / Fedora / RHELsudo yum install gettext gcc autoconf libtool automake make asciidoc xmlto c-ares-devel libev-devel## Archsudo pacman -S gettext gcc autoconf libtool automake make asciidoc xmlto c-ares libev# Installation of Libsodiumexport LIBSODIUM_VER=1.0.13wget https://download.libsodium.org/libsodium/releases/libsodium-$LIBSODIUM_VER.tar.gztar xvf libsodium-$LIBSODIUM_VER.tar.gzpushd libsodium-$LIBSODIUM_VER./configure --prefix=/usr &amp;&amp; makesudo make installpopdsudo ldconfig# Installation of MbedTLSexport MBEDTLS_VER=2.6.0wget https://tls.mbed.org/download/mbedtls-$MBEDTLS_VER-gpl.tgztar xvf mbedtls-$MBEDTLS_VER-gpl.tgzpushd mbedtls-$MBEDTLS_VERmake SHARED=1 CFLAGS=-fPICsudo make DESTDIR=/usr installpopdsudo ldconfig</code></pre><p> 进入shadowsocks-libev源码目录</p><pre><code># Start building./autogen.sh &amp;&amp; ./configure &amp;&amp; makesudo make install</code></pre></li></ol><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><pre><code>ss-server -c /etc/shadowsocks.json</code></pre><p>json示例：</p><pre><code>{  &quot;server&quot;: &quot;0.0.0.0&quot;,  &quot;server_port&quot;: 443,  &quot;password&quot;: &quot;yourpassword&quot;,  &quot;method&quot;: &quot;aes-256-gcm&quot;}</code></pre><p>如果启动时报错：</p><pre><code>This system doesn&apos;t provide enough entropy to quickly generate high-quality random numbersInstalling the rng-utils/rng-tools or haveged packages may help.On virtualized Linux environments, also consider using virtio-rng.The service will not start until enough entropy has been collected.</code></pre><p>是说系统没有足够的熵，两种解决方式，1. 多等一会就好了 2.按提示所说安装rng-tools</p><p>安装rng-tools：</p><pre><code># ubuntuapt-get install rng-tools# centosyum install rng-tools</code></pre><h2 id="启动BBR加速"><a href="#启动BBR加速" class="headerlink" title="启动BBR加速"></a>启动BBR加速</h2><p>注意：仅KVM架构可用，OVZ不可以这样安装</p><h3 id="Debian-8-Ubuntu-14-04"><a href="#Debian-8-Ubuntu-14-04" class="headerlink" title="Debian 8+ / Ubuntu 14.04+"></a>Debian 8+ / Ubuntu 14.04+</h3><ul><li><p>下载最新内核,最新内核查看<a href="http://kernel.ubuntu.com/~kernel-ppa/mainline" target="_blank" rel="noopener">这里</a>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.16/linux-image-4.16.0-041600-generic_4.16.0-041600.201804012230_amd64.deb</span><br></pre></td></tr></table></figure></li><li><p>安装内核</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i linux-image-4.*.deb</span><br></pre></td></tr></table></figure></li><li><p>删除旧内核(可选)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep linux-image </span><br><span class="line">apt-get purge 旧内核</span><br></pre></td></tr></table></figure></li><li><p>更新 grub 系统引导文件并重启</p><pre><code>update-grubreboot</code></pre></li></ul><h2 id="启用simple-obfs（非必选）"><a href="#启用simple-obfs（非必选）" class="headerlink" title="启用simple-obfs（非必选）"></a>启用simple-obfs（非必选）</h2><p>如需使用混淆请继续，不需要请离开</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><pre><code># Debian / Ubuntusudo apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libev-dev asciidoc xmlto automake# CentOS / Fedora / RHELsudo yum install gcc autoconf libtool automake make zlib-devel openssl-devel asciidoc xmlto# Archsudo pacman -Syu gcc autoconf libtool automake make zlib openssl asciidoc xmlto# Alpineapk add gcc autoconf make libtool automake zlib-devel openssl asciidoc xmlto libpcre32 libev-dev g++ linux-headersgit clone https://github.com/shadowsocks/simple-obfs.gitcd simple-obfsgit submodule update --init --recursive./autogen.sh./configure &amp;&amp; makesudo make install</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>客户端</p><pre><code>ss-local -c config.json --plugin obfs-local --plugin-opts &quot;obfs=http;obfs-host=www.bing.com&quot;</code></pre><p>服务端</p><pre><code>ss-server -c config.json --plugin obfs-server --plugin-opts &quot;obfs=http&quot;</code></pre><h2 id="查询连接到该服务的人数"><a href="#查询连接到该服务的人数" class="headerlink" title="查询连接到该服务的人数"></a>查询连接到该服务的人数</h2><pre><code>netstat -anp|grep ip:port |grep ESTABLISHED</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CentOS6-7安装&quot;&gt;&lt;a href=&quot;#CentOS6-7安装&quot; class=&quot;headerlink&quot; title=&quot;CentOS6/7安装&quot;&gt;&lt;/a&gt;CentOS6/7安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装Fedora软件源&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://smarxpan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>编程的智慧by王垠</title>
    <link href="http://smarxpan.github.io/2017/04/20/%E7%BC%96%E7%A8%8B%E7%9A%84%E6%99%BA%E6%85%A7by%E7%8E%8B%E5%9E%A0/"/>
    <id>http://smarxpan.github.io/2017/04/20/编程的智慧by王垠/</id>
    <published>2017-04-20T07:15:30.000Z</published>
    <updated>2018-12-17T11:06:12.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程的智慧by王垠"><a href="#编程的智慧by王垠" class="headerlink" title="编程的智慧by王垠"></a>编程的智慧by王垠</h2><p>编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而由于软件行业喜欢标新立异，喜欢把简单的事情搞复杂，我希望这些文字能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。</p><h3 id="反复推敲代码"><a href="#反复推敲代码" class="headerlink" title="反复推敲代码"></a>反复推敲代码</h3><p>既然“天才是百分之一的灵感，百分之九十九的汗水”，那我先来谈谈这汗水的部分吧。有人问我，提高编程水平最有效的办法是什么？我想了很久，终于发现最有效的办法，其实是反反复复地修改和推敲代码。</p><p>在IU的时候，由于Dan Friedman的严格教导，我们以写出冗长复杂的代码为耻。如果你代码多写了几行，这老顽童就会大笑，说：“当年我解决这个问题，只写了5行代码，你回去再想想吧……” 当然，有时候他只是夸张一下，故意刺激你的，其实没有人能只用5行代码完成。然而这种提炼代码，减少冗余的习惯，却由此深入了我的骨髓。</p><p>有些人喜欢炫耀自己写了多少多少万行的代码，仿佛代码的数量是衡量编程水平的标准。然而，如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。你会制造出越来越多平庸甚至糟糕的代码。在这种意义上，很多人所谓的“工作经验”，跟他代码的质量，其实不一定成正比。如果有几十年的工作经验，却从来不回头去提炼和反思自己的代码，那么他也许还不如一个只有一两年经验，却喜欢反复推敲，仔细领悟的人。</p><p>有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。</p><p>就像文学作品一样，代码是不可能一蹴而就的。灵感似乎总是零零星星，陆陆续续到来的。任何人都不可能一笔呵成，就算再厉害的程序员，也需要经过一段时间，才能发现最简单优雅的写法。有时候你反复提炼一段代码，觉得到了顶峰，没法再改进了，可是过了几个月再回头来看，又发现好多可以改进和简化的地方。这跟写文章一模一样，回头看几个月或者几年前写的东西，你总能发现一些改进。</p><p>所以如果反复提炼代码已经不再有进展，那么你可以暂时把它放下。过几个星期或者几个月再回头来看，也许就有焕然一新的灵感。这样反反复复很多次之后，你就积累起了灵感和智慧，从而能够在遇到新问题的时候直接朝正确，或者接近正确的方向前进。</p><h3 id="写优雅的代码"><a href="#写优雅的代码" class="headerlink" title="写优雅的代码"></a>写优雅的代码</h3><p>人们都讨厌“面条代码”（spaghetti code），因为它就像面条一样绕来绕去，没法理清头绪。那么优雅的代码一般是什么形状的呢？经过多年的观察，我发现优雅的代码，在形状上有一些明显的特征。</p><p>如果我们忽略具体的内容，从大体结构上来看，优雅的代码看起来就像是一些整整齐齐，套在一起的盒子。如果跟整理房间做一个类比，就很容易理解。如果你把所有物品都丢在一个很大的抽屉里，那么它们就会全都混在一起。你就很难整理，很难迅速的找到需要的东西。但是如果你在抽屉里再放几个小盒子，把物品分门别类放进去，那么它们就不会到处乱跑，你就可以比较容易的找到和管理它们。</p><p>优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。这是因为程序所做的几乎一切事情，都是信息的传递和分支。你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的if语句，它看起来就会像这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (...) &#123;</span><br><span class="line">  if (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到了吗？在我的代码里面，if语句几乎总是有两个分支。它们有可能嵌套，有多层的缩进，而且else分支里面有可能出现少量重复的代码。然而这样的结构，逻辑却非常严密和清晰。在后面我会告诉你为什么if语句最好有两个分支。</p><h3 id="写模块化的代码"><a href="#写模块化的代码" class="headerlink" title="写模块化的代码"></a>写模块化的代码</h3><p>有些人吵着闹着要让程序“模块化”，结果他们的做法是把代码分部到多个文件和目录里面，然后把这些目录或者文件叫做“module”。他们甚至把这些目录分放在不同的VCS repo里面。结果这样的作法并没有带来合作的流畅，而是带来了许多的麻烦。这是因为他们其实并不理解什么叫做“模块”，肤浅的把代码切割开来，分放在不同的位置，其实非但不能达到模块化的目的，而且制造了不必要的麻烦。</p><p>真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。</p><p>想要达到很好的模块化，你需要做到以下几点：</p><ul><li><p>避免写太长的函数。如果发现函数太大了，就应该把它拆分成几个更小的。通常我写的函数长度都不超过40行。对比一下，一般笔记本电脑屏幕所能容纳的代码行数是50行。我可以一目了然的看见一个40行的函数，而不需要滚屏。只有40行而不是50行的原因是，我的眼球不转的话，最大的视角只看得到40行代码。</p><p>如果我看代码不转眼球的话，我就能把整片代码完整的映射到我的视觉神经里，这样就算忽然闭上眼睛，我也能看得见这段代码。我发现闭上眼睛的时候，大脑能够更加有效地处理代码，你能想象这段代码可以变成什么其它的形状。40行并不是一个很大的限制，因为函数里面比较复杂的部分，往往早就被我提取出去，做成了更小的函数，然后从原来的函数里面调用。</p></li><li><p>制造小的工具函数。如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。有些帮助函数也许就只有两行，然而它们却能大大简化主要函数里面的逻辑。</p><p>有些人不喜欢使用小的函数，因为他们想避免函数调用的开销，结果他们写出几百行之大的函数。这是一种过时的观念。现代的编译器都能自动的把小的函数内联（inline）到调用它的地方，所以根本不产生函数调用，也就不会产生任何多余的开销。</p><p>同样的一些人，也爱使用宏（macro）来代替小函数，这也是一种过时的观念。在早期的C语言编译器里，只有宏是静态“内联”的，所以他们使用宏，其实是为了达到内联的目的。然而能否内联，其实并不是宏与函数的根本区别。宏与函数有着巨大的区别（这个我以后再讲），应该尽量避免使用宏。为了内联而使用宏，其实是滥用了宏，这会引起各种各样的麻烦，比如使程序难以理解，难以调试，容易出错等等。</p></li><li><p>每个函数只做一件简单的事情。有些人喜欢制造一些“通用”的函数，既可以做这个又可以做那个，它的内部依据某些变量和条件，来“选择”这个函数所要做的事情。比如，你也许写出这样的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  if (getOS().equals(&quot;MacOS&quot;)) &#123;</span><br><span class="line">    a();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    b();</span><br><span class="line">  &#125;</span><br><span class="line">  c();</span><br><span class="line">  if (getOS().equals(&quot;MacOS&quot;)) &#123;</span><br><span class="line">    d();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    e();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这个函数的人，根据系统是否为“MacOS”来做不同的事情。你可以看出这个函数里，其实只有<code>c()</code>是两种系统共有的，而其它的<code>a()</code>, <code>b()</code>, <code>d()</code>, <code>e()</code>都属于不同的分支。</p><p>这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void fooMacOS() &#123;</span><br><span class="line">  a();</span><br><span class="line">  c();</span><br><span class="line">  d();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void fooOther() &#123;</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">  e();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  a();</span><br><span class="line">  b()</span><br><span class="line">  c();</span><br><span class="line">  if (getOS().equals(&quot;MacOS&quot;)) &#123;</span><br><span class="line">    d();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    e();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>a()</code>，<code>b()</code>，<code>c()</code>都是一样的，只有<code>d()</code>和<code>e()</code>根据系统有所不同。那么你可以把<code>a()</code>，<code>b()</code>，<code>c()</code>提取出去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void preFoo() &#123;</span><br><span class="line">  a();</span><br><span class="line">  b()</span><br><span class="line">  c();</span><br></pre></td></tr></table></figure><p>然后制造两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fooMacOS() &#123;</span><br><span class="line">  preFoo();</span><br><span class="line">  d();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void fooOther() &#123;</span><br><span class="line">  preFoo();</span><br><span class="line">  e();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们既共享了代码，又做到了每个函数只做一件简单的事情。这样的代码，逻辑就更加清晰。</p></li><li><p>避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。有些人写代码，经常用类成员来传递信息，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  String x;</span><br><span class="line"></span><br><span class="line">  void findX() &#123;</span><br><span class="line">     ...</span><br><span class="line">     x = ...;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void foo() &#123;</span><br><span class="line">    findX();</span><br><span class="line">    ...</span><br><span class="line">    print(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，他使用<code>findX()</code>，把一个值写入成员<code>x</code>。然后，使用<code>x</code>的值。这样，<code>x</code>就变成了<code>findX</code>和<code>print</code>之间的数据通道。由于<code>x</code>属于<code>class A</code>，这样程序就失去了模块化的结构。由于这两个函数依赖于成员x，它们不再有明确的输入和输出，而是依赖全局的数据。<code>findX</code>和<code>foo</code>不再能够离开<code>class A</code>而存在，而且由于类成员还有可能被其他代码改变，代码变得难以理解，难以确保正确性。</p><p>如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个class，而且更加容易理解，不易出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String findX() &#123;</span><br><span class="line">   ...</span><br><span class="line">   x = ...;</span><br><span class="line">   return x;</span><br><span class="line">&#125;</span><br><span class="line">void foo() &#123;</span><br><span class="line">  String x = findX();</span><br><span class="line">  print(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="写可读的代码"><a href="#写可读的代码" class="headerlink" title="写可读的代码"></a>写可读的代码</h3><p>有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。</p><p>实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。</p><p>有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。这样的情况应该少出现，否则这意味着整个代码的设计都有问题。</p><p>如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要：</p><ol><li><p>使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// put elephant1 into fridge2</span><br><span class="line">put(elephant1, fridge2);</span><br></pre></td></tr></table></figure><p>由于我的函数名<code>put</code>，加上两个有意义的变量名<code>elephant1</code>和<code>fridge2</code>，已经说明了这是在干什么（把大象放进冰箱），所以上面那句注释完全没有必要。</p></li><li><p>局部变量应该尽量接近使用它的地方。有些人喜欢在函数最开头定义很多局部变量，然后在下面很远的地方使用它，就像这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  int index = ...;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  bar(index);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这中间都没有使用过<code>index</code>，也没有改变过它所依赖的数据，所以这个变量定义，其实可以挪到接近使用它的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  int index = ...;</span><br><span class="line">  bar(index);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样读者看到<code>bar(index)</code>，不需要向上看很远就能发现<code>index</code>是如何算出来的。而且这种短距离，可以加强读者对于这里的“计算顺序”的理解。否则如果index在顶上，读者可能会怀疑，它其实保存了某种会变化的数据，或者它后来又被修改过。如果index放在下面，读者就清楚的知道，index并不是保存了什么可变的值，而且它算出来之后就没变过。</p><p>如果你看透了局部变量的本质——它们就是电路里的导线，那你就能更好的理解近距离的好处。变量定义离用的地方越近，导线的长度就越短。你不需要摸着一根导线，绕来绕去找很远，就能发现接收它的端口，这样的电路就更容易理解。</p></li><li><p>局部变量名字应该简短。这貌似跟第一点相冲突，简短的变量名怎么可能有意义呢？注意我这里说的是局部变量，因为它们处于局部，再加上第2点已经把它放到离使用位置尽量近的地方，所以根据上下文你就会容易知道它的意思：</p><p>比如，你有一个局部变量，表示一个操作是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean successInDeleteFile = deleteFile(&quot;foo.txt&quot;);</span><br><span class="line">if (successInDeleteFile) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个局部变量<code>successInDeleteFile</code>大可不必这么啰嗦。因为它只用过一次，而且用它的地方就在下面一行，所以读者可以轻松发现它是<code>deleteFile</code>返回的结果。如果你把它改名为<code>success</code>，其实读者根据一点上下文，也知道它表示”success in deleteFile”。所以你可以把它改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean success = deleteFile(&quot;foo.txt&quot;);</span><br><span class="line">if (success) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法不但没漏掉任何有用的语义信息，而且更加易读。<code>successInDeleteFile</code>这种“<a href="https://en.wikipedia.org/wiki/CamelCase" target="_blank" rel="noopener">camelCase</a>”，如果超过了三个单词连在一起，其实是很碍眼的东西。所以如果你能用一个单词表示同样的意义，那当然更好。</p></li><li><p>不要重用局部变量。很多人写代码不喜欢定义新的局部变量，而喜欢“重用”同一个局部变量，通过反复对它们进行赋值，来表示完全不同意思。比如这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String msg;</span><br><span class="line">if (...) &#123;</span><br><span class="line">  msg = &quot;succeed&quot;;</span><br><span class="line">  log.info(msg);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  msg = &quot;failed&quot;;</span><br><span class="line">  log.info(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样在逻辑上是没有问题的，然而却不易理解，容易混淆。变量<code>msg</code>两次被赋值，表示完全不同的两个值。它们立即被<code>log.info</code>使用，没有传递到其它地方去。这种赋值的做法，把局部变量的作用域不必要的增大，让人以为它可能在将来改变，也许会在其它地方被使用。更好的做法，其实是定义两个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (...) &#123;</span><br><span class="line">  String msg = &quot;succeed&quot;;</span><br><span class="line">  log.info(msg);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  String msg = &quot;failed&quot;;</span><br><span class="line">  log.info(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这两个<code>msg</code>变量的作用域仅限于它们所处的if语句分支，你可以很清楚的看到这两个<code>msg</code>被使用的范围，而且知道它们之间没有任何关系。</p></li><li><p>把复杂的逻辑提取出去，做成“帮助函数”。有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，这样你就可以使用有意义的函数名来代替注释。举一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">// put elephant1 into fridge2</span><br><span class="line">openDoor(fridge2);</span><br><span class="line">if (elephant1.alive()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">closeDoor(fridge2);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你把这片代码提出去定义成一个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void put(Elephant elephant, Fridge fridge) &#123;</span><br><span class="line">  openDoor(fridge);</span><br><span class="line">  if (elephant.alive()) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">  closeDoor(fridge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样原来的代码就可以改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">put(elephant1, fridge2);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更加清晰，而且注释也没必要了。</p></li><li><p>把复杂的表达式提取出去，做成中间变量。有些人听说“函数式编程”是个好东西，也不理解它的真正含义，就在代码里大量使用嵌套的函数。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pizza pizza = makePizza(crust(salt(), butter()),</span><br><span class="line">   topping(onion(), tomato(), sausage()));</span><br></pre></td></tr></table></figure><p>这样的代码一行太长，而且嵌套太多，不容易看清楚。其实训练有素的函数式程序员，都知道中间变量的好处，不会盲目的使用嵌套的函数。他们会把这代码变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Crust crust = crust(salt(), butter());</span><br><span class="line">Topping topping = topping(onion(), tomato(), sausage());</span><br><span class="line">Pizza pizza = makePizza(crust, topping);</span><br></pre></td></tr></table></figure><p>这样写，不但有效地控制了单行代码的长度，而且由于引入的中间变量具有“意义”，步骤清晰，变得很容易理解。</p></li><li><p>在合理的地方换行。对于绝大部分的程序语言，代码的逻辑是和空白字符无关的，所以你可以在几乎任何地方换行，你也可以不换行。这样的语言设计是个好东西，因为它给了程序员自由控制自己代码格式的能力。然而，它也引起了一些问题，因为很多人不知道如何合理的换行。</p></li></ol><p>有些人喜欢利用IDE的自动换行机制，编辑之后用一个热键把整个代码重新格式化一遍，IDE就会把超过行宽限制的代码自动折行。可是这种自动这行，往往没有根据代码的逻辑来进行，不能帮助理解代码。自动换行之后可能产生这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (someLongCondition1() &amp;&amp; someLongCondition2() &amp;&amp; someLongCondition3() &amp;&amp;</span><br><span class="line">  someLongCondition4()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>someLongCondition4()</code>超过了行宽限制，被编辑器自动换到了下面一行。虽然满足了行宽限制，换行的位置却是相当任意的，它并不能帮助人理解这代码的逻辑。这几个boolean表达式，全都用<code>&amp;&amp;</code>连接，所以它们其实处于平等的地位。为了表达这一点，当需要折行的时候，你应该把每一个表达式都放到新的一行，就像这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (someLongCondition1() &amp;&amp;</span><br><span class="line">    someLongCondition2() &amp;&amp;</span><br><span class="line">    someLongCondition3() &amp;&amp;</span><br><span class="line">    someLongCondition4()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每一个条件都对齐，里面的逻辑就很清楚了。再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;failed to find file &#123;&#125; for command &#123;&#125;, with exception &#123;&#125;&quot;, file, command,</span><br><span class="line">  exception);</span><br></pre></td></tr></table></figure><p>这行因为太长，被自动折行成这个样子。<code>file</code>，<code>command</code>和<code>exception</code>本来是同一类东西，却有两个留在了第一行，最后一个被折到第二行。它就不如手动换行成这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;failed to find file &#123;&#125; for command &#123;&#125;, with exception &#123;&#125;&quot;,</span><br><span class="line">  file, command, exception);</span><br></pre></td></tr></table></figure><p>把格式字符串单独放在一行，而把它的参数一并放在另外一行，这样逻辑就更加清晰。</p><p>为了避免IDE把这些手动调整好的换行弄乱，很多IDE（比如IntelliJ）的自动格式化设定里都有“保留原来的换行符”的设定。如果你发现IDE的换行不符合逻辑，你可以修改这些设定，然后在某些地方保留你自己的手动换行。</p><p>说到这里，我必须警告你，这里所说的“不需注释，让代码自己解释自己”，并不是说要让代码看起来像某种自然语言。有个叫Chai的JavaScript测试工具，可以让你这样写代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expect(foo).to.be.a(&apos;string&apos;);</span><br><span class="line">expect(foo).to.equal(&apos;bar&apos;);</span><br><span class="line">expect(foo).to.have.length(3);</span><br><span class="line">expect(tea).to.have.property(&apos;flavors&apos;).with.length(3);</span><br></pre></td></tr></table></figure><p>这种做法是极其错误的。程序语言本来就比自然语言简单清晰，这种写法让它看起来像自然语言的样子，反而变得复杂难懂了。</p><h3 id="写简单的代码"><a href="#写简单的代码" class="headerlink" title="写简单的代码"></a>写简单的代码</h3><p>程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。</p><p>并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，“新”的特性，我基本都只用经过千锤百炼，我觉得值得信赖的那一套。</p><p>现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。</p><ul><li><p>避免使用自增减表达式（i++，++i，i–，–i）。这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。</p><p>其实这两个表达式完全可以分解成两步，把读和写分开：一步更新i的值，另外一步使用i的值。比如，如果你想写<code>foo(i++)</code>，你完全可以把它拆成<code>int t = i; i += 1; foo(t);</code>。如果你想写<code>foo(++i)</code>，可以拆成<code>i += 1; foo(i);</code> 拆开之后的代码，含义完全一致，却清晰很多。到底更新是在取值之前还是之后，一目了然。</p><p>有人也许以为i++或者++i的效率比拆开之后要高，这只是一种错觉。这些代码经过基本的编译器优化之后，生成的机器代码是完全没有区别的。自增减表达式只有在两种情况下才可以安全的使用。一种是在for循环的update部分，比如<code>for(int i = 0; i &lt; 5; i++)</code>。另一种情况是写成单独的一行，比如<code>i++;</code>。这两种情况是完全没有歧义的。你需要避免其它的情况，比如用在复杂的表达式里面，比如<code>foo(i++)</code>，<code>foo(++i) + foo(i)</code>，…… 没有人应该知道，或者去追究这些是什么意思。</p></li><li><p>永远不要省略花括号。很多语言允许你在某种情况下省略掉花括号，比如C，Java都允许你在if语句里面只有一句话的时候省略掉花括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (...)</span><br><span class="line">  action1();</span><br></pre></td></tr></table></figure><p>咋一看少打了两个字，多好。可是这其实经常引起奇怪的问题。比如，你后来想要加一句话<code>action2()</code>到这个if里面，于是你就把代码改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (...)</span><br><span class="line">  action1();</span><br><span class="line">  action2();</span><br></pre></td></tr></table></figure><p>为了美观，你很小心的使用了<code>action1()</code>的缩进。咋一看它们是在一起的，所以你下意识里以为它们只会在if的条件为真的时候执行，然而<code>action2()</code>却其实在if外面，它会被无条件的执行。我把这种现象叫做“光学幻觉”（optical illusion），理论上每个程序员都应该发现这个错误，然而实际上却容易被忽视。</p><p>那么你问，谁会这么傻，我在加入<code>action2()</code>的时候加上花括号不就行了？可是从设计的角度来看，这样其实并不是合理的作法。首先，也许你以后又想把<code>action2()</code>去掉，这样你为了样式一致，又得把花括号拿掉，烦不烦啊？其次，这使得代码样式不一致，有的if有花括号，有的又没有。况且，你为什么需要记住这个规则？如果你不问三七二十一，只要是if-else语句，把花括号全都打上，就可以想都不用想了，就当C和Java没提供给你这个特殊写法。这样就可以保持完全的一致性，减少不必要的思考。</p><p>有人可能会说，全都打上花括号，只有一句话也打上，多碍眼啊？然而经过实行这种编码规范几年之后，我并没有发现这种写法更加碍眼，反而由于花括号的存在，使得代码界限明确，让我的眼睛负担更小了。</p></li><li><p>合理使用括号，不要盲目依赖操作符优先级。利用操作符的优先级来减少括号，对于<code>1 + 2 * 3</code>这样常见的算数表达式，是没问题的。然而有些人如此的仇恨括号，以至于他们会写出<code>2 &lt;&lt; 7 - 2 * 3</code>这样的表达式，而完全不用括号。</p><p>这里的问题，在于移位操作<code>&lt;&lt;</code>的优先级，是很多人不熟悉，而且是违反常理的。由于<code>x &lt;&lt; 1</code>相当于把<code>x</code>乘以2，很多人误以为这个表达式相当于<code>(2 &lt;&lt; 7) - (2 * 3)</code>，所以等于250。然而实际上<code>&lt;&lt;</code>的优先级比加法<code>+</code>还要低，所以这表达式其实相当于<code>2 &lt;&lt; (7 - 2 * 3)</code>，所以等于4！</p><p>解决这个问题的办法，不是要每个人去把操作符优先级表给硬背下来，而是合理的加入括号。比如上面的例子，最好直接加上括号写成<code>2 &lt;&lt; (7 - 2 * 3)</code>。虽然没有括号也表示同样的意思，但是加上括号就更加清晰，读者不再需要死记<code>&lt;&lt;</code>的优先级就能理解代码。</p></li><li><p>避免使用continue和break。循环语句（for，while）里面出现return是没问题的，然而如果你使用了continue或者break，就会让循环的逻辑和终止条件变得复杂，难以确保正确。</p><p>出现continue或者break的原因，往往是对循环的逻辑没有想清楚。如果你考虑周全了，应该是几乎不需要continue或者break的。如果你的循环里出现了continue或者break，你就应该考虑改写这个循环。改写循环的办法有多种：</p><ol><li>如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。</li><li>如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。</li><li>有时候你可以把break替换成return，从而去掉break。</li><li>如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。</li></ol><p>下面我对这些情况举一些例子。</p><p>情况1：下面这段代码里面有一个continue：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; goodNames = new ArrayList&lt;&gt;();</span><br><span class="line">for (String name: names) &#123;</span><br><span class="line">  if (name.contains(&quot;bad&quot;)) &#123;</span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line">  goodNames.add(name);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它说：“如果name含有’bad’这个词，跳过后面的循环代码……” 注意，这是一种“负面”的描述，它不是在告诉你什么时候“做”一件事，而是在告诉你什么时候“不做”一件事。为了知道它到底在干什么，你必须搞清楚continue会导致哪些语句被跳过了，然后脑子里把逻辑反个向，你才能知道它到底想做什么。这就是为什么含有continue和break的循环不容易理解，它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。</p><p>其实，我们只需要把continue的条件反向，这段代码就可以很容易的被转换成等价的，不含continue的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; goodNames = new ArrayList&lt;&gt;();</span><br><span class="line">for (String name: names) &#123;</span><br><span class="line">  if (!name.contains(&quot;bad&quot;)) &#123;</span><br><span class="line">    goodNames.add(name);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goodNames.add(name);</code>和它之后的代码全部被放到了if里面，多了一层缩进，然而continue却没有了。你再读这段代码，就会发现更加清晰。因为它是一种更加“正面”地描述。它说：“在name不含有’bad’这个词的时候，把它加到goodNames的链表里面……”</p><p>情况2：for和while头部都有一个循环的“终止条件”，那本来应该是这个循环唯一的退出条件。如果你在循环中间有break，它其实给这个循环增加了一个退出条件。你往往只需要把这个条件合并到循环头部，就可以去掉break。</p><p>比如下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (condition1) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if (condition2) &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当condition成立的时候，break会退出循环。其实你只需要把condition2反转之后，放到while头部的终止条件，就可以去掉这种break语句。改写后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (condition1 &amp;&amp; !condition2) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况表面上貌似只适用于break出现在循环开头或者末尾的时候，然而其实大部分时候，break都可以通过某种方式，移动到循环的开头或者末尾。具体的例子我暂时没有，等出现的时候再加进来。</p><p>情况3：很多break退出循环之后，其实接下来就是一个return。这种break往往可以直接换成return。比如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasBadName(List&lt;String&gt; names) &#123;</span><br><span class="line">    boolean result = false;</span><br><span class="line"></span><br><span class="line">    for (String name: names) &#123;</span><br><span class="line">        if (name.contains(&quot;bad&quot;)) &#123;</span><br><span class="line">            result = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数检查names链表里是否存在一个名字，包含“bad”这个词。它的循环里包含一个break语句。这个函数可以被改写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasBadName(List&lt;String&gt; names) &#123;</span><br><span class="line">    for (String name: names) &#123;</span><br><span class="line">        if (name.contains(&quot;bad&quot;)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后的代码，在name里面含有“bad”的时候，直接用<code>return true</code>返回，而不是对result变量赋值，break出去，最后才返回。如果循环结束了还没有return，那就返回false，表示没有找到这样的名字。使用return来代替break，这样break语句和result这个变量，都一并被消除掉了。</p><p>我曾经见过很多其他使用continue和break的例子，几乎无一例外的可以被消除掉，变换后的代码变得清晰很多。我的经验是，99%的break和continue，都可以通过替换成return语句，或者翻转if条件的方式来消除掉。剩下的1%含有复杂的逻辑，但也可以通过提取一个帮助函数来消除掉。修改之后的代码变得容易理解，容易确保正确。</p></li></ul><h3 id="写直观的代码"><a href="#写直观的代码" class="headerlink" title="写直观的代码"></a>写直观的代码</h3><p>我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。比如，Unix命令行有一种“巧妙”的写法是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2 &amp;&amp; command3</span><br></pre></td></tr></table></figure><p>由于Shell语言的逻辑操作<code>a &amp;&amp; b</code>具有“短路”的特性，如果<code>a</code>等于false，那么<code>b</code>就没必要执行了。这就是为什么当command1成功，才会执行command2，当command2成功，才会执行command3。同样，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 || command2 || command3</span><br></pre></td></tr></table></figure><p>操作符<code>||</code>也有类似的特性。上面这个命令行，如果command1成功，那么command2和command3都不会被执行。如果command1失败，command2成功，那么command3就不会被执行。</p><p>这比起用if语句来判断失败，似乎更加巧妙和简洁，所以有人就借鉴了这种方式，在程序的代码里也使用这种方式。比如他们可能会写这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (action1() || action2() &amp;&amp; action3()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看得出来这代码是想干什么吗？action2和action3什么条件下执行，什么条件下不执行？也许稍微想一下，你知道它在干什么：“如果action1失败了，执行action2，如果action2成功了，执行action3”。然而那种语义，并不是直接的“映射”在这代码上面的。比如“失败”这个词，对应了代码里的哪一个字呢？你找不出来，因为它包含在了<code>||</code>的语义里面，你需要知道<code>||</code>的短路特性，以及逻辑或的语义才能知道这里面在说“如果action1失败……”。每一次看到这行代码，你都需要思考一下，这样积累起来的负荷，就会让人很累。</p><p>其实，这种写法是滥用了逻辑操作<code>&amp;&amp;</code>和<code>||</code>的短路特性。这两个操作符可能不执行右边的表达式，原因是为了机器的执行效率，而不是为了给人提供这种“巧妙”的用法。这两个操作符的本意，只是作为逻辑操作，它们并不是拿来给你代替if语句的。也就是说，它们只是碰巧可以达到某些if语句的效果，但你不应该因此就用它来代替if语句。如果你这样做了，就会让代码晦涩难懂。</p><p>上面的代码写成笨一点的办法，就会清晰很多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!action1()) &#123;</span><br><span class="line">  if (action2()) &#123;</span><br><span class="line">    action3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我很明显的看出这代码在说什么，想都不用想：如果action1()失败了，那么执行action2()，如果action2()成功了，执行action3()。你发现这里面的一一对应关系吗？<code>if</code>=如果，<code>!</code>=失败，…… 你不需要利用逻辑学知识，就知道它在说什么。</p><h3 id="写无懈可击的代码"><a href="#写无懈可击的代码" class="headerlink" title="写无懈可击的代码"></a>写无懈可击的代码</h3><p>在之前一节里，我提到了自己写的代码里面很少出现只有一个分支的if语句。我写出的if语句，大部分都有两个分支，所以我的代码很多看起来是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (...) &#123;</span><br><span class="line">  if (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return false;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。</p><p>很多人写if语句喜欢省略else的分支，因为他们觉得有些else分支的代码重复了。比如我的代码里，两个else分支都是<code>return true</code>。为了避免重复，他们省略掉那两个else分支，只在最后使用一个<code>return true</code>。这样，缺了else分支的if语句，控制流自动“掉下去”，到达最后的<code>return true</code>。他们的代码看起来像这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (...) &#123;</span><br><span class="line">  if (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><p>这种写法看似更加简洁，避免了重复，然而却很容易出现疏忽和漏洞。嵌套的if语句省略了一些else，依靠语句的“控制流”来处理else的情况，是很难正确的分析和推理的。如果你的if条件里使用了<code>&amp;&amp;</code>和<code>||</code>之类的逻辑运算，就更难看出是否涵盖了所有的情况。</p><p>由于疏忽而漏掉的分支，全都会自动“掉下去”，最后返回意想不到的结果。即使你看一遍之后确信是正确的，每次读这段代码，你都不能确信它照顾了所有的情况，又得重新推理一遍。这简洁的写法，带来的是反复的，沉重的头脑开销。这就是所谓“面条代码”，因为程序的逻辑分支，不是像一棵枝叶分明的树，而是像面条一样绕来绕去。</p><p>另外一种省略else分支的情况是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;&quot;;</span><br><span class="line">if (x &lt; 5) &#123;</span><br><span class="line">  s = &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这段代码的人，脑子里喜欢使用一种“缺省值”的做法。<code>s</code>缺省为null，如果x&lt;5，那么把它改变（mutate）成“ok”。这种写法的缺点是，当<code>x&lt;5</code>不成立的时候，你需要往上面看，才能知道s的值是什么。这还是你运气好的时候，因为s就在上面不远。很多人写这种代码的时候，s的初始值离判断语句有一定的距离，中间还有可能插入一些其它的逻辑和赋值操作。这样的代码，把变量改来改去的，看得人眼花，就容易出错。</p><p>现在比较一下我的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br><span class="line">if (x &lt; 5) &#123;</span><br><span class="line">  s = &quot;ok&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  s = &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法貌似多打了一两个字，然而它却更加清晰。这是因为我们明确的指出了<code>x&lt;5</code>不成立的时候，s的值是什么。它就摆在那里，它是<code>&quot;&quot;</code>（空字符串）。注意，虽然我也使用了赋值操作，然而我并没有“改变”s的值。s一开始的时候没有值，被赋值之后就再也没有变过。我的这种写法，通常被叫做更加“函数式”，因为我只赋值一次。</p><p>如果我漏写了else分支，Java编译器是不会放过我的。它会抱怨：“在某个分支，s没有被初始化。”这就强迫我清清楚楚的设定各种条件下s的值，不漏掉任何一种情况。</p><p>当然，由于这个情况比较简单，你还可以把它写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = x &lt; 5 ? &quot;ok&quot; : &quot;&quot;;</span><br></pre></td></tr></table></figure><p>对于更加复杂的情况，我建议还是写成if语句为好。</p><h3 id="正确处理错误"><a href="#正确处理错误" class="headerlink" title="正确处理错误"></a>正确处理错误</h3><p>使用有两个分支的if语句，只是我的代码可以达到无懈可击的其中一个原因。这样写if语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。</p><p>程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。</p><p>错误处理是一个古老的问题，可是经过了几十年，还是很多人没搞明白。Unix的系统API手册，一般都会告诉你可能出现的返回值和错误信息。比如，Linux的<a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a>系统调用手册里面有如下内容：</p><pre>RETURN VALUE On success, the number of bytes read is returned...On error, -1 is returned, and errno is set appropriately.ERRORSEAGAIN, EBADF, EFAULT, EINTR, EINVAL, ...</pre><p>很多初学者，都会忘记检查<code>read</code>的返回值是否为-1，觉得每次调用<code>read</code>都得检查返回值真繁琐，不检查貌似也相安无事。这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就必须要对这个-1作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。</p><p>对于Java来说，这相对方便一些。Java的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union类型”。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String foo() throws MyException &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里MyException是一个错误返回。你可以认为这个函数返回一个union类型：<code>{String, MyException}</code>。任何调用<code>foo</code>的代码，必须对MyException作出合理的处理，才有可能确保程序的正确运行。Union类型是一种相当先进的类型，目前只有极少数语言（比如Typed Racket）具有这种类型，我在这里提到它，只是为了方便解释概念。掌握了概念之后，你其实可以在头脑里实现一个union类型系统，这样使用普通的语言也能写出可靠的代码。</p><p>由于Java的类型系统强制要求函数在类型里面声明可能出现的异常，而且强制调用者处理可能出现的异常，所以基本上不可能出现由于疏忽而漏掉的情况。但有些Java程序员有一种恶习，使得这种安全机制几乎完全失效。每当编译器报错，说“你没有catch这个foo函数可能出现的异常”时，有些人想都不想，直接把代码改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125; catch (Exception e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>或者最多在里面放个log，或者干脆把自己的函数类型上加上<code>throws Exception</code>，这样编译器就不再抱怨。这些做法貌似很省事，然而都是错误的，你终究会为此付出代价。</p><p>如果你把异常catch了，忽略掉，那么你就不知道foo其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。这当然迟早会出问题，因为你根本不知道自己在干什么。</p><p>catch异常的时候，你不应该使用Exception这么宽泛的类型。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，因为它会不经意的catch住另外的异常（比如B）。你的代码逻辑是基于判断A是否出现，可你却catch所有的异常（Exception类），所以当其它的异常B出现的时候，你的代码就会出现莫名其妙的问题，因为你以为A出现了，而其实它没有。这种bug，有时候甚至使用debugger都难以发现。</p><p>如果你在自己函数的类型加上<code>throws Exception</code>，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着<code>throws Exception</code>，这毛病就传得更远。我的经验是，尽量在异常出现的当时就作出处理。否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。</p><p>另外，try { … } catch里面，应该包含尽量少的代码。比如，如果<code>foo</code>和<code>bar</code>都可能产生异常A，你的代码应该尽可能写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125; catch (A e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  bar();</span><br><span class="line">&#125; catch (A e) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  foo();</span><br><span class="line">  bar();</span><br><span class="line">&#125; catch (A e) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>第一种写法能明确的分辨是哪一个函数出了问题，而第二种写法全都混在一起。明确的分辨是哪一个函数出了问题，有很多的好处。比如，如果你的catch代码里面包含log，它可以提供给你更加精确的错误信息，这样会大大地加速你的调试过程。</p><h3 id="正确处理null指针"><a href="#正确处理null指针" class="headerlink" title="正确处理null指针"></a>正确处理null指针</h3><p>穷举的思想是如此的有用，依据这个原理，我们可以推出一些基本原则，它们可以让你无懈可击的处理null指针。</p><p>首先你应该知道，许多语言（C，C++，Java，C#，……）的类型系统对于null的处理，其实是完全错误的。这个错误源自于<a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Tony Hoare</a>最早的设计，Hoare把这个错误称为自己的“<a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank" rel="noopener">billion dollar mistake</a>”，因为由于它所产生的财产和人力损失，远远超过十亿美元。</p><p>这些语言的类型系统允许null出现在任何对象（指针）类型可以出现的地方，然而null其实根本不是一个合法的对象。它不是一个String，不是一个Integer，也不是一个自定义的类。null的类型本来应该是NULL，也就是null自己。根据这个基本观点，我们推导出以下原则：</p><ul><li><p>尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制。虽然写法上有点别扭，然而Java的异常，和函数的返回值合并在一起，基本上可以当成union类型来用。比如，如果你有一个函数find，可以帮你找到一个String，也有可能什么也找不到，你可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String find() throws NotFoundException &#123;</span><br><span class="line">  if (...) &#123;</span><br><span class="line">    return ...;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new NotFoundException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java的类型系统会强制你catch这个NotFoundException，所以你不可能像漏掉检查null一样，漏掉这种情况。Java的异常也是一个比较容易滥用的东西，不过我已经在上一节告诉你如何正确的使用异常。</p><p>Java的try…catch语法相当的繁琐和蹩脚，所以如果你足够小心的话，像<code>find</code>这类函数，也可以返回null来表示“没找到”。这样稍微好看一些，因为你调用的时候不必用try…catch。很多人写的函数，返回null来表示“出错了”，这其实是对null的误用。“出错了”和“没有”，其实完全是两码事。“没有”是一种很常见，正常的情况，比如查哈希表没找到，很正常。“出错了”则表示罕见的情况，本来正常情况下都应该存在有意义的值，偶然出了问题。如果你的函数要表示“出错了”，应该使用异常，而不是null。</p></li><li><p>不要catch NullPointerException。有些人写代码很nice，他们喜欢“容错”。首先他们写一些函数，这些函数里面不大小心，没检查null指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  String found = find();</span><br><span class="line">  int len = found.length();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当foo调用产生了异常，他们不管三七二十一，就把调用的地方改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当found是null的时候，NullPointerException就会被捕获并且得到处理。这其实是很错误的作法。首先，上一节已经提到了，<code>catch (Exception e)</code>这种写法是要绝对避免的，因为它捕获所有的异常，包括NullPointerException。这会让你意外地捕获try语句里面出现的NullPointerException，从而把代码的逻辑搅得一塌糊涂。</p><p>另外就算你写成<code>catch (NullPointerException e)</code>也是不可以的。由于foo的内部缺少了null检查，才出现了NullPointerException。现在你不对症下药，倒把每个调用它的地方加上catch，以后你的生活就会越来越苦。正确的做法应该是改动foo，而不改调用它的代码。foo应该被改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  String found = find();</span><br><span class="line">  if (found != null) &#123;</span><br><span class="line">    int len = found.length();</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在null可能出现的当时就检查它是否是null，然后进行相应的处理。</p></li><li><p>不要把null放进“容器数据结构”里面。所谓容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。</p><p>解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。</p><p>需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  String name = null;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以可以这样，是因为null只可能在A对象的name成员里出现，你不用怀疑其它的成员因此成为null。所以你每次访问name成员时，检查它是否是null就可以了，不需要对其他成员也做同样的检查。</p></li><li><p>函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播。null很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”。有时候它表示“出错了”，“失败了”。有时候它甚至可以表示“成功了”，…… 这其中有很多误用之处，不过无论如何，你必须理解每一个null的意义，不能给混淆起来。</p><p>如果你调用的函数有可能返回null，那么你应该在第一时间对null做出“有意义”的处理。比如，上述的函数<code>find</code>，返回null表示“没找到”，那么调用<code>find</code>的代码就应该在它返回的第一时间，检查返回值是否是null，并且对“没找到”这种情况，作出有意义的处理。</p><p>“有意义”是什么意思呢？我的意思是，使用这函数的人，应该明确的知道在拿到null的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。如果你违反了这一点，就有可能采用一种不负责任，危险的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String foo() &#123;</span><br><span class="line">  String found = find();</span><br><span class="line">  if (found == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当看到find()返回了null，foo自己也返回null。这样null就从一个地方，游走到了另一个地方，而且它表示另外一个意思。如果你不假思索就写出这样的代码，最后的结果就是代码里面随时随地都可能出现null。到后来为了保护自己，你的每个函数都会写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void foo(A a, B b, C c) &#123;</span><br><span class="line">  if (a == null) &#123; ... &#125;</span><br><span class="line">  if (b == null) &#123; ... &#125;</span><br><span class="line">  if (c == null) &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数作者：明确声明不接受null参数，当参数是null时立即崩溃。不要试图对null进行“容错”，不要让程序继续往下执行。如果调用者使用了null作为参数，那么调用者（而不是函数作者）应该对程序的崩溃负全责。</p><p>上面的例子之所以成为问题，就在于人们对于null的“容忍态度”。这种“保护式”的写法，试图“容错”，试图“优雅的处理null”，其结果是让调用者更加肆无忌惮的传递null给你的函数。到后来，你的代码里出现一堆堆nonsense的情况，null可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了null是什么意思，该做什么，所有人都把null踢给其他人。最后这null像瘟疫一样蔓延开来，到处都是，成为一场噩梦。</p><p>正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是null，如果你给我null，程序崩溃了该你自己负责。至于调用者代码里有null怎么办，他自己该知道怎么处理（参考以上几条），不应该由函数作者来操心。</p><p>采用强硬态度一个很简单的做法是使用<code>Objects.requireNonNull()</code>。它的定义很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span><br><span class="line">  if (obj == null) &#123;</span><br><span class="line">    throw new NullPointerException();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以用这个函数来检查不想接受null的每一个参数，只要传进来的参数是null，就会立即触发<code>NullPointerException</code>崩溃掉，这样你就可以有效地防止null指针不知不觉传递到其它地方去。</p></li><li><p>使用@NotNull和@Nullable标记。IntelliJ提供了@NotNull和@Nullable两种标记，加在类型前面，这样可以比较简洁可靠地防止null指针的出现。IntelliJ本身会对含有这种标记的代码进行静态分析，指出运行时可能出现<code>NullPointerException</code>的地方。在运行时，会在null指针不该出现的地方产生<code>IllegalArgumentException</code>，即使那个null指针你从来没有deference。这样你可以在尽量早期发现并且防止null指针的出现。</p></li><li><p>使用Optional类型。Java 8和Swift之类的语言，提供了一种叫Optional的类型。正确的使用这种类型，可以在很大程度上避免null的问题。null指针的问题之所以存在，是因为你可以在没有“检查”null的情况下，“访问”对象的成员。</p></li></ul><p>Optional类型的设计原理，就是把“检查”和“访问”这两个操作合二为一，成为一个“原子操作”。这样你没法只访问，而不进行检查。这种做法其实是ML，Haskell等语言里的模式匹配（pattern matching）的一个特例。模式匹配使得类型判断和访问成员这两种操作合二为一，所以你没法犯错。</p><p>比如，在Swift里面，你可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let found = find()</span><br><span class="line">if let content = found &#123;</span><br><span class="line">  print(&quot;found: &quot; + content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你从<code>find()</code>函数得到一个Optional类型的值<code>found</code>。假设它的类型是<code>String?</code>，那个问号表示它可能包含一个String，也可能是nil。然后你就可以用一种特殊的if语句，同时进行null检查和访问其中的内容。这个if语句跟普通的if语句不一样，它的条件不是一个Bool，而是一个变量绑定<code>let content = found</code>。</p><p>我不是很喜欢这语法，不过这整个语句的含义是：如果found是nil，那么整个if语句被略过。如果它不是nil，那么变量content被绑定到found里面的值（unwrap操作），然后执行<code>print(&quot;found: &quot; + content)</code>。由于这种写法把检查和访问合并在了一起，你没法只进行访问而不检查。</p><p>Java 8的做法比较蹩脚一些。如果你得到一个Optional<string>类型的值found，你必须使用“函数式编程”的方式，来写这之后的代码：</string></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; found = find();</span><br><span class="line">found.ifPresent(content -&gt; System.out.println(&quot;found: &quot; + content));</span><br></pre></td></tr></table></figure><p>这段Java代码跟上面的Swift代码等价，它包含一个“判断”和一个“取值”操作。ifPresent先判断found是否有值（相当于判断是不是null）。如果有，那么将其内容“绑定”到lambda表达式的content参数（unwrap操作），然后执行lambda里面的内容，否则如果found没有内容，那么ifPresent里面的lambda不执行。</p><p>Java的这种设计有个问题。判断null之后分支里的内容，全都得写在lambda里面。在函数式编程里，这个lambda叫做“<a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="noopener">continuation</a>”，Java把它叫做 “<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" target="_blank" rel="noopener">Consumer</a>”，它表示“如果found不是null，拿到它的值，然后应该做什么”。由于lambda是个函数，你不能在里面写<code>return</code>语句返回出外层的函数。比如，如果你要改写下面这个函数（含有null）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static String foo() &#123;</span><br><span class="line">  String found = find();</span><br><span class="line">  if (found != null) &#123;</span><br><span class="line">    return found;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会比较麻烦。因为如果你写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String foo() &#123;</span><br><span class="line">  Optional&lt;String&gt; found = find();</span><br><span class="line">  found.ifPresent(content -&gt; &#123;</span><br><span class="line">    return content;    // can&apos;t return from foo here</span><br><span class="line">  &#125;);</span><br><span class="line">  return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的<code>return a</code>，并不能从函数<code>foo</code>返回出去。它只会从lambda返回，而且由于那个lambda（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#accept-T-" target="_blank" rel="noopener">Consumer.accept</a>）的返回类型必须是<code>void</code>，编译器会报错，说你返回了String。由于Java里closure的自由变量是只读的，你没法对lambda外面的变量进行赋值，所以你也不能采用这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static String foo() &#123;</span><br><span class="line">  Optional&lt;String&gt; found = find();</span><br><span class="line">  String result = &quot;&quot;;</span><br><span class="line">  found.ifPresent(content -&gt; &#123;</span><br><span class="line">    result = content;    // can&apos;t assign to result</span><br><span class="line">  &#125;);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，虽然你在lambda里面得到了found的内容，如何使用这个值，如何返回一个值，却让人摸不着头脑。你平时的那些Java编程手法，在这里几乎完全废掉了。实际上，判断null之后，你必须使用Java 8提供的一系列古怪的<a href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" target="_blank" rel="noopener">函数式编程操作</a>：<code>map</code>, <code>flatMap</code>, <code>orElse</code>之类，想法把它们组合起来，才能表达出原来代码的意思。比如之前的代码，只能改写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static String foo() &#123;</span><br><span class="line">  Optional&lt;String&gt; found = find();</span><br><span class="line">  return found.orElse(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这简单的情况还好。复杂一点的代码，我还真不知道怎么表达，我怀疑Java 8的Optional类型的方法，到底有没有提供足够的表达力。那里面少数几个东西表达能力不咋的，论工作原理，却可以扯到functor，continuation，甚至monad等高深的理论…… 仿佛用了Optional之后，这语言就不再是Java了一样。</p><p>所以Java虽然提供了Optional，但我觉得可用性其实比较低，难以被人接受。相比之下，Swift的设计更加简单直观，接近普通的过程式编程。你只需要记住一个特殊的语法<code>if let content = found {...}</code>，里面的代码写法，跟普通的过程式语言没有任何差别。</p><p>总之你只要记住，使用Optional类型，要点在于“原子操作”，使得null检查与取值合二为一。这要求你必须使用我刚才介绍的特殊写法。如果你违反了这一原则，把检查和取值分成两步做，还是有可能犯错误。比如在Java 8里面，你可以使用<code>found.get()</code>这样的方式直接访问found里面的内容。在Swift里你也可以使用<code>found!</code>来直接访问而不进行检查。</p><p>你可以写这样的Java代码来使用Optional类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Option&lt;String&gt; found = find();</span><br><span class="line">if (found.isPresent()) &#123;</span><br><span class="line">  System.out.println(&quot;found: &quot; + found.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用这种方式，把检查和取值分成两步做，就可能会出现运行时错误。<code>if (found.isPresent())</code>本质上跟普通的null检查，其实没什么两样。如果你忘记判断<code>found.isPresent()</code>，直接进行<code>found.get()</code>，就会出现<code>NoSuchElementException</code>。这跟<code>NullPointerException</code>本质上是一回事。所以这种写法，比起普通的null的用法，其实换汤不换药。如果你要用Optional类型而得到它的益处，请务必遵循我之前介绍的“原子操作”写法。</p><h3 id="防止过度工程"><a href="#防止过度工程" class="headerlink" title="防止过度工程"></a>防止过度工程</h3><p>人的脑子真是奇妙的东西。虽然大家都知道过度工程（over-engineering）不好，在实际的工程中却经常不由自主的出现过度工程。我自己也犯过好多次这种错误，所以觉得有必要分析一下，过度工程出现的信号和兆头，这样可以在初期的时候就及时发现并且避免。</p><p>过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”……</p><p>这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，把手头的问题先搞定了，再谈以后扩展的问题。</p><p>另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。为了让代码可以重用，最后被自己搞出来的各种框架捆住手脚，最后连可用的代码就没写好。如果可用的代码都写不好，又何谈重用呢？很多一开头就考虑太多重用的工程，到后来被人完全抛弃，没人用了，因为别人发现这些代码太难懂了，自己从头开始写一个，反而省好多事。</p><p>过度地关心“测试”，也会引起过度工程。有些人为了测试，把本来很简单的代码改成“方便测试”的形式，结果引入很多复杂性，以至于本来一下就能写对的代码，最后复杂不堪，出现很多bug。</p><p>世界上有两种“没有bug”的代码。一种是“没有明显的bug的代码”，另一种是“明显没有bug的代码”。第一种情况，由于代码复杂不堪，加上很多测试，各种coverage，貌似测试都通过了，所以就认为代码是正确的。第二种情况，由于代码简单直接，就算没写很多测试，你一眼看去就知道它不可能有bug。你喜欢哪一种“没有bug”的代码呢？</p><p>根据这些，我总结出来的防止过度工程的原则如下：</p><ol><li>先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。</li><li>先写出可用的代码，反复推敲，再考虑是否需要重用的问题。</li><li>先写出可用，简单，明显没有bug的代码，再考虑测试的问题。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编程的智慧by王垠&quot;&gt;&lt;a href=&quot;#编程的智慧by王垠&quot; class=&quot;headerlink&quot; title=&quot;编程的智慧by王垠&quot;&gt;&lt;/a&gt;编程的智慧by王垠&lt;/h2&gt;&lt;p&gt;编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这
      
    
    </summary>
    
    
      <category term="编程" scheme="http://smarxpan.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android权限管理适配</title>
    <link href="http://smarxpan.github.io/2017/04/18/Android%E6%9D%83%E9%99%90%E8%A7%86%E9%A2%91%E9%80%82%E9%85%8D%E7%AE%A1%E7%90%86/"/>
    <id>http://smarxpan.github.io/2017/04/18/Android权限视频适配管理/</id>
    <published>2017-04-18T07:15:30.000Z</published>
    <updated>2018-12-17T07:58:26.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android权限管理适配"><a href="#Android权限管理适配" class="headerlink" title="Android权限管理适配"></a>Android权限管理适配</h1><h2 id="Android权限管理的变动"><a href="#Android权限管理的变动" class="headerlink" title="Android权限管理的变动"></a>Android权限管理的变动</h2><p>从Android6.0开始，权限分为普通权限和许可权限。许可权限分类归组，一个权限授权之后，该组下的权限均可使用。</p><ol><li><p>普通权限</p><p> 只需要在xml申请即可，使用方法和之前6.0以前的一样。在应用安装应用时，会默认获得许可。</p></li><li><p>许可权限</p><p> 当指定target&gt;=23时（Android6.0），需要开发者手动申请以下权限，如果没有手动申请，应用就不会获得这些权限</p><p> Permission Group|Permissions<br> :–|:–|<br> android.permission-group.CALENDAR   |android.permission.READ_CALENDAR<br> android.permission.WRITE_CALENDAR<br> android.permission-group.CAMERA |android.permission.CAMERA<br> android.permission-group.CONTACTS   |android.permission.READ_CONTACTS<br>android.permission.WRITE_CONTACTS<br>android.permission.GET_ACCOUNTS<br> android.permission-group.LOCATION   |android.permission.ACCESS_FINE_LOCATION<br>android.permission.ACCESS_COARSE_LOCATION<br> android.permission-group.MICROPHONE|ndroid.permission.RECORD_AUDIO<br> android.permission-group.PHONE|android.permission.READ_PHONE_STATE<br>android.permission.CALL_PHONE<br>android.permission.READ_CALL_LOG<br>android.permission.WRITE_CALL_LOG<br>com.android.voicemail.permission.ADD_VOICEMAIL<br>android.permission.USE_SIP<br>android.permission.PROCESS_OUTGOING_CALLS<br> android.permission-group.SENSORS|android.permission.BODY_SENSORS<br> android.permission-group.SMS|android.permission.SEND_SMS<br>android.permission.RECEIVE_SMS<br>android.permission.READ_SMS<br>android.permission.RECEIVE_WAP_PUSH<br>android.permission.RECEIVE_MMS<br>android.permission.READ_CELL_BROADCASTS<br> android.permission-group.STORAGE|   android.permission.READ_EXTERNAL_STORAGE<br>android.permission.WRITE_EXTERNAL_STORAGE</p></li></ol><p>动态权限的适配较为麻烦</p><h2 id="短信相关"><a href="#短信相关" class="headerlink" title="短信相关"></a>短信相关</h2><p>修改短信的权限，WRITE_SMS权限， 这个权限从Android4.4开始，Google已经不允许第三方应用使用该权限，但是仅隐藏了相关api，还是可以反射调用，从5.0才开始做了签名和权限的限制。因此5.0之后的手机除部分定制rom的厂商（比如小米、魅族、360OS）外，均无法删除短信。</p><h2 id="关于MIUI"><a href="#关于MIUI" class="headerlink" title="关于MIUI"></a>关于MIUI</h2><p>MIUI系统订制内容较多，权限管理机制与官方差异很大。</p><p>短信相关的有通知类短信和删除短信的行为与官方不同。MIUI将短信分为普通短信与通知类短信，短信权限仅对普通短信生效，通知类短信的权限不对外提供，系统会默认拒绝。而验证码短信基本都是通知类短信，因此需要提醒用户开启。</p><pre><code>/**  * 跳转到MIUI应用权限设置页面  *  * @param context context  */ public static void jumpToMiuiPermissionEditorActivity(Context context) {     try {         // MIUI 8         Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;);         localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;);         localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName());         context.startActivity(localIntent);     } catch (ActivityNotFoundException e) {         try {             // MIUI 5/6/7             Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;);             localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;);             localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName());             context.startActivity(localIntent);         } catch (Exception e1) {             Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);             Uri uri = Uri.fromParts(&quot;package&quot;, context.getPackageName(), null);             intent.setData(uri);             context.startActivity(intent);         }     } }</code></pre><p>MIUI的删除短信权限并未隐藏，还可以请求修改短信的权限来删除短信。</p><h2 id="Android7-0出现FileUriExposedException"><a href="#Android7-0出现FileUriExposedException" class="headerlink" title="Android7.0出现FileUriExposedException"></a>Android7.0出现FileUriExposedException</h2><p>当target指定为25时，如果给出一个<code>file://</code>格式的URI的话，应用会抛出<code>FileUriExposedException</code>。有三种解决方案：</p><ol><li>target设置为小于25的值</li><li><p>VmPolicy方式</p><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) {    StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder();    StrictMode.setVmPolicy(builder.build());}</code></pre><p>放置一个不设防的VmPolicy，不检验uri</p></li><li><p>FileProvider方式</p><p> 替换 <code>file://uri</code> 为 <code>content://uri</code>:</p><p> 增加FileProvider在 AndroidManifest.xml中</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    ...    &lt;application        ...        &lt;provider            android:name=&quot;android.support.v4.content.FileProvider&quot;            android:authorities=&quot;${applicationId}.provider&quot;            android:exported=&quot;false&quot;            android:grantUriPermissions=&quot;true&quot;&gt;            &lt;meta-data                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;                android:resource=&quot;@xml/provider_paths&quot;/&gt;        &lt;/provider&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p> 编写file_paths.xml</p><pre><code>&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;files-path name=&quot;my_images&quot; path=&quot;images/&quot;/&gt;...&lt;/paths&gt;</code></pre><p> 内部的element可以是<code>files-path</code>，<code>cache-path</code>，<code>external-path</code>，<code>external-files-path</code>，<code>external-cache-path</code>，分别对应<code>Context.getFilesDir()</code>，<code>Context.getCacheDir()</code>，<code>Environment.getExternalStorageDirectory()</code>，<code>Context.getExternalFilesDir()</code>，<code>Context.getExternalCacheDir()</code>等几个方法。</p><p> 使用示例：</p><pre><code>Uri photoURI = FileProvider.getUriForFile(context, context.getApplicationContext().getPackageName() + &quot;.provider&quot;, createImageFile());</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android权限管理适配&quot;&gt;&lt;a href=&quot;#Android权限管理适配&quot; class=&quot;headerlink&quot; title=&quot;Android权限管理适配&quot;&gt;&lt;/a&gt;Android权限管理适配&lt;/h1&gt;&lt;h2 id=&quot;Android权限管理的变动&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Android" scheme="http://smarxpan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>MIUI跳转至权限设置页面</title>
    <link href="http://smarxpan.github.io/2017/04/13/MIUI%E8%B7%B3%E8%BD%AC%E8%87%B3%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2/"/>
    <id>http://smarxpan.github.io/2017/04/13/MIUI跳转至权限设置页面/</id>
    <published>2017-04-13T07:15:30.000Z</published>
    <updated>2018-12-17T07:58:05.204Z</updated>
    
    <content type="html"><![CDATA[<p>网上基本只有比较古老的MIUI5/6的跳转方式：</p><pre><code>Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;);localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;);localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName());context.startActivity(localIntent);</code></pre><p>这种方式已经不能满足如今的新版MIUI，所以，自己动手丰衣足食</p><p>电脑打开cmd/terminal， 手机打开应用权限设置页面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/quanxian.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>命令行输入：</p><pre><code>adb shell dumpsys activity | grep &quot;mFocusedActivity&quot;</code></pre><p>输入结果：</p><pre><code>mFocusedActivity: ActivityRecord{11ae2ef u0 com.miui.securitycenter/com.miui.permcenter.permissions.PermissionsEditorActivity t192}</code></pre><p>即为当前打开的权限设置页的Activity</p><p>观察到Activity包名与MIUI 5/6的相同，Activity名字不同，将跳转代码改为：</p><pre><code>// MIUI 7/8Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;);localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;);localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName());context.startActivity(localIntent);</code></pre><p>成功跳转。</p><p>完整的工具类如下：</p><pre><code>public class MiuiUtils {    /**     * 跳转到MIUI应用权限设置页面     *     * @param context context     */    public static void jumpToPermissionSettings(Context context) {        if (isMIUI()) {            try {                // MIUI 7/8                Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;);                localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;);                localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName());                context.startActivity(localIntent);            } catch (Exception e) {                try {                    // MIUI 5/6                    Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;);                    localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;);                    localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName());                    context.startActivity(localIntent);                } catch (Exception e1) {                    // 否则跳转到应用详情                     Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);                    Uri uri = Uri.fromParts(&quot;package&quot;, context.getPackageName(), null);                    intent.setData(uri);                    context.startActivity(intent);                }            }        }    }    /**     * 判断是否是MIUI     */    private static boolean isMIUI() {        String device = Build.MANUFACTURER;        if (device.equals(&quot;Xiaomi&quot;)) {            try {                Properties prop = new Properties();                prop.load(new FileInputStream(new File(Environment.getRootDirectory(), &quot;build.prop&quot;)));                return prop.getProperty(&quot;ro.miui.ui.version.code&quot;, null) != null                        || prop.getProperty(&quot;ro.miui.ui.version.name&quot;, null) != null                        || prop.getProperty(&quot;ro.miui.internal.storage&quot;, null) != null;            } catch (IOException e) {                e.printStackTrace();            }        }        return false;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上基本只有比较古老的MIUI5/6的跳转方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Intent localIntent = new Intent(&amp;quot;miui.intent.action.APP_PERM_EDITOR&amp;quot;);
localIntent.setC
      
    
    </summary>
    
    
      <category term="Android" scheme="http://smarxpan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Looper解析</title>
    <link href="http://smarxpan.github.io/2017/03/22/Looper%E7%9A%84%E6%9C%89%E8%B6%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://smarxpan.github.io/2017/03/22/Looper的有趣问题/</id>
    <published>2017-03-22T07:15:30.000Z</published>
    <updated>2018-12-14T12:59:01.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Looper解析"><a href="#Looper解析" class="headerlink" title="Looper解析"></a>Looper解析</h1><h2 id="正确的主线程运行代码"><a href="#正确的主线程运行代码" class="headerlink" title="正确的主线程运行代码"></a>正确的主线程运行代码</h2><p>一个回调</p><pre><code>public interface MyCallback {    void onSuccess(String result);}</code></pre><p>创建主线程的Handler，然后将回调post到主线程执行</p><pre><code>public class SubThreadTest {    static Handler handler  = new Handler(Looper.getMainLooper());    public static void mockRequest(final String url, final MyCallback callback){        handler.post(new Runnable() {            @Override            public void run() {                callback.onSuccess(url);            }        });    }}</code></pre><p>调用过程</p><pre><code>public class MainActivity extends ActionBarActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        new Thread(new Runnable() {            @Override            public void run() {                SubThreadTest.mockRequest(&quot;heheda&quot;, new MyCallback() {                    @Override                    public void onSuccess(String result) {                        System.out.println(Thread.currentThread().getName()+&quot; : &quot;+result);                        Toast.makeText(getApplicationContext(), result, 0).show();                    }                });                try {                    Thread.sleep(500);                } catch (InterruptedException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                  }                Looper.prepare();                System.out.println(Thread.currentThread().getName()+&quot; : &quot;);                Toast.makeText(getApplicationContext(), &quot;result&quot;, 0).show();                TextView findViewById = (TextView) findViewById(R.id.tv);                findViewById.setText(&quot;heheda&quot;);                Looper.loop();            }        }).start();    }}</code></pre><h2 id="一个有趣的问题"><a href="#一个有趣的问题" class="headerlink" title="一个有趣的问题"></a>一个有趣的问题</h2><pre><code>public class MainActivity extends ActionBarActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        new Thread(new Runnable() {            @Override            public void run() {                try {                    Thread.sleep(500);                } catch (InterruptedException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                  }                Looper.prepare();                System.out.println(Thread.currentThread().getName()+&quot; : &quot;);                Toast.makeText(getApplicationContext(), &quot;result&quot;, 0).show();                TextView findViewById = (TextView) findViewById(R.id.tv);                findViewById.setText(&quot;heheda&quot;);                Looper.loop();            }        }).start();    }}</code></pre><p>子线程中其实可以弹Toast，只是需要使用Looper，而设置TextView却不行</p><p>待查看源码了解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Looper解析&quot;&gt;&lt;a href=&quot;#Looper解析&quot; class=&quot;headerlink&quot; title=&quot;Looper解析&quot;&gt;&lt;/a&gt;Looper解析&lt;/h1&gt;&lt;h2 id=&quot;正确的主线程运行代码&quot;&gt;&lt;a href=&quot;#正确的主线程运行代码&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://smarxpan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用指南</title>
    <link href="http://smarxpan.github.io/2017/02/04/Mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://smarxpan.github.io/2017/02/04/Mac使用指南/</id>
    <published>2017-02-04T07:15:30.000Z</published>
    <updated>2018-12-17T07:58:31.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac使用指南"><a href="#Mac使用指南" class="headerlink" title="Mac使用指南"></a>Mac使用指南</h1><p>之前购入mac时，整理了一篇Mac使用指南，部分内容来自<a href="https://github.com/macdao/ocds-guide-to-setting-up-mac#%E5%8A%9F%E8%83%BD%E9%94%AE" target="_blank" rel="noopener">强迫症的 Mac 设置指南</a>。</p><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><h3 id="功能键"><a href="#功能键" class="headerlink" title="功能键"></a>功能键</h3><p>默认情况下，F1-F12 都是特殊功能，比如调节屏幕亮度。而当你需要键入 F1-F12 时（比如在使用 IntelliJ IDEA 的快捷键时），需要同时按住 Fn。这对于开发人员来说是非常不方便的。</p><p>在<code>系统偏好设置</code>-&gt;<code>键盘</code>-&gt;<code>键盘</code>中，选择将F1、F2等键用作基本功能键</p><blockquote><p>对于新款带有Multi Touch Bar的macbook，此条并不适用</p></blockquote><h3 id="全键盘控制"><a href="#全键盘控制" class="headerlink" title="全键盘控制"></a>全键盘控制</h3><p>当你清理废纸篓时会遇到这样的对话框</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/not_control.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>按回车后会清理废纸篓，但是想要通过键盘控制取消却不可以，只能鼠标点击取消。</p><p>在<code>系统偏好设置</code>-&gt;<code>键盘</code>中，<code>快捷键</code>选项卡中选择<code>所有控制</code>，弹框会变成这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/all_control.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>取消选项上就出现了蓝色边框，这时就可以通过<code>空格键</code>选择该选项，可以通过<code>tab键</code>切换选项</p><h3 id="触摸板和鼠标设置"><a href="#触摸板和鼠标设置" class="headerlink" title="触摸板和鼠标设置"></a>触摸板和鼠标设置</h3><p><code>系统偏好设置</code>-&gt;<code>触摸板</code>、<code>系统偏好设置</code>-&gt;<code>鼠标</code>，里面所有的选项，除了<code>静默点按</code>不需要勾选，所有的选项都勾选，那些选项提供了很多快捷操作</p><h3 id="更改Caps-Lock键为Control键"><a href="#更改Caps-Lock键为Control键" class="headerlink" title="更改Caps Lock键为Control键"></a>更改Caps Lock键为Control键</h3><p>我本人总是使用按住<code>Shift</code>的方式输入大写，或者使用快捷键转换大写，基本用不掉<code>Caps Lock</code>键，因此将其转换为更常用的<code>Control</code></p><p>在<code>系统偏好设置</code>-&gt;<code>键盘</code>-&gt;<code>键盘</code>中， 选择<code>修饰键...</code>， 大写锁定键下拉框中选择Control</p><h3 id="允许安装任何来源的软件"><a href="#允许安装任何来源的软件" class="headerlink" title="允许安装任何来源的软件"></a>允许安装任何来源的软件</h3><p>为了不受限制的安装软件，需要设置<code>系统偏好设置</code>-&gt;<code>安全与隐私</code>中，选择<code>任何来源</code></p><p>新的macOS系统中，将安全与隐私中的任何来源隐藏了，需要在终端执行以下命令：</p><pre><code>sudo spctl --master-disable</code></pre><blockquote><p>这一步需要输入管理员密码，输入时密码不可见。</p></blockquote><p>然后就能在安全与隐私中看到任何来源选项了。</p><h3 id="显示隐藏文件夹"><a href="#显示隐藏文件夹" class="headerlink" title="显示隐藏文件夹"></a>显示隐藏文件夹</h3><p>打开“终端”，执行下面两行命令：</p><pre><code>defaults write com.apple.finder AppleShowAllFiles -bool trueKillAll Finder</code></pre><p>这样就可以默认显示隐藏文件夹，如果不想显示隐藏文件夹：</p><pre><code>defaults write com.apple.finder AppleShowAllFiles -bool falseKillAll Finder</code></pre><h3 id="文件夹上方显示文件夹路径"><a href="#文件夹上方显示文件夹路径" class="headerlink" title="文件夹上方显示文件夹路径"></a>文件夹上方显示文件夹路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/finder_path.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>终端中执行：</p><pre><code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES</code></pre><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>Mac官方快捷键文档地址：<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT201236</a></p><p>下面特别提几个我最常用的几个操作：</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li><p>复制文件</p><p> <code>Command + C</code></p></li><li><p>粘贴文件</p><p> <code>Command + V</code></p></li><li><p>剪切（移动文件）</p><p> <code>Command + C</code>，然后进入你想移动到的文件夹，<code>Command + Option + V</code></p></li><li><p>删除文件</p><p> <code>Command + Delete</code>，清空回收站是<code>Command + Shift + Delete</code></p></li><li><p>设置打开文件默认打开方式</p><p> 使用<code>Command + i</code>呼出文件信息，看到“打开方式”，下拉框中选用想用的应用，选择好后点击“全部更改”</p></li></ol><h3 id="使用应用"><a href="#使用应用" class="headerlink" title="使用应用"></a>使用应用</h3><p>使用Mac上的各种应用时，一般是不需要将其最小化的，用到时用各种快捷键或者<code>Misson Control</code>切换来切换去，不想用时直接<code>Cmd+Q</code>关掉</p><ol start="4"><li><p>切换应用</p><p> <code>Command + tab</code>，切换同一应用的不同窗口是Command + `</p></li><li><p>关闭应用</p><p> <code>Command + W</code></p></li><li><p>退出应用</p><p> <code>Command + Q</code></p></li><li><p>呼出Spotlight搜索</p><p> <code>Command + Space</code>， 这是呼出搜索框，Mac上的搜索框很强大，可搜索文件、应用，离开这个功能简直活不下去（我隐藏了Dock栏，打开应用一般全用这个）。</p></li><li><p>调用<code>Mission Control</code></p><p> 触摸板三指上滑或者<code>Control + ↑</code></p></li></ol><h3 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h3><p>编辑文件时的操作</p><ol start="8"><li><p>删除当前行光标前的内容</p><p> <code>Command + Delete</code></p></li><li><p>删除当前行光标后的内容</p><p> <code>Control + K</code></p></li><li><p>光标移动至行首</p><p><code>Command + ←</code>，此组合加入shift，<code>Command + Shift + ←</code>即为选中内容至行首</p></li><li><p>光标移动至行尾</p><p><code>Command + →</code></p></li><li><p>按单词移动光标</p><p><code>Option + →</code>或<code>Option + ←</code>，同理，加入shift键即可按单词选中内容</p></li></ol><h3 id="授人以渔"><a href="#授人以渔" class="headerlink" title="授人以渔"></a>授人以渔</h3><p>这么多快捷键，记不住怎么办？</p><p>不要紧，记不住可以打小抄啊~ Mac上有这么个神器，帮你打小抄–<code>CheatSheet</code>。记不住看一眼小抄你就知道了。</p><p>官网地址：<a href="https://www.mediaatelier.com/CheatSheet/" target="_blank" rel="noopener">https://www.mediaatelier.com/CheatSheet/</a></p><p>使用很简单，在任意应用中长按<code>Command</code>既可。</p><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><h3 id="压缩、解压文件"><a href="#压缩、解压文件" class="headerlink" title="压缩、解压文件"></a>压缩、解压文件</h3><p>压缩文件可以直接右键压缩</p><p>解压文件才是我们日常使用的痛点，mac本身仅支持zip格式</p><p>这里推荐两款软件：</p><p><code>The Unarchriver</code>，直接去AppStore下载既可，免费的解压软件，支持格式众多，但是仅支持解压，不能压缩</p><p><code>keka</code>，去官网下载免费：<a href="http://www.kekaosx.com/en/" target="_blank" rel="noopener">http://www.kekaosx.com/en/</a>，支持压缩，需要<strong>打开软件，将要压缩的文件或文件夹拖进来</strong>即可以</p><h3 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h3><p>CheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按⌘。</p><p>官网地址：<a href="https://www.mediaatelier.com/CheatSheet/" target="_blank" rel="noopener">https://www.mediaatelier.com/CheatSheet/</a></p><h3 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h3><p>Mac上的包管理工具，相当于Ubuntu上的<code>apt</code>，CentOS上的<code>yum</code>，用于安装各种开发环境，省去折腾开发环境的烦恼。</p><p>安装方式见官网：<a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a></p><h3 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew Cask"></a>Homebrew Cask</h3><p>使用各种命令行安装软件</p><p>官网地址：<a href="https://caskroom.github.io/" target="_blank" rel="noopener">https://caskroom.github.io/</a></p><p>例如安装Chrome：</p><pre><code>brew cask install google-chrome</code></pre><p>常用应用都可以在上面找到，如果不知道应用id，可以搜索：</p><pre><code>brew cask search 应用名</code></pre><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p>iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。</p><p>安装：</p><pre><code>brew cask install iterm2</code></pre><p>比Terminal强大的终端，具体使用可自行查找教程</p><h3 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a>Go2Shell</h3><p>在当前文件夹中打开命令行，安装方式：</p><pre><code>brew cask install go2shell</code></pre><p>安装完成后文件夹上方会出现这个图标：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/folder.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>点击即可在当前文件夹打开命令行，可以打开应用设置默认打开的命令行是Terminal还是iTerm2</p><h3 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h3><p>默认是shell是bash，zsh意为zshell，意味着终极shell，但是设置非常麻烦，直到Oh My Zsh出现，大大简化其设置。zsh拥有许多插件，让你的终端进入彩色时代，并且更为变得强大</p><p>安装方法见官网：<a href="http://ohmyz.sh/" target="_blank" rel="noopener">http://ohmyz.sh/</a></p><h3 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a>MacDown</h3><p>MarkDown写作必备，Mac上最好的MarkDown写作工具。</p><p>安装：</p><pre><code>brew cask install macdown</code></pre><h3 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h3><p>非常棒的文本编辑器，前端开发人员必备。</p><p>安装方式：</p><pre><code>brew cask install sublime-text</code></pre><h3 id="LastPass"><a href="#LastPass" class="headerlink" title="LastPass"></a>LastPass</h3><p>LastPass 是管理密码的工具，支持二次验证，提供所有浏览器插件以及 Mac 桌面版本。</p><p>官网地址：<a href="https://lastpass.com/" target="_blank" rel="noopener">https://lastpass.com/</a></p><h3 id="CleanMyMac"><a href="#CleanMyMac" class="headerlink" title="CleanMyMac"></a>CleanMyMac</h3><p>等同于Mac上的360，提供了卸载器、系统清理等常用功能，这个是付费软件，欢迎支持正版。</p><blockquote><p>参考链接 <a href="https://github.com/macdao/ocds-guide-to-setting-up-mac#%E5%8A%9F%E8%83%BD%E9%94%AE" target="_blank" rel="noopener">https://github.com/macdao/ocds-guide-to-setting-up-mac#%E5%8A%9F%E8%83%BD%E9%94%AE</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac使用指南&quot;&gt;&lt;a href=&quot;#Mac使用指南&quot; class=&quot;headerlink&quot; title=&quot;Mac使用指南&quot;&gt;&lt;/a&gt;Mac使用指南&lt;/h1&gt;&lt;p&gt;之前购入mac时，整理了一篇Mac使用指南，部分内容来自&lt;a href=&quot;https://githu
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://smarxpan.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac设置开机启动</title>
    <link href="http://smarxpan.github.io/2017/01/28/Mac%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <id>http://smarxpan.github.io/2017/01/28/Mac设置开机启动/</id>
    <published>2017-01-28T07:15:30.000Z</published>
    <updated>2018-12-14T12:57:34.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac设置开机启动"><a href="#Mac设置开机启动" class="headerlink" title="Mac设置开机启动"></a>Mac设置开机启动</h1><blockquote><p>本文针对命令行使用的开发工具或自己编写的脚本设置开机启动，图形化界面的程序仅需要<code>设置</code>-&gt;<code>用户与群组</code>-&gt;<code>登录项</code>中即可配置。</p></blockquote><p>相比于Linux开机启动设置的简单方便–配置<code>rc.local</code>文件即可，mac设置开机启动略显麻烦。</p><p>如果是使用homebrew安装软件自然不用考虑开机启动这回事，但有时候想执行自己的脚本或者有特殊需求，就不得不自己处理开机启动了。</p><h2 id="1-使用登录项添加可执行脚本（推荐）"><a href="#1-使用登录项添加可执行脚本（推荐）" class="headerlink" title="1. 使用登录项添加可执行脚本（推荐）"></a>1. 使用登录项添加可执行脚本（推荐）</h2><p>在用户的家目录编写一个sh脚本，例如：</p><p>test.sh</p><pre><code>#!/bin/bash# 在用户的家目录创建一个文件touch ~/haha.txt</code></pre><p>添加可执行权限</p><pre><code>chmod 755 test.sh</code></pre><p>进入<code>设置</code>-&gt;<code>用户与群组</code>-&gt;<code>登录项</code>，点+号，选择test.sh文件即可。</p><p>重启电脑，验证是否新建了文件，如存在说明配置成功，修改该文件内容为你想要的配置。</p><p>该文件将会在开机时执行，可在命令行中执行的开机启动项均可在此文件中配置。</p><blockquote><p>PS: 开机后会显示一个“进程已结束”的终端，不太爽，需要进入终端的<code>偏好设置</code>-&gt;<code>shell</code>选项卡-&gt;<code>当shell退出时</code>, 选择“关闭窗口”。这样开机时就不会出现一个终端了</p></blockquote><h2 id="2-launchctl加载plist文件"><a href="#2-launchctl加载plist文件" class="headerlink" title="2. launchctl加载plist文件"></a>2. launchctl加载plist文件</h2><p>macOS开机启动一般使用launchctl加载plist文件</p><p>plist文件放置处：</p><pre><code>~/Library/LaunchAgents 由用户自己定义的任务项/Library/LaunchAgents 由管理员为用户定义的任务项/Library/LaunchDaemons 由管理员定义的守护进程任务项/System/Library/LaunchAgents 由Mac OS X为用户定义的任务项/System/Library/LaunchDaemons 由Mac OS X定义的守护进程任务项</code></pre><p>建议放在 ~/Library/LaunchAgents 下面。</p><p>下面再来理解几个基础概念：</p><p>/System/Library和/Library和~/Library目录的区别？</p><pre><code>/System/Library目录是存放Apple自己开发的软件。/Library目录是系统管理员存放的第三方软件。~/Library/是用户自己存放的第三方软件。</code></pre><p>LaunchDaemons和LaunchAgents的区别？</p><pre><code>LaunchDaemons是用户未登陆前就启动的服务（守护进程）。LaunchAgents是用户登陆后启动的服务（守护进程）。</code></pre><p>plist文件示例</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//ENhttp://www.apple.com/DTDs/PropertyList-1.0.dtd &gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;    &lt;key&gt;Label&lt;/key&gt;    &lt;string&gt;com.example.exampled&lt;/string&gt;    &lt;key&gt;ProgramArguments&lt;/key&gt;    &lt;array&gt;         &lt;string&gt;exampled&lt;/string&gt;    &lt;/array&gt;    &lt;key&gt;KeepAlive&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;RunAtLoad&lt;/key&gt;    &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt;</code></pre><p>launchd.plist的部分键值说明，完整版见<a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/launchd.plist.5.html#//apple_ref/doc/man/5/launchd.plist" target="_blank" rel="noopener">launchd.plist(5)</a></p><p><strong>Label (必须)</strong></p><p>该项服务的名称</p><p><strong>ProgramArguments</strong></p><p>指定可执行文件路径及其参数，比如执行<code>ls -a</code>，对应到该配置中，应该写作：</p><pre><code>&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;     &lt;string&gt;ls&lt;/string&gt;              &lt;string&gt;-a&lt;/string&gt;&lt;/array&gt;</code></pre><p><strong>RunAtLoad (可选)</strong></p><p>标识launchd在加载完该项服务之后立即启动路径指定的可执行文件。默认值为 false,设置为 true 即可实现开机运行脚本文件。</p><p><strong>StartCalendarInterval</strong> (可选)</p><p>该关键字可以用来设置定时执行可执行程序，可使用 Month, Day, Hour, Minute, Second等子关键字，它可以指定脚本在多少月，天，小时，分钟，秒，星期几等时间上执行，若缺少某个关键字则表示任意该时间点，类似于 Unix 的 Crontab 计划任务的设置方式，比如在该例子中设置为每小时的20分的时候执行该命令。</p><p><strong>KeepAlive</strong>（可选）</p><p>是否保持持续运行</p><p>所有key关键字详细使用说明可以在Mac OS X终端下使用命令 man launchd.plist 查询</p><p>修改 plist 文件权限</p><pre><code>sudo chown root:wheel ~/Library/LaunchAgents/example.plistsudo chmod 644 ~/Library/LaunchAgents/example.plist</code></pre><p>生效配置</p><pre><code># 载入配置sudo launchctl load ~/Library/LaunchAgents/example.plist# 卸载配置sudo launchctl unload ~/Library/LaunchAgents/example.plist# 检查语法是否正确plutil ~/Library/LaunchAgents/example.plist# 查看服务运行状态sudo launchctl list</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac设置开机启动&quot;&gt;&lt;a href=&quot;#Mac设置开机启动&quot; class=&quot;headerlink&quot; title=&quot;Mac设置开机启动&quot;&gt;&lt;/a&gt;Mac设置开机启动&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文针对命令行使用的开发工具或自己编写的脚本设置开机启动，
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://smarxpan.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Rails学习笔记</title>
    <link href="http://smarxpan.github.io/2017/01/23/Rails%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://smarxpan.github.io/2017/01/23/Rails学习笔记/</id>
    <published>2017-01-23T07:15:30.000Z</published>
    <updated>2018-12-18T01:42:48.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rails学习笔记"><a href="#Rails学习笔记" class="headerlink" title="Rails学习笔记"></a>Rails学习笔记</h1><h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><p>使用 Git 之前，要做些一次性设置。这些设置对整个系统都有效，因此一台电脑只需设置一次：</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email your.email@example.com</code></pre><p>初始化一个新仓库：</p><pre><code>git init</code></pre><p>把项目中的所有文件都放到仓库中：</p><pre><code>git add -A</code></pre><p>提交：</p><pre><code>git commit -m &quot;Initialize repository&quot;</code></pre><p>提交<strong>已加入版本控制文件</strong>的全部改动：</p><pre><code>git commit -am &quot;message&quot;</code></pre><p>检查状态</p><pre><code>git status</code></pre><p>强制撤销未提交的改动：</p><pre><code>git checkout -f</code></pre><p>添加至远程仓库，然后首次推送：</p><pre><code>git remote add origin git@bitbucket.org:&lt;username&gt;/hello_app.gitgit push -u origin --all</code></pre><p>之后的推送只要<code>git push</code>即可</p><p><strong>分支操作</strong></p><pre><code># 查看分支git branch # 查看所有分支（包含远程）git branch -a# 合并分支git merge branch_name# 删除本地分支git branch --delete branch_name# 删除远程分支git push origin --delete branch_name# 创建并切换到该分支git checkout -b xxx</code></pre><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>一般来说，下面这两个命令是相互抵消的：</p><pre><code>rails generate controller StaticPages home helprails destroy  controller StaticPages home help# 生成Modelrails generate model User name:string email:string# 删除Modelrails destroy model User</code></pre><p>数据库</p><pre><code># 数据迁移rails db:migrate# 回滚rails db:rollback# 回到最开始的状态rails db:migrate VERSION=0</code></pre><p>把数字 0 换成其他数字就会回到相应的版本，这些版本数字是按照迁移执行的顺序排列的。</p><h2 id="Rails内建环境"><a href="#Rails内建环境" class="headerlink" title="Rails内建环境"></a>Rails内建环境</h2><p>Rails 内建了三个环境，分别是测试环境、开发环境和生产环境。Rails 控制台默认使用的是开发环境：</p><pre><code>$ rails consoleLoading development environment&gt;&gt; Rails.env=&gt; &quot;development&quot;</code></pre><p>Rails 本地服务器和控制台一样，默认使用开发环境，不过也可以在其他环境中运行：</p><pre><code>$ rails server --environment production</code></pre><p>如果想在生产环境中运行应用，要先有一个生产数据库。在生产环境中执行 rails db:migrate 命令可以生成这个数据库：</p><pre><code>$ rails db:migrate RAILS_ENV=production</code></pre><p>把应用部署到 Heroku 后，可以使用 <code>heroku run console</code> 命令进入控制台查看所用的环境：</p><pre><code>$ heroku run console&gt;&gt; Rails.env=&gt; &quot;production&quot;</code></pre><h2 id="账户持久会话设计方案"><a href="#账户持久会话设计方案" class="headerlink" title="账户持久会话设计方案"></a>账户持久会话设计方案</h2><ol><li>生成随机字符串，用作记忆令牌；</li><li>把这个令牌存入浏览器的 cookie 中，并把过期时间设为未来的某个日期；</li><li>在数据库中存储令牌的摘要；</li><li>在浏览器的 cookie 中存储加密后的用户 ID；</li><li>如果 cookie 中有用户的 ID，就用这个 ID 在数据库中查找用户，并且检查 cookie 中的记忆令牌和数据库中的哈希摘要是否匹配。</li></ol><h2 id="部署heroku"><a href="#部署heroku" class="headerlink" title="部署heroku"></a>部署heroku</h2><p>部署到 Heroku 之前要注意一个问题：推送之后，迁移完成之前，应用基本上处于不可用状态。在拥有巨大流量的线上网站中，更新前最好开启维护模式：</p><pre><code>$ heroku maintenance:on$ git push heroku$ heroku run rails db:migrate$ heroku maintenance:off</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rails学习笔记&quot;&gt;&lt;a href=&quot;#Rails学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Rails学习笔记&quot;&gt;&lt;/a&gt;Rails学习笔记&lt;/h1&gt;&lt;h2 id=&quot;git操作&quot;&gt;&lt;a href=&quot;#git操作&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Rails" scheme="http://smarxpan.github.io/tags/Rails/"/>
    
  </entry>
  
  <entry>
    <title>heroku安装及部署rails项目教程</title>
    <link href="http://smarxpan.github.io/2017/01/17/rails%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2heroku%E6%95%99%E7%A8%8B/"/>
    <id>http://smarxpan.github.io/2017/01/17/rails项目部署heroku教程/</id>
    <published>2017-01-17T07:15:30.000Z</published>
    <updated>2018-12-18T01:42:39.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="heroku安装及部署rails项目教程"><a href="#heroku安装及部署rails项目教程" class="headerlink" title="heroku安装及部署rails项目教程"></a>heroku安装及部署rails项目教程</h1><p>开发了一个带数据库的小项目，部署至heroku看看效果。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>macOS安装：</p><pre><code>brew install heroku</code></pre><p>其他系统安装参见<a href="https://www.heroku.com/" target="_blank" rel="noopener">heroku官网</a></p><p>检查是否安装好：</p><pre><code>heroku version</code></pre><p>确认 Heroku 命令行工具已经安装之后，使用 heroku 命令登录，然后添加 SSH 密钥：</p><pre><code>heroku loginheroku keys:add</code></pre><p>如果没有ssh key，请先<a href="https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5" target="_blank" rel="noopener">生成 SSH 公钥</a></p><h2 id="部署前准备"><a href="#部署前准备" class="headerlink" title="部署前准备"></a>部署前准备</h2><h3 id="1-将项目添加至git"><a href="#1-将项目添加至git" class="headerlink" title="1. 将项目添加至git"></a>1. 将项目添加至git</h3><p>进入项目目录，初始化git</p><pre><code>git init</code></pre><p>然后执行 git add -A 命令，把项目中的所有文件都放到仓库中：</p><pre><code>git add -A</code></pre><p>提交：</p><pre><code>git commit -m &quot;Initialize repository&quot;</code></pre><p>这里的提交仅仅将代码提交到了本地，一般都会提交至服务端，这里我用了 Bitbucket，这是一个专门用来托管和分享 Git 仓库的网站</p><p>提交远程仓库之前要做下面三件事：</p><ol><li>如果没有账户，先注册一个 Bitbucket 账户；</li><li>添加公钥到账户控制中</li><li>创建一个仓库</li></ol><p>建好远程仓库后，需要将本地项目与远程仓库关联：</p><pre><code>git remote add origin git@bitbucket.org:&lt;username&gt;/&lt;project&gt;.git</code></pre><p>提交本地项目</p><pre><code>git push -u origin --all    </code></pre><h3 id="2-修改-Gemfile"><a href="#2-修改-Gemfile" class="headerlink" title="2. 修改 Gemfile"></a>2. 修改 Gemfile</h3><p>本地数据库使用的是sqlite，heroku不支持sqlite，因此需要配置对生产环境进行一些设置。</p><p>Gemfile中配置</p><pre><code>group :development, :test do  # Call &apos;byebug&apos; anywhere in the code to stop execution and get a debugger console  gem &apos;byebug&apos;, platform: :mri  # sqlite数据库移动到里  gem &apos;sqlite3&apos;end# 添加production组，内部配置postgresql的插件group :production do  gem &apos;pg&apos;, &apos;0.18.4&apos;end</code></pre><p>修改完后需要运行</p><pre><code>bundle install --without production</code></pre><p>然后，提交这次改动：</p><pre><code>git commit -a -m &quot;Update Gemfile for Heroku&quot;</code></pre><h3 id="部署并迁移数据"><a href="#部署并迁移数据" class="headerlink" title="部署并迁移数据"></a>部署并迁移数据</h3><p>在 Heroku 中创建一个新应用，在项目目录运行</p><pre><code>heroku create</code></pre><p>部署</p><pre><code>git push heroku master</code></pre><p>创建postgresql数据库</p><pre><code>heroku addons:create heroku-postgresql:hobby-dev</code></pre><p>查找数据库地址</p><pre><code>heroku config -s | grep HEROKU_POSTGRESQL</code></pre><p>将这个地址粘贴出来，修改<code>database.yml</code>中的生产环境配置</p><pre><code>production:  adapter: postgresql  encoding: unicode  database: postgres://xxxxxxx  pool: 5  timeout: 5000    </code></pre><p>运行数据迁移</p><pre><code># 数据迁移heroku run rake db:migrate# 插入测试数据heroku run rake db:seed</code></pre><p>打开项目页面</p><pre><code>heroku open</code></pre><p>至此，部署彻底完成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;heroku安装及部署rails项目教程&quot;&gt;&lt;a href=&quot;#heroku安装及部署rails项目教程&quot; class=&quot;headerlink&quot; title=&quot;heroku安装及部署rails项目教程&quot;&gt;&lt;/a&gt;heroku安装及部署rails项目教程&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Rails" scheme="http://smarxpan.github.io/tags/Rails/"/>
    
  </entry>
  
  <entry>
    <title>rails安装指南</title>
    <link href="http://smarxpan.github.io/2017/01/05/rails%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    <id>http://smarxpan.github.io/2017/01/05/rails安装指南/</id>
    <published>2017-01-05T07:15:30.000Z</published>
    <updated>2018-12-18T01:42:53.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rails安装指南"><a href="#Rails安装指南" class="headerlink" title="Rails安装指南"></a>Rails安装指南</h1><p>介绍 Mac、linux、windows 安装 rails 的方式</p><h2 id="windows-安装-rails"><a href="#windows-安装-rails" class="headerlink" title="windows 安装 rails"></a>windows 安装 rails</h2><p>就别瞎折腾了，直接使用 RailsInstaller 一键安装包</p><p>官网地址：<a href="http://railsinstaller.org/en" target="_blank" rel="noopener">http://railsinstaller.org/en</a></p><p>安装完成后，rails极可能用不了，需要命令行执行</p><pre><code>gem update --system &amp;&amp; gem update --no-document</code></pre><p>当然，windows 部分的教程并没有到此结束，请直接跳到后面配置 RubyGems 镜像的教程。</p><h2 id="nix安装rails"><a href="#nix安装rails" class="headerlink" title="*nix安装rails"></a>*nix安装rails</h2><p>Mac和Linux安装方式基本相同，此处我使用rbenv来安装，rbenv是管理多个ruby版本的工具，可以很方便的切换ruby的版本。</p><blockquote><p>注意：尽量不要在root用户安装rails，要在普通用户安装</p></blockquote><h3 id="1-安装rbenv"><a href="#1-安装rbenv" class="headerlink" title="1. 安装rbenv"></a>1. 安装rbenv</h3><p>首先安装git，已安装跳过此步</p><pre><code># macbrew install git# centosyum install git# ubuntuapt-get install git</code></pre><p>然后安装rbenv</p><pre><code># 安装rbenv到~/.rbenv目录git clone git://github.com/sstephenson/rbenv.git ~/.rbenv</code></pre><p>下面安装一些rbenv的插件</p><pre><code># 用来编译安装 rubygit clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build# 用来管理 gemset, 可选, 因为有 bundler 也没什么必要git clone git://github.com/jamis/rbenv-gemset.git  ~/.rbenv/plugins/rbenv-gemset# 通过 gem 命令安装完 gem 后无需手动输入 rbenv rehash 命令, 推荐git clone git://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash# 通过 rbenv update 命令来更新 rbenv 以及所有插件, 推荐git clone git://github.com/rkh/rbenv-update.git ~/.rbenv/plugins/rbenv-update# 使用 Ruby China 的镜像安装 Ruby, 国内用户推荐git clone git://github.com/AndorChen/rbenv-china-mirror.git ~/.rbenv/plugins/rbenv-china-mirror</code></pre><p>然后需要将下面两句代码放在bash的配置文件中：</p><pre><code>export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;eval &quot;$(rbenv init -)&quot;</code></pre><p>linux是一般是放在<code>~/.bashrc</code>中，mac是放在<code>~/.bash_profile</code>中</p><p>修改完成后，执行下面的命令使其生效</p><pre><code># linuxsource ~/.bashrc# macsource ~/.bash_profile</code></pre><h3 id="2-安装ruby"><a href="#2-安装ruby" class="headerlink" title="2. 安装ruby"></a>2. 安装ruby</h3><pre><code>rbenv install --list  # 列出所有 ruby 版本</code></pre><p>例如安装2.3.3：</p><pre><code>rbenv install 2.3.3</code></pre><p>设置使用的ruby版本, 有以下三种设置方式</p><pre><code>rbenv global 2.3.3      # 默认使用2.3.3rbenv shell 2.3.3       # 当前的 shell 使用2.3.3, 会设置一个 `RBENV_VERSION` 环境变量rbenv local 2.3.3      # 当前目录使用2.3.3, 会生成一个 `.rbenv-version` 文件</code></pre><h3 id="3-安装rails"><a href="#3-安装rails" class="headerlink" title="3. 安装rails"></a>3. 安装rails</h3><p>设置ruby版本后，安装rails：</p><pre><code># 在当前的ruby版本中安装railsgem install rails</code></pre><p>好了，这样就完成了rails的安装，rails已经可以使用了，但是为了更好的使用，请继续看后面的教程。</p><h2 id="配置RubyGems镜像"><a href="#配置RubyGems镜像" class="headerlink" title="配置RubyGems镜像"></a>配置RubyGems镜像</h2><p>gem是ruby管理依赖包的工具，而RubyGems的默认地址因为万恶的墙的关系很难访问到，因此需要配置RubyGems 镜像。这里使用的是<a href="http://gems.ruby-china.org/" target="_blank" rel="noopener">Ruby China</a>的镜像地址</p><p>命令行输入</p><pre><code>gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</code></pre><p>可以通过下面这个命令查看设置的结果是不是<code>https://gems.ruby-china.org</code>：</p><pre><code>gem sources -l</code></pre><p>对于<strong>Windows系统，会报下面这个错误</strong>： </p><pre><code>Error fetching https://gems.ruby-china.org/:    SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://gems.ruby-china.org/specs.4.8.gz)</code></pre><p>报这个错的原因是 RailsInstaller 安装的 ruby 没有包含 SSL 证书，所以 https 的链接被服务器拒绝。</p><p>解决方法为：</p><ol><li>下载证书文件 <a href="http://curl.haxx.se/ca/cacert.pem" target="_blank" rel="noopener">http://curl.haxx.se/ca/cacert.pem</a></li><li>然后设置 <code>SSL_CERT_FILE</code> 环境变量，变量值为<code>cacert.pem</code>文件的路径。</li></ol><h2 id="修改bundle的源地址"><a href="#修改bundle的源地址" class="headerlink" title="修改bundle的源地址"></a>修改bundle的源地址</h2><p>bundler是rails管理gem依赖的工具，同样的，也需要修改其地址为ruby china的镜像</p><p>命令行输入</p><pre><code>bundle config mirror.https://rubygems.org https://gems.ruby-china.org</code></pre><p>至此，rails安装完成，下一步可以去学习<a href="http://guides.ruby-china.org/" target="_blank" rel="noopener">Ruby on Rails 指南</a>或者<a href="https://railstutorial-china.org/book/" target="_blank" rel="noopener">Ruby on Rails 教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rails安装指南&quot;&gt;&lt;a href=&quot;#Rails安装指南&quot; class=&quot;headerlink&quot; title=&quot;Rails安装指南&quot;&gt;&lt;/a&gt;Rails安装指南&lt;/h1&gt;&lt;p&gt;介绍 Mac、linux、windows 安装 rails 的方式&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="Rails" scheme="http://smarxpan.github.io/tags/Rails/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装PostgreSQL</title>
    <link href="http://smarxpan.github.io/2017/01/04/Mac%E5%AE%89%E8%A3%85PostgreSQL/"/>
    <id>http://smarxpan.github.io/2017/01/04/Mac安装PostgreSQL/</id>
    <published>2017-01-04T07:15:30.000Z</published>
    <updated>2018-12-14T12:53:54.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac安装PostgreSQL"><a href="#Mac安装PostgreSQL" class="headerlink" title="Mac安装PostgreSQL"></a>Mac安装PostgreSQL</h1><p>最近在学习rails，记录下安装psql的过程</p><h2 id="安装及初始化"><a href="#安装及初始化" class="headerlink" title="安装及初始化"></a>安装及初始化</h2><p>这里使用homebrew安装</p><pre><code>brew install postgresql</code></pre><p>等待安装完成后，初始化：</p><pre><code>initdb /usr/local/var/postgres</code></pre><p>启动服务：</p><pre><code>pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start</code></pre><h2 id="创建数据库和账户"><a href="#创建数据库和账户" class="headerlink" title="创建数据库和账户"></a>创建数据库和账户</h2><p>mac安装postgresql后不会创建用户名数据库，执行命令：</p><pre><code>createdb</code></pre><p>然后登录PostgreSQL控制台：</p><pre><code>psql</code></pre><p>使用<code>\l</code>命令列出所有的数据库，看到已存在用户同名数据库、postgres数据库，但是postgres数据库的所有者是当前用户，没有postgres用户。按<code>:q</code>退出查看</p><p>之后需要做以下几件事：</p><ol><li><p>创建postgres用户</p><pre><code>CREATE USER postgres WITH PASSWORD &apos;password&apos;;</code></pre></li><li><p>删除默认生成的postgres数据库</p><pre><code>DROP DATABASE postgres;</code></pre></li><li><p>创建属于postgres用户的postgres数据库</p><pre><code>CREATE DATABASE postgres OWNER postgres;</code></pre></li><li><p>将数据库所有权限赋予postgres用户</p><pre><code>GRANT ALL PRIVILEGES ON DATABASE postgres to postgres;</code></pre></li><li><p>给postgres用户添加创建数据库的属性</p><pre><code>CREATE ROLE postgres CREATEDB;</code></pre><p>这样就可以使用postgres作为数据库的登录用户了，并可以使用该用户管理数据库</p></li></ol><h2 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h2><p>编辑<code>.bash_profile</code>文件</p><pre><code>vim ~/.bash_profile</code></pre><p>按i进入插入模式，粘贴启动服务的命令到文件中：</p><pre><code>pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start</code></pre><h2 id="登录控制台指令"><a href="#登录控制台指令" class="headerlink" title="登录控制台指令"></a>登录控制台指令</h2><pre><code>psql -U [user] -d [database] -h [host] -p [post]</code></pre><p>-U指定用户，-d指定数据库，-h指定服务器，-p指定端口</p><p>上方直接使用<code>psql</code>登录控制台，实际上使用的是缺省数据</p><pre><code>user：当前mac用户database：用户同名数据库主机：localhost端口号：5432，postgresql的默认端口是5432</code></pre><p>完整的登录命令，比如使用postgres用户登录</p><pre><code>psql -U postgres -d postgres</code></pre><h2 id="常用控制台命令"><a href="#常用控制台命令" class="headerlink" title="常用控制台命令"></a>常用控制台命令</h2><pre><code>\h：查看SQL命令的解释，比如\h select。\?：查看psql命令列表。\l：列出所有数据库。\c [database_name]：连接其他数据库。\d：列出当前数据库的所有表格。\d [table_name]：列出某一张表格的结构。\du：列出所有用户。\e：打开文本编辑器。\conninfo：列出当前数据库和连接的信息。\password [user]: 修改用户密码\q：退出</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac安装PostgreSQL&quot;&gt;&lt;a href=&quot;#Mac安装PostgreSQL&quot; class=&quot;headerlink&quot; title=&quot;Mac安装PostgreSQL&quot;&gt;&lt;/a&gt;Mac安装PostgreSQL&lt;/h1&gt;&lt;p&gt;最近在学习rails，记录下安装ps
      
    
    </summary>
    
    
      <category term="Rails" scheme="http://smarxpan.github.io/tags/Rails/"/>
    
  </entry>
  
  <entry>
    <title>Linux使用指南</title>
    <link href="http://smarxpan.github.io/2016/11/15/Linux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://smarxpan.github.io/2016/11/15/Linux使用指南/</id>
    <published>2016-11-15T07:15:30.000Z</published>
    <updated>2018-12-14T12:58:22.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux使用指南"><a href="#Linux使用指南" class="headerlink" title="Linux使用指南"></a>Linux使用指南</h1><h2 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h2><p>先要有个linux才能使用，其中有以下几种比较简单的方式可以快速拥有linux</p><ol><li><p>安装SecureCRT、Xshell、putty等模拟终端连接远程linux</p><p> 其中推荐使用SecureCrt, 安装并激活，相信你可以搞定的。</p></li><li><p>通过虚拟机安装</p><p> 推荐安装VirtualBox虚拟机软件（<a href="http://download.virtualbox.org/virtualbox/5.1.10/VirtualBox-5.1.10-112026-Win.exe" target="_blank" rel="noopener">点击下载</a>），下载Ubuntu镜像（<a href="http://www.ubuntukylin.com/downloads/download.php?id=50" target="_blank" rel="noopener">点击下载</a>），安装教程如下：</p><p> <a href="http://www.xuzefeng.com/post/84.html" target="_blank" rel="noopener">http://www.xuzefeng.com/post/84.html</a>，虽然与教程中的版本不一样，但安装方式大同小异</p><p> 这里安装的是Ubuntu，这个系统是有图形化界面的，不是纯命令行的，方便新手学习使用。与CentOS没有太大区别，仅仅安装软件的命令不太一样。</p></li></ol><h2 id="日常使用篇"><a href="#日常使用篇" class="headerlink" title="日常使用篇"></a>日常使用篇</h2><h3 id="打开目录-cd命令"><a href="#打开目录-cd命令" class="headerlink" title="打开目录(cd命令)"></a>打开目录(cd命令)</h3><pre><code>cd path</code></pre><p>使用示例</p><pre><code>cd /etccd root</code></pre><p>此处需要懂得一个小知识：绝对路径和相对路径。”/“开头的是绝对路径，不加斜杠的是相对路径，也就是相对于当前路径以下的路径。</p><blockquote><p>思考题：返回上一层的命令是<code>cd ..</code>， 那么返回上上一层呢？</p></blockquote><!--可以`cd ../..`--><h3 id="查看当前路径的文件-ls命令"><a href="#查看当前路径的文件-ls命令" class="headerlink" title="查看当前路径的文件(ls命令)"></a>查看当前路径的文件(ls命令)</h3><p>一般习惯使用<code>ll</code>命令，也就是<code>ls -l</code>命令查看当前路径的文件</p><p>查看全部文件（包含隐藏文件）</p><pre><code>ls -a</code></pre><h3 id="复制文件或文件夹（cp命令）"><a href="#复制文件或文件夹（cp命令）" class="headerlink" title="复制文件或文件夹（cp命令）"></a>复制文件或文件夹（cp命令）</h3><p>复制文件</p><pre><code>cp file pathcp file new_file</code></pre><p>复制文件夹</p><pre><code>cp -a folder pathcp -a folder new_folder</code></pre><p>使用示例：</p><pre><code>cp hehe.txt /root             #复制当前目录的hehe.txt到root目录下cp /root/hehe.txt /home     #复制root目录的hehe.txt到home目录cp hehe.txt lala.txt         #复制hehe.txt为lala.txtcp -a /home /root             #复制home目录及其内部所有文件到root目录</code></pre><h3 id="移动文件（mv命令）"><a href="#移动文件（mv命令）" class="headerlink" title="移动文件（mv命令）"></a>移动文件（mv命令）</h3><pre><code>mv file pathmv folder path</code></pre><h3 id="删除文件（rm命令）"><a href="#删除文件（rm命令）" class="headerlink" title="删除文件（rm命令）"></a>删除文件（rm命令）</h3><pre><code>rm -rf 文件或文件夹</code></pre><h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><pre><code>yum install packagename</code></pre><p>这里centos使用的是yum安装应用，而ubuntu使用的是<code>apt-get</code>命令</p><p>使用示例，如果我要安装压缩软件7z，通过百度“linux安装7z”，得知使用以下命令安装：</p><pre><code>yum install p7zip</code></pre><blockquote><p>小作业：为服务器<code>45.78.17.172</code>安装7z压缩程序</p></blockquote><h3 id="下载、上传文件"><a href="#下载、上传文件" class="headerlink" title="下载、上传文件"></a>下载、上传文件</h3><p>以下命令<font color="red"><strong>仅限使用SecureCrt</strong></font>时使用：</p><pre><code>#上传文件rz#下载文件sz filen</code></pre><p>注意：sz下载仅能下载一个文件，下载文件夹需要压缩成一个文件后才能下载</p><h3 id="授人以渔"><a href="#授人以渔" class="headerlink" title="授人以渔"></a>授人以渔</h3><p>上面的命令都是些常用命令，如果遇到一个操作想不起来或者不会做该怎么办呢？</p><p>很简单，百度 “linux + 操作名称”</p><p>例如，“linux如何压缩文件”，“linux如何下载文件”、</p><blockquote><p>小作业：学会如何在linux压缩文件</p></blockquote><p>如果是已有的命令，却记不住怎么用该怎么办呢？推荐使用cheat命令</p><p>比如：<code>cheat ls</code>，会显示出以下结果：</p><pre><code> cheat ls# Displays everything in the target directoryls path/to/the/target/directory# Displays everything including hidden filesls -a# Displays all files, along with the size (with unit suffixes) and timestampls -lh # Display files, sorted by sizels -S# Display directories onlyls -d */# Display directories only, include hiddenls -d .*/ */</code></pre><h3 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h3><p>自带的压缩工具有<code>tar</code>和<code>zip</code></p><p>自带的解压软件有<code>tar</code>和<code>unzip</code></p><p>使用方式可以使用cheat命令查看</p><p>推荐使用7z压缩和解压，一方面是该命令比较好用，另一方面压缩的比例比较高。上面的学习中应该已经安装了p7zip，因此可以使用7za这个命令</p><p><strong>压缩</strong></p><pre><code>7za a 压缩后的文件名 要压缩的文件或文件夹</code></pre><p>使用示例：</p><pre><code>7za a hehe.7z hehe.txt</code></pre><p><strong>解压</strong></p><pre><code>7za x 压缩文件.7z</code></pre><p>注意，压缩后的文件需使用<code>.7z</code>作为后缀，方便软件识别其为7z格式的压缩包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux使用指南&quot;&gt;&lt;a href=&quot;#Linux使用指南&quot; class=&quot;headerlink&quot; title=&quot;Linux使用指南&quot;&gt;&lt;/a&gt;Linux使用指南&lt;/h1&gt;&lt;h2 id=&quot;安装篇&quot;&gt;&lt;a href=&quot;#安装篇&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://smarxpan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>老司机来教你单例的正确姿势</title>
    <link href="http://smarxpan.github.io/2016/06/29/how_to_use_singleton/"/>
    <id>http://smarxpan.github.io/2016/06/29/how_to_use_singleton/</id>
    <published>2016-06-29T02:15:28.000Z</published>
    <updated>2016-06-30T14:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="老司机来教你单例的正确姿势"><a href="#老司机来教你单例的正确姿势" class="headerlink" title="老司机来教你单例的正确姿势"></a>老司机来教你单例的正确姿势</h1><p>Java单例模式可能是最简单也是最常用的设计模式，一个完美的单例需要做到哪些事呢？</p><ol><li>单例（这不是废话吗）</li><li>延迟加载</li><li>线程安全</li><li>没有性能问题</li><li>防止序列化产生新对象</li><li>防止反射攻击</li></ol><p>可以看到，真正要实现一个完美的单例是很复杂的，那么，让我这个司机带大家看一看正确姿势的单例。</p><h2 id="最佳实践单例之枚举"><a href="#最佳实践单例之枚举" class="headerlink" title="最佳实践单例之枚举"></a>最佳实践单例之枚举</h2><p>没错，直接就上最佳实践，就是这么任性</p><p>这货长这样： </p><pre><code>public enum Singleton{    INSTANCE;}</code></pre><p>如果你不熟悉枚举，可能会说：这货是啥？！</p><p>这种方式的好处是：</p><ol><li>利用的枚举的特性实现单例</li><li>由JVM保证线程安全</li><li>序列化和反射攻击已经被枚举解决</li></ol><p>调用方式为<code>Singleton.INSTANCE</code>, 出自《Effective Java》第二版第三条: 用私有构造器或枚举类型强化Singleton属性。</p><blockquote><p>关于单例最佳实践的讨论可以看Stackoverflow：<a href="http://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="noopener">what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java</a></p></blockquote><p>下面将会介绍更为常见的单例模式，但是均未处理反射攻击，如果想了解更多可以看这篇文章：<a href="http://blog.csdn.net/u013256816/article/details/50525335" target="_blank" rel="noopener">如何防止单例模式被JAVA反射攻击</a></p><a id="more"></a><h2 id="最简单的单例之饿汉式"><a href="#最简单的单例之饿汉式" class="headerlink" title="最简单的单例之饿汉式"></a>最简单的单例之饿汉式</h2><pre><code>public class Singleton {    private static final Singleton INSTANCE = new Singleton();    // 私有化构造函数    private Singleton(){}    public static Singleton getInstance(){        return INSTANCE;    }}</code></pre><p>这种单例的写法最简单，但是缺点是一旦类被加载，单例就会初始化，没有实现懒加载。而且当实现了Serializable接口后，反序列化时单例会被破坏。</p><p>实现Serializable接口需要重写<code>readResolve</code>，才能保证其反序列化依旧是单例：</p><pre><code>public class Singleton implements Serializable {    private static final Singleton INSTANCE = new Singleton();    // 私有化构造函数    private Singleton(){}    public static Singleton getInstance(){        return INSTANCE;    }    /**     * 如果实现了Serializable, 必须重写这个方法     */    private Object readResolve() throws ObjectStreamException {        return INSTANCE;    }}</code></pre><p>OK，反序列化要注意的就是这一点，下面的内容中就不再复述了。</p><h2 id="最体现技术的单例之懒汉式"><a href="#最体现技术的单例之懒汉式" class="headerlink" title="最体现技术的单例之懒汉式"></a>最体现技术的单例之懒汉式</h2><p>懒汉式即实现延迟加载的单例，为上述饿汉式的优化形式。而因其仍需要进一步优化，往往成为面试考点，让我们一起来看看坑爹的“懒汉式”</p><p>懒汉式的最初形式是这样的：</p><pre><code>public class Singleton {    private static Singleton INSTANCE;    private Singleton (){}    public static Singleton getInstance() {     if (INSTANCE == null) {         INSTANCE = new Singleton();     }     return INSTANCE;    }}</code></pre><p>这种写法就轻松实现了单例的懒加载，只有调用了<code>getInstance</code>方法才会初始化。但是这样的写法出现了新的问题–线程不安全。当多个线程调用<code>getInstance</code>方法时，可能会创建多个实例，因此需要对其进行同步。</p><p>如何使其线程安全呢？简单，加个<code>synchronized</code>关键字就行了</p><pre><code>public static synchronized Singleton getInstance() {    if (INSTANCE == null) {        INSTANCE = new Singleton();    }    return INSTANCE;}</code></pre><p>可是…这样又出现了性能问题，简单粗暴的同步整个方法，导致同一时间内只有一个线程能够调用<code>getInstance</code>方法。</p><p>因为仅仅需要对初始化部分的代码进行同步，所以再次进行优化：</p><pre><code>public static Singleton getSingleton() {    if (INSTANCE == null) {               // 第一次检查        synchronized (Singleton.class) {            if (INSTANCE == null) {      // 第二次检查                INSTANCE = new Singleton();            }        }    }    return INSTANCE ;}</code></pre><p>执行两次检测很有必要：当多线程调用时，如果多个线程同时执行完了第一次检查，其中一个进入同步代码块创建了实例，后面的线程因第二次检测不会创建新实例。</p><p>这段代码看起来很完美，但仍旧存在问题，以下内容引用自黑桃夹克大神的<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确地写出单例模式</a></p><blockquote><p>这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p></blockquote><ol><li>给 instance 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量</li><li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li></ol><blockquote><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p></blockquote><blockquote><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p></blockquote><pre><code>public class Singleton {    private volatile static Singleton INSTANCE; //声明成 volatile    private Singleton (){}    public static Singleton getSingleton() {        if (INSTANCE == null) {                                     synchronized (Singleton.class) {                if (INSTANCE == null) {                           INSTANCE = new Singleton();                }            }        }        return INSTANCE;    }}</code></pre><blockquote><p>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p></blockquote><blockquote><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p></blockquote><p>至此，这样的懒汉式才是没有问题的懒汉式。</p><h2 id="内部类实现单例"><a href="#内部类实现单例" class="headerlink" title="内部类实现单例"></a>内部类实现单例</h2><pre><code>public class Singleton {     /**      * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，      * 而且只有被调用到才会装载，从而实现了延迟加载      */     private static class SingletonHolder{         /**          * 静态初始化器，由JVM来保证线程安全          */         private static final Singleton instance = new Singleton();     }     /**      * 私有化构造方法      */     private Singleton(){     }     public static  Singleton getInstance(){         return SingletonHolder.instance;     } } </code></pre><p>使用内部类来维护单例的实例，当Singleton被加载时，其内部类并不会被初始化，故可以确保当 Singleton类被载入JVM时，不会初始化单例类。只有 <code>getInstance()</code> 方法调用时，才会初始化 instance。同时，由于实例的建立是时在类加载时完成，故天生对多线程友好，<code>getInstance()</code> 方法也无需使用同步关键字。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无疑，单例就应使用枚举实现，最佳实践诚不欺我</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="http://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="noopener">What is an efficient way to implement a singleton pattern in Java</a></p><p><a href="www.javapractices.com/topic/TopicAction.do?Id=46">Java Practices -&gt; Singleton</a></p><p><a href="http://www.drdobbs.com/jvm/creating-and-destroying-java-objects-par/208403883?pgno=3" target="_blank" rel="noopener">Creating and Destroying Java Objects: Part 1</a></p><p><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确地写出单例模式</a></p><p><a href="https://segmentfault.com/q/1010000000646806" target="_blank" rel="noopener">JAVA 枚举单例模式</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;老司机来教你单例的正确姿势&quot;&gt;&lt;a href=&quot;#老司机来教你单例的正确姿势&quot; class=&quot;headerlink&quot; title=&quot;老司机来教你单例的正确姿势&quot;&gt;&lt;/a&gt;老司机来教你单例的正确姿势&lt;/h1&gt;&lt;p&gt;Java单例模式可能是最简单也是最常用的设计模式，一个完美的单例需要做到哪些事呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单例（这不是废话吗）&lt;/li&gt;
&lt;li&gt;延迟加载&lt;/li&gt;
&lt;li&gt;线程安全&lt;/li&gt;
&lt;li&gt;没有性能问题&lt;/li&gt;
&lt;li&gt;防止序列化产生新对象&lt;/li&gt;
&lt;li&gt;防止反射攻击&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到，真正要实现一个完美的单例是很复杂的，那么，让我这个司机带大家看一看正确姿势的单例。&lt;/p&gt;
&lt;h2 id=&quot;最佳实践单例之枚举&quot;&gt;&lt;a href=&quot;#最佳实践单例之枚举&quot; class=&quot;headerlink&quot; title=&quot;最佳实践单例之枚举&quot;&gt;&lt;/a&gt;最佳实践单例之枚举&lt;/h2&gt;&lt;p&gt;没错，直接就上最佳实践，就是这么任性&lt;/p&gt;
&lt;p&gt;这货长这样： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public enum Singleton{
    INSTANCE;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你不熟悉枚举，可能会说：这货是啥？！&lt;/p&gt;
&lt;p&gt;这种方式的好处是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用的枚举的特性实现单例&lt;/li&gt;
&lt;li&gt;由JVM保证线程安全&lt;/li&gt;
&lt;li&gt;序列化和反射攻击已经被枚举解决&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调用方式为&lt;code&gt;Singleton.INSTANCE&lt;/code&gt;, 出自《Effective Java》第二版第三条: 用私有构造器或枚举类型强化Singleton属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于单例最佳实践的讨论可以看Stackoverflow：&lt;a href=&quot;http://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面将会介绍更为常见的单例模式，但是均未处理反射攻击，如果想了解更多可以看这篇文章：&lt;a href=&quot;http://blog.csdn.net/u013256816/article/details/50525335&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何防止单例模式被JAVA反射攻击&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://smarxpan.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
