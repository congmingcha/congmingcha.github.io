{"meta":{"title":"聪明叉的博客","subtitle":"成为更好的自己","description":"持志如心痛","author":"聪明叉","url":"http://smarxpan.github.io"},"pages":[{"title":"","date":"2018-12-17T02:51:15.844Z","updated":"2018-12-17T02:51:15.838Z","comments":false,"path":"categories/index.html","permalink":"http://smarxpan.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-17T02:50:31.992Z","updated":"2018-12-17T02:50:31.973Z","comments":false,"path":"tags/index.html","permalink":"http://smarxpan.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-17T07:07:54.093Z","updated":"2018-12-17T07:05:42.339Z","comments":true,"path":"gitment/style/default.css","permalink":"http://smarxpan.github.io/gitment/style/default.css","excerpt":"","text":".gitment-container { font-family: sans-serif; font-size: 14px; line-height: 1.5; color: #333; word-wrap: break-word; } .gitment-container * { box-sizing: border-box; } .gitment-container *:disabled { cursor: not-allowed; } .gitment-container a, .gitment-container a:visited { cursor: pointer; text-decoration: none; } .gitment-container a:hover { text-decoration: underline; } .gitment-container .gitment-hidden { display: none; } .gitment-container .gitment-spinner-icon { fill: #333; -webkit-animation: gitment-spin 1s steps(12) infinite; animation: gitment-spin 1s steps(12) infinite; } @-webkit-keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } @keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } .gitment-root-container { margin: 19px 0; } .gitment-header-container { margin: 19px 0; } .gitment-header-like-btn, .gitment-comment-like-btn { cursor: pointer; } .gitment-comment-like-btn { float: right; } .gitment-comment-like-btn.liked { color: #F44336; } .gitment-header-like-btn svg { vertical-align: middle; height: 30px; } .gitment-comment-like-btn svg { vertical-align: middle; height: 20px; } .gitment-header-like-btn.liked svg, .gitment-comment-like-btn.liked svg { fill: #F44336; } a.gitment-header-issue-link, a.gitment-header-issue-link:visited { float: right; line-height: 30px; color: #666; } a.gitment-header-issue-link:hover { color: #666; } .gitment-comments-loading, .gitment-comments-error, .gitment-comments-empty { text-align: center; margin: 50px 0; } .gitment-comments-list { list-style: none; padding-left: 0; margin: 0 0 38px; } .gitment-comment, .gitment-editor-container { position: relative; min-height: 60px; padding-left: 60px; margin: 19px 0; } .gitment-comment-avatar, .gitment-editor-avatar { float: left; margin-left: -60px; } .gitment-comment-avatar, .gitment-comment-avatar-img, .gitment-comment-avatar, .gitment-editor-avatar-img, .gitment-editor-avatar svg { width: 44px; height: 44px; border-radius: 3px; } .gitment-editor-avatar .gitment-github-icon { fill: #fff; background-color: #333; } .gitment-comment-main, .gitment-editor-main { position: relative; border: 1px solid #CFD8DC; border-radius: 0; } .gitment-editor-main::before, .gitment-editor-main::after, .gitment-comment-main::before, .gitment-comment-main::after { position: absolute; top: 11px; left: -16px; display: block; width: 0; height: 0; pointer-events: none; content: \"\"; border-color: transparent; border-style: solid solid outset; } .gitment-editor-main::before, .gitment-comment-main::before { border-width: 8px; border-right-color: #CFD8DC; } .gitment-editor-main::after, .gitment-comment-main::after { margin-top: 1px; margin-left: 2px; border-width: 7px; border-right-color: #fff; } .gitment-comment-header { margin: 12px 15px; color: #666; background-color: #fff; border-radius: 3px; } .gitment-editor-header { padding: 0; margin: 0; border-bottom: 1px solid #CFD8DC; } a.gitment-comment-name, a.gitment-comment-name:visited { font-weight: 600; color: #666; } .gitment-editor-tabs { margin-bottom: -1px; margin-left: -1px; } .gitment-editor-tab { display: inline-block; padding: 11px 12px; font-size: 14px; line-height: 20px; color: #666; text-decoration: none; background-color: transparent; border-width: 0 1px; border-style: solid; border-color: transparent; border-radius: 0; white-space: nowrap; cursor: pointer; user-select: none; outline: none; } .gitment-editor-tab.gitment-selected { color: #333; background-color: #fff; border-color: #CFD8DC; } .gitment-editor-login { float: right; margin-top: -30px; margin-right: 15px; } a.gitment-footer-project-link, a.gitment-footer-project-link:visited, a.gitment-editor-login-link, a.gitment-editor-login-link:visited { color: #2196F3; } a.gitment-editor-logout-link, a.gitment-editor-logout-link:visited { color: #666; } a.gitment-editor-logout-link:hover { color: #2196F3; text-decoration: none; } .gitment-comment-body { position: relative; margin: 12px 15px; overflow: hidden; border-radius: 3px; } .gitment-comment-body-folded { cursor: pointer; } .gitment-comment-body-folded::before { display: block !important; content: \"\"; position: absolute; width: 100%; left: 0; top: 0; bottom: 50px; pointer-events: none; background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); } .gitment-comment-body-folded::after { display: block !important; content: \"Click to Expand\" !important; text-align: center; color: #666; position: absolute; width: 100%; height: 50px; line-height: 50px; left: 0; bottom: 0; pointer-events: none; background: rgba(255, 255, 255, .9); } .gitment-editor-body { margin: 0; } .gitment-comment-body > *:first-child, .gitment-editor-preview > *:first-child { margin-top: 0 !important; } .gitment-comment-body > *:last-child, .gitment-editor-preview > *:last-child { margin-bottom: 0 !important; } .gitment-editor-body textarea { display: block; width: 100%; min-height: 150px; max-height: 500px; padding: 16px; resize: vertical; max-width: 100%; margin: 0; font-size: 14px; line-height: 1.6; background-color: #fff; color: #333; vertical-align: middle; border: none; border-radius: 0; outline: none; box-shadow: none; overflow: visible; } .gitment-editor-body textarea:focus { background-color: #fff; } .gitment-editor-preview { min-height: 150px; padding: 16px; background-color: transparent; width: 100%; font-size: 14px; line-height: 1.5; word-wrap: break-word; } .gitment-editor-footer { padding: 0; margin-top: 10px; } .gitment-editor-footer::after { display: table; clear: both; content: \"\"; } a.gitment-editor-footer-tip { display: inline-block; padding-top: 10px; font-size: 12px; color: #666; } a.gitment-editor-footer-tip:hover { color: #2196F3; text-decoration: none; } .gitment-comments-pagination { list-style: none; text-align: right; border-radius: 0; margin: -19px 0 19px 0; } .gitment-comments-page-item { display: inline-block; cursor: pointer; border: 1px solid #CFD8DC; margin-left: -1px; padding: .25rem .5rem; } .gitment-comments-page-item:hover { background-color: #f5f5f5; } .gitment-comments-page-item.gitment-selected { background-color: #f5f5f5; } .gitment-editor-submit, .gitment-comments-init-btn { color: #fff; background-color: #00BCD4; position: relative; display: inline-block; padding: 7px 13px; font-size: 14px; font-weight: 600; line-height: 20px; white-space: nowrap; vertical-align: middle; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-size: 110% 110%; border: none; -webkit-appearance: none; -moz-appearance: none; appearance: none; } .gitment-editor-submit:hover, .gitment-comments-init-btn:hover { background-color: #00ACC1; } .gitment-comments-init-btn:disabled, .gitment-editor-submit:disabled { color: rgba(255,255,255,0.75); background-color: #4DD0E1; box-shadow: none; } .gitment-editor-submit { float: right; } .gitment-footer-container { margin-top: 30px; margin-bottom: 20px; text-align: right; font-size: 12px; } /* * Markdown CSS * Copied from https://github.com/sindresorhus/github-markdown-css */ .gitment-markdown { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; line-height: 1.5; color: #333; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; font-size: 16px; line-height: 1.5; word-wrap: break-word; } .gitment-markdown .pl-c { color: #969896; } .gitment-markdown .pl-c1, .gitment-markdown .pl-s .pl-v { color: #0086b3; } .gitment-markdown .pl-e, .gitment-markdown .pl-en { color: #795da3; } .gitment-markdown .pl-smi, .gitment-markdown .pl-s .pl-s1 { color: #333; } .gitment-markdown .pl-ent { color: #63a35c; } .gitment-markdown .pl-k { color: #a71d5d; } .gitment-markdown .pl-s, .gitment-markdown .pl-pds, .gitment-markdown .pl-s .pl-pse .pl-s1, .gitment-markdown .pl-sr, .gitment-markdown .pl-sr .pl-cce, .gitment-markdown .pl-sr .pl-sre, .gitment-markdown .pl-sr .pl-sra { color: #183691; } .gitment-markdown .pl-v, .gitment-markdown .pl-smw { color: #ed6a43; } .gitment-markdown .pl-bu { color: #b52a1d; } .gitment-markdown .pl-ii { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2 { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2::before { content: \"^M\"; } .gitment-markdown .pl-sr .pl-cce { font-weight: bold; color: #63a35c; } .gitment-markdown .pl-ml { color: #693a17; } .gitment-markdown .pl-mh, .gitment-markdown .pl-mh .pl-en, .gitment-markdown .pl-ms { font-weight: bold; color: #1d3e81; } .gitment-markdown .pl-mq { color: #008080; } .gitment-markdown .pl-mi { font-style: italic; color: #333; } .gitment-markdown .pl-mb { font-weight: bold; color: #333; } .gitment-markdown .pl-md { color: #bd2c00; background-color: #ffecec; } .gitment-markdown .pl-mi1 { color: #55a532; background-color: #eaffea; } .gitment-markdown .pl-mc { color: #ef9700; background-color: #ffe3b4; } .gitment-markdown .pl-mi2 { color: #d8d8d8; background-color: #808080; } .gitment-markdown .pl-mdr { font-weight: bold; color: #795da3; } .gitment-markdown .pl-mo { color: #1d3e81; } .gitment-markdown .pl-ba { color: #595e62; } .gitment-markdown .pl-sg { color: #c0c0c0; } .gitment-markdown .pl-corl { text-decoration: underline; color: #183691; } .gitment-markdown .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } .gitment-markdown a { background-color: transparent; -webkit-text-decoration-skip: objects; } .gitment-markdown a:active, .gitment-markdown a:hover { outline-width: 0; } .gitment-markdown strong { font-weight: inherit; } .gitment-markdown strong { font-weight: bolder; } .gitment-markdown h1 { font-size: 2em; margin: 0.67em 0; } .gitment-markdown img { border-style: none; } .gitment-markdown svg:not(:root) { overflow: hidden; } .gitment-markdown code, .gitment-markdown kbd, .gitment-markdown pre { font-family: monospace, monospace; font-size: 1em; } .gitment-markdown hr { box-sizing: content-box; height: 0; overflow: visible; } .gitment-markdown input { font: inherit; margin: 0; } .gitment-markdown input { overflow: visible; } .gitment-markdown [type=\"checkbox\"] { box-sizing: border-box; padding: 0; } .gitment-markdown * { box-sizing: border-box; } .gitment-markdown input { font-family: inherit; font-size: inherit; line-height: inherit; } .gitment-markdown a { color: #0366d6; text-decoration: none; } .gitment-markdown a:hover { text-decoration: underline; } .gitment-markdown strong { font-weight: 600; } .gitment-markdown hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #dfe2e5; } .gitment-markdown hr::before { display: table; content: \"\"; } .gitment-markdown hr::after { display: table; clear: both; content: \"\"; } .gitment-markdown table { border-spacing: 0; border-collapse: collapse; } .gitment-markdown td, .gitment-markdown th { padding: 0; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 0; margin-bottom: 0; } .gitment-markdown h1 { font-size: 32px; font-weight: 600; } .gitment-markdown h2 { font-size: 24px; font-weight: 600; } .gitment-markdown h3 { font-size: 20px; font-weight: 600; } .gitment-markdown h4 { font-size: 16px; font-weight: 600; } .gitment-markdown h5 { font-size: 14px; font-weight: 600; } .gitment-markdown h6 { font-size: 12px; font-weight: 600; } .gitment-markdown p { margin-top: 0; margin-bottom: 10px; } .gitment-markdown blockquote { margin: 0; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } .gitment-markdown ol ol, .gitment-markdown ul ol { list-style-type: lower-roman; } .gitment-markdown ul ul ol, .gitment-markdown ul ol ol, .gitment-markdown ol ul ol, .gitment-markdown ol ol ol { list-style-type: lower-alpha; } .gitment-markdown dd { margin-left: 0; } .gitment-markdown code { font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; font-size: 12px; } .gitment-markdown pre { margin-top: 0; margin-bottom: 0; font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; } .gitment-markdown .octicon { vertical-align: text-bottom; } .gitment-markdown .pl-0 { padding-left: 0 !important; } .gitment-markdown .pl-1 { padding-left: 4px !important; } .gitment-markdown .pl-2 { padding-left: 8px !important; } .gitment-markdown .pl-3 { padding-left: 16px !important; } .gitment-markdown .pl-4 { padding-left: 24px !important; } .gitment-markdown .pl-5 { padding-left: 32px !important; } .gitment-markdown .pl-6 { padding-left: 40px !important; } .gitment-markdown::before { display: table; content: \"\"; } .gitment-markdown::after { display: table; clear: both; content: \"\"; } .gitment-markdown>*:first-child { margin-top: 0 !important; } .gitment-markdown>*:last-child { margin-bottom: 0 !important; } .gitment-markdown a:not([href]) { color: inherit; text-decoration: none; } .gitment-markdown .anchor { float: left; padding-right: 4px; margin-left: -20px; line-height: 1; } .gitment-markdown .anchor:focus { outline: none; } .gitment-markdown p, .gitment-markdown blockquote, .gitment-markdown ul, .gitment-markdown ol, .gitment-markdown dl, .gitment-markdown table, .gitment-markdown pre { margin-top: 0; margin-bottom: 16px; } .gitment-markdown hr { height: 0.25em; padding: 0; margin: 24px 0; background-color: #e1e4e8; border: 0; } .gitment-markdown blockquote { padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; } .gitment-markdown blockquote>:first-child { margin-top: 0; } .gitment-markdown blockquote>:last-child { margin-bottom: 0; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fafbfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; } .gitment-markdown h1 .octicon-link, .gitment-markdown h2 .octicon-link, .gitment-markdown h3 .octicon-link, .gitment-markdown h4 .octicon-link, .gitment-markdown h5 .octicon-link, .gitment-markdown h6 .octicon-link { color: #1b1f23; vertical-align: middle; visibility: hidden; } .gitment-markdown h1:hover .anchor, .gitment-markdown h2:hover .anchor, .gitment-markdown h3:hover .anchor, .gitment-markdown h4:hover .anchor, .gitment-markdown h5:hover .anchor, .gitment-markdown h6:hover .anchor { text-decoration: none; } .gitment-markdown h1:hover .anchor .octicon-link, .gitment-markdown h2:hover .anchor .octicon-link, .gitment-markdown h3:hover .anchor .octicon-link, .gitment-markdown h4:hover .anchor .octicon-link, .gitment-markdown h5:hover .anchor .octicon-link, .gitment-markdown h6:hover .anchor .octicon-link { visibility: visible; } .gitment-markdown h1 { padding-bottom: 0.3em; font-size: 2em; border-bottom: 1px solid #eaecef; } .gitment-markdown h2 { padding-bottom: 0.3em; font-size: 1.5em; border-bottom: 1px solid #eaecef; } .gitment-markdown h3 { font-size: 1.25em; } .gitment-markdown h4 { font-size: 1em; } .gitment-markdown h5 { font-size: 0.875em; } .gitment-markdown h6 { font-size: 0.85em; color: #6a737d; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 2em; } .gitment-markdown ul ul, .gitment-markdown ul ol, .gitment-markdown ol ol, .gitment-markdown ol ul { margin-top: 0; margin-bottom: 0; } .gitment-markdown li>p { margin-top: 16px; } .gitment-markdown li+li { margin-top: 0.25em; } .gitment-markdown dl { padding: 0; } .gitment-markdown dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: 600; } .gitment-markdown dl dd { padding: 0 16px; margin-bottom: 16px; } .gitment-markdown table { display: block; width: 100%; overflow: auto; } .gitment-markdown table th { font-weight: 600; } .gitment-markdown table th, .gitment-markdown table td { padding: 6px 13px; border: 1px solid #dfe2e5; } .gitment-markdown table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } .gitment-markdown table tr:nth-child(2n) { background-color: #f5f5f5; } .gitment-markdown img { max-width: 100%; box-sizing: content-box; background-color: #fff; } .gitment-markdown code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(27,31,35,0.05); border-radius: 0; } .gitment-markdown code::before, .gitment-markdown code::after { letter-spacing: -0.2em; content: \"\\00a0\"; } .gitment-markdown pre { word-wrap: normal; } .gitment-markdown pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .gitment-markdown .highlight { margin-bottom: 16px; } .gitment-markdown .highlight pre { margin-bottom: 0; word-break: normal; } .gitment-markdown .highlight pre, .gitment-markdown pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f5f5f5; border-radius: 0; } .gitment-markdown pre code { display: inline; max-width: auto; padding: 0; margin: 0; overflow: visible; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .gitment-markdown pre code::before, .gitment-markdown pre code::after { content: normal; } .gitment-markdown .full-commit .btn-outline:not(:disabled):hover { color: #005cc5; border-color: #005cc5; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown :checked+.radio-label { position: relative; z-index: 1; border-color: #0366d6; } .gitment-markdown .task-list-item { list-style-type: none; } .gitment-markdown .task-list-item+.task-list-item { margin-top: 3px; } .gitment-markdown .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } .gitment-markdown hr { border-bottom-color: #eee; }"},{"title":"","date":"2018-12-17T07:52:13.509Z","updated":"2018-12-17T07:42:13.872Z","comments":true,"path":"gitment/js/gitment.browser.js","permalink":"http://smarxpan.github.io/gitment/js/gitment.browser.js","excerpt":"","text":"var Gitment = /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ i: moduleId, /******/ l: false, /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.l = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // identity function for calling harmony imports with the correct context /******/ __webpack_require__.i = function(value) { return value; }; /******/ /******/ // define getter function for harmony exports /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if(!__webpack_require__.o(exports, name)) { /******/ Object.defineProperty(exports, name, { /******/ configurable: false, /******/ enumerable: true, /******/ get: getter /******/ }); /******/ } /******/ }; /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules /******/ __webpack_require__.n = function(module) { /******/ var getter = module && module.__esModule ? /******/ function getDefault() { return module['default']; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, 'a', getter); /******/ return getter; /******/ }; /******/ /******/ // Object.prototype.hasOwnProperty.call /******/ __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = ''; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(__webpack_require__.s = 5); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); var LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token'; var LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info'; var NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized'); /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; /* WEBPACK VAR INJECTION */(function(global) { var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; var __extends = undefined && undefined.__extends || function () { var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; } || function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) d[p] = b[p]; } }; return function (d, b) { extendStatics(d, b); function __() { this.constructor = d; } d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); }; }(); Object.defineProperty(exports, \"__esModule\", { value: true }); registerGlobals(); exports.extras = { allowStateChanges: allowStateChanges, deepEqual: deepEqual, getAtom: getAtom, getDebugName: getDebugName, getDependencyTree: getDependencyTree, getAdministration: getAdministration, getGlobalState: getGlobalState, getObserverTree: getObserverTree, isComputingDerivation: isComputingDerivation, isSpyEnabled: isSpyEnabled, onReactionError: onReactionError, resetGlobalState: resetGlobalState, shareGlobalState: shareGlobalState, spyReport: spyReport, spyReportEnd: spyReportEnd, spyReportStart: spyReportStart, setReactionScheduler: setReactionScheduler }; if ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") { __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports); } module.exports.default = module.exports; var actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) { var actionName = args && args.length === 1 ? args[0] : value.name || key || \"\"; var wrappedAction = action(actionName, value); addHiddenProp(target, key, wrappedAction); }, function (key) { return this[key]; }, function () { invariant(false, getMessage(\"m001\")); }, false, true); var boundActionDecorator = createClassPropertyDecorator(function (target, key, value) { defineBoundAction(target, key, value); }, function (key) { return this[key]; }, function () { invariant(false, getMessage(\"m001\")); }, false, false); var action = function action(arg1, arg2, arg3, arg4) { if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"\", arg1); if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2); if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1); return namedActionDecorator(arg2).apply(null, arguments); }; exports.action = action; action.bound = function boundAction(arg1, arg2, arg3) { if (typeof arg1 === \"function\") { var action_1 = createAction(\"\", arg1); action_1.autoBind = true; return action_1; } return boundActionDecorator.apply(null, arguments); }; function namedActionDecorator(name) { return function (target, prop, descriptor) { if (descriptor && typeof descriptor.value === \"function\") { descriptor.value = createAction(name, descriptor.value); descriptor.enumerable = false; descriptor.configurable = true; return descriptor; } return actionFieldDecorator(name).apply(this, arguments); }; } function runInAction(arg1, arg2, arg3) { var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"\"; var fn = typeof arg1 === \"function\" ? arg1 : arg2; var scope = typeof arg1 === \"function\" ? arg2 : arg3; invariant(typeof fn === \"function\", getMessage(\"m002\")); invariant(fn.length === 0, getMessage(\"m003\")); invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\"); return executeAction(actionName, fn, scope, undefined); } exports.runInAction = runInAction; function isAction(thing) { return typeof thing === \"function\" && thing.isMobxAction === true; } exports.isAction = isAction; function defineBoundAction(target, propertyName, fn) { var res = function res() { return executeAction(propertyName, fn, target, arguments); }; res.isMobxAction = true; addHiddenProp(target, propertyName, res); } function autorun(arg1, arg2, arg3) { var name, view, scope; if (typeof arg1 === \"string\") { name = arg1; view = arg2; scope = arg3; } else { name = arg1.name || \"Autorun@\" + getNextId(); view = arg1; scope = arg2; } invariant(typeof view === \"function\", getMessage(\"m004\")); invariant(isAction(view) === false, getMessage(\"m005\")); if (scope) view = view.bind(scope); var reaction = new Reaction(name, function () { this.track(reactionRunner); }); function reactionRunner() { view(reaction); } reaction.schedule(); return reaction.getDisposer(); } exports.autorun = autorun; function when(arg1, arg2, arg3, arg4) { var name, predicate, effect, scope; if (typeof arg1 === \"string\") { name = arg1; predicate = arg2; effect = arg3; scope = arg4; } else { name = \"When@\" + getNextId(); predicate = arg1; effect = arg2; scope = arg3; } var disposer = autorun(name, function (r) { if (predicate.call(scope)) { r.dispose(); var prevUntracked = untrackedStart(); effect.call(scope); untrackedEnd(prevUntracked); } }); return disposer; } exports.when = when; function autorunAsync(arg1, arg2, arg3, arg4) { var name, func, delay, scope; if (typeof arg1 === \"string\") { name = arg1; func = arg2; delay = arg3; scope = arg4; } else { name = arg1.name || \"AutorunAsync@\" + getNextId(); func = arg1; delay = arg2; scope = arg3; } invariant(isAction(func) === false, getMessage(\"m006\")); if (delay === void 0) delay = 1; if (scope) func = func.bind(scope); var isScheduled = false; var r = new Reaction(name, function () { if (!isScheduled) { isScheduled = true; setTimeout(function () { isScheduled = false; if (!r.isDisposed) r.track(reactionRunner); }, delay); } }); function reactionRunner() { func(r); } r.schedule(); return r.getDisposer(); } exports.autorunAsync = autorunAsync; function reaction(expression, effect, arg3) { if (arguments.length > 3) { fail(getMessage(\"m007\")); } if (isModifierDescriptor(expression)) { fail(getMessage(\"m008\")); } var opts; if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") { opts = arg3; } else { opts = {}; } opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId(); opts.fireImmediately = arg3 === true || opts.fireImmediately === true; opts.delay = opts.delay || 0; opts.compareStructural = opts.compareStructural || opts.struct || false; effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect); if (opts.context) { expression = expression.bind(opts.context); } var firstTime = true; var isScheduled = false; var nextValue; var r = new Reaction(opts.name, function () { if (firstTime || opts.delay < 1) { reactionRunner(); } else if (!isScheduled) { isScheduled = true; setTimeout(function () { isScheduled = false; reactionRunner(); }, opts.delay); } }); function reactionRunner() { if (r.isDisposed) return; var changed = false; r.track(function () { var v = expression(r); changed = valueDidChange(opts.compareStructural, nextValue, v); nextValue = v; }); if (firstTime && opts.fireImmediately) effect(nextValue, r); if (!firstTime && changed === true) effect(nextValue, r); if (firstTime) firstTime = false; } r.schedule(); return r.getDisposer(); } exports.reaction = reaction; function createComputedDecorator(compareStructural) { return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) { invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\")); invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\")); var adm = asObservableObject(target, ''); defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false); }, function (name) { var observable = this.$mobx.values[name]; if (observable === undefined) return undefined; return observable.get(); }, function (name, value) { this.$mobx.values[name].set(value); }, false, false); } var computedDecorator = createComputedDecorator(false); var computedStructDecorator = createComputedDecorator(true); var computed = function computed(arg1, arg2, arg3) { if (typeof arg2 === \"string\") { return computedDecorator.apply(null, arguments); } invariant(typeof arg1 === \"function\", getMessage(\"m011\")); invariant(arguments.length < 3, getMessage(\"m012\")); var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {}; opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter; return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || '', opts.setter); }; exports.computed = computed; computed.struct = computedStructDecorator; function createTransformer(transformer, onCleanup) { invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\"); var objectCache = {}; var resetId = globalState.resetId; var Transformer = function (_super) { __extends(Transformer, _super); function Transformer(sourceIdentifier, sourceObject) { var _this = _super.call(this, function () { return transformer(sourceObject); }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this; _this.sourceIdentifier = sourceIdentifier; _this.sourceObject = sourceObject; return _this; } Transformer.prototype.onBecomeUnobserved = function () { var lastValue = this.value; _super.prototype.onBecomeUnobserved.call(this); delete objectCache[this.sourceIdentifier]; if (onCleanup) onCleanup(lastValue, this.sourceObject); }; return Transformer; }(ComputedValue); return function (object) { if (resetId !== globalState.resetId) { objectCache = {}; resetId = globalState.resetId; } var identifier = getMemoizationId(object); var reactiveTransformer = objectCache[identifier]; if (reactiveTransformer) return reactiveTransformer.get(); reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object); return reactiveTransformer.get(); }; } exports.createTransformer = createTransformer; function getMemoizationId(object) { if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object); var tid = object.$transformId; if (tid === undefined) { tid = getNextId(); addHiddenProp(object, \"$transformId\", tid); } return tid; } function expr(expr, scope) { if (!isComputingDerivation()) console.warn(getMessage(\"m013\")); return computed(expr, { context: scope }).get(); } exports.expr = expr; function extendObservable(target) { var properties = []; for (var _i = 1; _i < arguments.length; _i++) { properties[_i - 1] = arguments[_i]; } return extendObservableHelper(target, deepEnhancer, properties); } exports.extendObservable = extendObservable; function extendShallowObservable(target) { var properties = []; for (var _i = 1; _i < arguments.length; _i++) { properties[_i - 1] = arguments[_i]; } return extendObservableHelper(target, referenceEnhancer, properties); } exports.extendShallowObservable = extendShallowObservable; function extendObservableHelper(target, defaultEnhancer, properties) { invariant(arguments.length >= 2, getMessage(\"m014\")); invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\")); invariant(!isObservableMap(target), getMessage(\"m016\")); properties.forEach(function (propSet) { invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\")); invariant(!isObservable(propSet), getMessage(\"m018\")); }); var adm = asObservableObject(target); var definedProps = {}; for (var i = properties.length - 1; i >= 0; i--) { var propSet = properties[i]; for (var key in propSet) { if (definedProps[key] !== true && hasOwnProperty(propSet, key)) { definedProps[key] = true; if (target === propSet && !isPropertyConfigurable(target, key)) continue; var descriptor = Object.getOwnPropertyDescriptor(propSet, key); defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer); } } } return target; } function getDependencyTree(thing, property) { return nodeToDependencyTree(getAtom(thing, property)); } function nodeToDependencyTree(node) { var result = { name: node.name }; if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree); return result; } function getObserverTree(thing, property) { return nodeToObserverTree(getAtom(thing, property)); } function nodeToObserverTree(node) { var result = { name: node.name }; if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree); return result; } function intercept(thing, propOrHandler, handler) { if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler); } exports.intercept = intercept; function interceptInterceptable(thing, handler) { return getAdministration(thing).intercept(handler); } function interceptProperty(thing, property, handler) { return getAdministration(thing, property).intercept(handler); } function isComputed(value, property) { if (value === null || value === undefined) return false; if (property !== undefined) { if (isObservableObject(value) === false) return false; var atom = getAtom(value, property); return isComputedValue(atom); } return isComputedValue(value); } exports.isComputed = isComputed; function isObservable(value, property) { if (value === null || value === undefined) return false; if (property !== undefined) { if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) { var o = value.$mobx; return o.values && !!o.values[property]; } return false; } return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value); } exports.isObservable = isObservable; var deepDecorator = createDecoratorForEnhancer(deepEnhancer); var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer); var refDecorator = createDecoratorForEnhancer(referenceEnhancer); var deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer); var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer); function createObservable(v) { if (v === void 0) { v = undefined; } if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments); invariant(arguments.length 2) incorrectlyUsedAsDecorator(\"box\"); return new ObservableValue(value, deepEnhancer, name); }; IObservableFactories.prototype.shallowBox = function (value, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\"); return new ObservableValue(value, referenceEnhancer, name); }; IObservableFactories.prototype.array = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\"); return new ObservableArray(initialValues, deepEnhancer, name); }; IObservableFactories.prototype.shallowArray = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\"); return new ObservableArray(initialValues, referenceEnhancer, name); }; IObservableFactories.prototype.map = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\"); return new ObservableMap(initialValues, deepEnhancer, name); }; IObservableFactories.prototype.shallowMap = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\"); return new ObservableMap(initialValues, referenceEnhancer, name); }; IObservableFactories.prototype.object = function (props, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\"); var res = {}; asObservableObject(res, name); extendObservable(res, props); return res; }; IObservableFactories.prototype.shallowObject = function (props, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\"); var res = {}; asObservableObject(res, name); extendShallowObservable(res, props); return res; }; IObservableFactories.prototype.ref = function () { if (arguments.length < 2) { return createModifierDescriptor(referenceEnhancer, arguments[0]); } else { return refDecorator.apply(null, arguments); } }; IObservableFactories.prototype.shallow = function () { if (arguments.length < 2) { return createModifierDescriptor(shallowEnhancer, arguments[0]); } else { return shallowDecorator.apply(null, arguments); } }; IObservableFactories.prototype.deep = function () { if (arguments.length < 2) { return createModifierDescriptor(deepEnhancer, arguments[0]); } else { return deepDecorator.apply(null, arguments); } }; IObservableFactories.prototype.struct = function () { if (arguments.length < 2) { return createModifierDescriptor(deepStructEnhancer, arguments[0]); } else { return deepStructDecorator.apply(null, arguments); } }; return IObservableFactories; }(); exports.IObservableFactories = IObservableFactories; var observable = createObservable; exports.observable = observable; Object.keys(IObservableFactories.prototype).forEach(function (key) { return observable[key] = IObservableFactories.prototype[key]; }); observable.deep.struct = observable.struct; observable.ref.struct = function () { if (arguments.length < 2) { return createModifierDescriptor(refStructEnhancer, arguments[0]); } else { return refStructDecorator.apply(null, arguments); } }; function incorrectlyUsedAsDecorator(methodName) { fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\"); } function createDecoratorForEnhancer(enhancer) { invariant(!!enhancer, \":(\"); return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) { assertPropertyConfigurable(target, name); invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\")); var adm = asObservableObject(target, undefined); defineObservableProperty(adm, name, baseValue, enhancer); }, function (name) { var observable = this.$mobx.values[name]; if (observable === undefined) return undefined; return observable.get(); }, function (name, value) { setPropertyValue(this, name, value); }, true, false); } function observe(thing, propOrCb, cbOrFire, fireImmediately) { if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire); } exports.observe = observe; function observeObservable(thing, listener, fireImmediately) { return getAdministration(thing).observe(listener, fireImmediately); } function observeObservableProperty(thing, property, listener, fireImmediately) { return getAdministration(thing, property).observe(listener, fireImmediately); } function toJS(source, detectCycles, __alreadySeen) { if (detectCycles === void 0) { detectCycles = true; } if (__alreadySeen === void 0) { __alreadySeen = []; } function cache(value) { if (detectCycles) __alreadySeen.push([source, value]); return value; } if (isObservable(source)) { if (detectCycles && __alreadySeen === null) __alreadySeen = []; if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") { for (var i = 0, l = __alreadySeen.length; i < l; i++) { if (__alreadySeen[i][0] === source) return __alreadySeen[i][1]; } } if (isObservableArray(source)) { var res = cache([]); var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); }); res.length = toAdd.length; for (var i = 0, l = toAdd.length; i < l; i++) { res[i] = toAdd[i]; }return res; } if (isObservableObject(source)) { var res = cache({}); for (var key in source) { res[key] = toJS(source[key], detectCycles, __alreadySeen); }return res; } if (isObservableMap(source)) { var res_1 = cache({}); source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); }); return res_1; } if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen); } return source; } exports.toJS = toJS; function transaction(action, thisArg) { if (thisArg === void 0) { thisArg = undefined; } deprecated(getMessage(\"m023\")); return runInTransaction.apply(undefined, arguments); } exports.transaction = transaction; function runInTransaction(action, thisArg) { if (thisArg === void 0) { thisArg = undefined; } return executeAction('', action); } function log(msg) { console.log(msg); return msg; } function whyRun(thing, prop) { switch (arguments.length) { case 0: thing = globalState.trackingDerivation; if (!thing) return log(getMessage(\"m024\")); break; case 2: thing = getAtom(thing, prop); break; } thing = getAtom(thing); if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun()); return fail(getMessage(\"m025\")); } exports.whyRun = whyRun; function createAction(actionName, fn) { invariant(typeof fn === \"function\", getMessage(\"m026\")); invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\"); var res = function res() { return executeAction(actionName, fn, this, arguments); }; res.originalFn = fn; res.isMobxAction = true; return res; } function executeAction(actionName, fn, scope, args) { var runInfo = startAction(actionName, fn, scope, args); try { return fn.apply(scope, args); } finally { endAction(runInfo); } } function startAction(actionName, fn, scope, args) { var notifySpy = isSpyEnabled() && !!actionName; var startTime = 0; if (notifySpy) { startTime = Date.now(); var l = args && args.length || 0; var flattendArgs = new Array(l); if (l > 0) for (var i = 0; i < l; i++) { flattendArgs[i] = args[i]; }spyReportStart({ type: \"action\", name: actionName, fn: fn, object: scope, arguments: flattendArgs }); } var prevDerivation = untrackedStart(); startBatch(); var prevAllowStateChanges = allowStateChangesStart(true); return { prevDerivation: prevDerivation, prevAllowStateChanges: prevAllowStateChanges, notifySpy: notifySpy, startTime: startTime }; } function endAction(runInfo) { allowStateChangesEnd(runInfo.prevAllowStateChanges); endBatch(); untrackedEnd(runInfo.prevDerivation); if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime }); } function useStrict(strict) { invariant(globalState.trackingDerivation === null, getMessage(\"m028\")); globalState.strictMode = strict; globalState.allowStateChanges = !strict; } exports.useStrict = useStrict; function isStrictModeEnabled() { return globalState.strictMode; } exports.isStrictModeEnabled = isStrictModeEnabled; function allowStateChanges(allowStateChanges, func) { var prev = allowStateChangesStart(allowStateChanges); var res; try { res = func(); } finally { allowStateChangesEnd(prev); } return res; } function allowStateChangesStart(allowStateChanges) { var prev = globalState.allowStateChanges; globalState.allowStateChanges = allowStateChanges; return prev; } function allowStateChangesEnd(prev) { globalState.allowStateChanges = prev; } var BaseAtom = function () { function BaseAtom(name) { if (name === void 0) { name = \"Atom@\" + getNextId(); } this.name = name; this.isPendingUnobservation = true; this.observers = []; this.observersIndexes = {}; this.diffValue = 0; this.lastAccessedBy = 0; this.lowestObserverState = IDerivationState.NOT_TRACKING; } BaseAtom.prototype.onBecomeUnobserved = function () {}; BaseAtom.prototype.reportObserved = function () { reportObserved(this); }; BaseAtom.prototype.reportChanged = function () { startBatch(); propagateChanged(this); endBatch(); }; BaseAtom.prototype.toString = function () { return this.name; }; return BaseAtom; }(); exports.BaseAtom = BaseAtom; var Atom = function (_super) { __extends(Atom, _super); function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) { if (name === void 0) { name = \"Atom@\" + getNextId(); } if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; } if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; } var _this = _super.call(this, name) || this; _this.name = name; _this.onBecomeObservedHandler = onBecomeObservedHandler; _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler; _this.isPendingUnobservation = false; _this.isBeingTracked = false; return _this; } Atom.prototype.reportObserved = function () { startBatch(); _super.prototype.reportObserved.call(this); if (!this.isBeingTracked) { this.isBeingTracked = true; this.onBecomeObservedHandler(); } endBatch(); return !!globalState.trackingDerivation; }; Atom.prototype.onBecomeUnobserved = function () { this.isBeingTracked = false; this.onBecomeUnobservedHandler(); }; return Atom; }(BaseAtom); exports.Atom = Atom; var isAtom = createInstanceofPredicate(\"Atom\", BaseAtom); var ComputedValue = function () { function ComputedValue(derivation, scope, compareStructural, name, setter) { this.derivation = derivation; this.scope = scope; this.compareStructural = compareStructural; this.dependenciesState = IDerivationState.NOT_TRACKING; this.observing = []; this.newObserving = null; this.isPendingUnobservation = false; this.observers = []; this.observersIndexes = {}; this.diffValue = 0; this.runId = 0; this.lastAccessedBy = 0; this.lowestObserverState = IDerivationState.UP_TO_DATE; this.unboundDepsCount = 0; this.__mapid = \"#\" + getNextId(); this.value = undefined; this.isComputing = false; this.isRunningSetter = false; this.name = name || \"ComputedValue@\" + getNextId(); if (setter) this.setter = createAction(name + \"-setter\", setter); } ComputedValue.prototype.onBecomeStale = function () { propagateMaybeChanged(this); }; ComputedValue.prototype.onBecomeUnobserved = function () { invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\")); clearObserving(this); this.value = undefined; }; ComputedValue.prototype.get = function () { invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation); if (globalState.inBatch === 0) { startBatch(); if (shouldCompute(this)) this.value = this.computeValue(false); endBatch(); } else { reportObserved(this); if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this); } var result = this.value; if (isCaughtException(result)) throw result.cause; return result; }; ComputedValue.prototype.peek = function () { var res = this.computeValue(false); if (isCaughtException(res)) throw res.cause; return res; }; ComputedValue.prototype.set = function (value) { if (this.setter) { invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\"); this.isRunningSetter = true; try { this.setter.call(this.scope, value); } finally { this.isRunningSetter = false; } } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\"); }; ComputedValue.prototype.trackAndCompute = function () { if (isSpyEnabled()) { spyReport({ object: this.scope, type: \"compute\", fn: this.derivation }); } var oldValue = this.value; var newValue = this.value = this.computeValue(true); return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue); }; ComputedValue.prototype.computeValue = function (track) { this.isComputing = true; globalState.computationDepth++; var res; if (track) { res = trackDerivedFunction(this, this.derivation, this.scope); } else { try { res = this.derivation.call(this.scope); } catch (e) { res = new CaughtException(e); } } globalState.computationDepth--; this.isComputing = false; return res; }; ; ComputedValue.prototype.observe = function (listener, fireImmediately) { var _this = this; var firstTime = true; var prevValue = undefined; return autorun(function () { var newValue = _this.get(); if (!firstTime || fireImmediately) { var prevU = untrackedStart(); listener({ type: \"update\", object: _this, newValue: newValue, oldValue: prevValue }); untrackedEnd(prevU); } firstTime = false; prevValue = newValue; }); }; ComputedValue.prototype.toJSON = function () { return this.get(); }; ComputedValue.prototype.toString = function () { return this.name + \"[\" + this.derivation.toString() + \"]\"; }; ComputedValue.prototype.valueOf = function () { return toPrimitive(this.get()); }; ; ComputedValue.prototype.whyRun = function () { var isTracking = Boolean(globalState.trackingDerivation); var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) { return dep.name; }); var observers = unique(getObservers(this).map(function (dep) { return dep.name; })); return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n \" + joinStrings(observing) + \"\\n \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : '') + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n * If the outcome of this computation changes, the following observers will be re-run:\\n \" + joinStrings(observers) + \"\\n\"); }; return ComputedValue; }(); ComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf; var isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue); var IDerivationState; (function (IDerivationState) { IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\"; IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\"; IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\"; IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\"; })(IDerivationState || (IDerivationState = {})); exports.IDerivationState = IDerivationState; var CaughtException = function () { function CaughtException(cause) { this.cause = cause; } return CaughtException; }(); function isCaughtException(e) { return e instanceof CaughtException; } function shouldCompute(derivation) { switch (derivation.dependenciesState) { case IDerivationState.UP_TO_DATE: return false; case IDerivationState.NOT_TRACKING: case IDerivationState.STALE: return true; case IDerivationState.POSSIBLY_STALE: { var prevUntracked = untrackedStart(); var obs = derivation.observing, l = obs.length; for (var i = 0; i < l; i++) { var obj = obs[i]; if (isComputedValue(obj)) { try { obj.get(); } catch (e) { untrackedEnd(prevUntracked); return true; } if (derivation.dependenciesState === IDerivationState.STALE) { untrackedEnd(prevUntracked); return true; } } } changeDependenciesStateTo0(derivation); untrackedEnd(prevUntracked); return false; } } } function isComputingDerivation() { return globalState.trackingDerivation !== null; } function checkIfStateModificationsAreAllowed(atom) { var hasObservers = atom.observers.length > 0; if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name); if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name); } function trackDerivedFunction(derivation, f, context) { changeDependenciesStateTo0(derivation); derivation.newObserving = new Array(derivation.observing.length + 100); derivation.unboundDepsCount = 0; derivation.runId = ++globalState.runId; var prevTracking = globalState.trackingDerivation; globalState.trackingDerivation = derivation; var result; try { result = f.call(context); } catch (e) { result = new CaughtException(e); } globalState.trackingDerivation = prevTracking; bindDependencies(derivation); return result; } function bindDependencies(derivation) { var prevObserving = derivation.observing; var observing = derivation.observing = derivation.newObserving; derivation.newObserving = null; var i0 = 0, l = derivation.unboundDepsCount; for (var i = 0; i < l; i++) { var dep = observing[i]; if (dep.diffValue === 0) { dep.diffValue = 1; if (i0 !== i) observing[i0] = dep; i0++; } } observing.length = i0; l = prevObserving.length; while (l--) { var dep = prevObserving[l]; if (dep.diffValue === 0) { removeObserver(dep, derivation); } dep.diffValue = 0; } while (i0--) { var dep = observing[i0]; if (dep.diffValue === 1) { dep.diffValue = 0; addObserver(dep, derivation); } } } function clearObserving(derivation) { var obs = derivation.observing; var i = obs.length; while (i--) { removeObserver(obs[i], derivation); }derivation.dependenciesState = IDerivationState.NOT_TRACKING; obs.length = 0; } function untracked(action) { var prev = untrackedStart(); var res = action(); untrackedEnd(prev); return res; } exports.untracked = untracked; function untrackedStart() { var prev = globalState.trackingDerivation; globalState.trackingDerivation = null; return prev; } function untrackedEnd(prev) { globalState.trackingDerivation = prev; } function changeDependenciesStateTo0(derivation) { if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return; derivation.dependenciesState = IDerivationState.UP_TO_DATE; var obs = derivation.observing; var i = obs.length; while (i--) { obs[i].lowestObserverState = IDerivationState.UP_TO_DATE; } } var persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"]; var MobXGlobals = function () { function MobXGlobals() { this.version = 5; this.trackingDerivation = null; this.computationDepth = 0; this.runId = 0; this.mobxGuid = 0; this.inBatch = 0; this.pendingUnobservations = []; this.pendingReactions = []; this.isRunningReactions = false; this.allowStateChanges = true; this.strictMode = false; this.resetId = 0; this.spyListeners = []; this.globalReactionErrorHandlers = []; } return MobXGlobals; }(); var globalState = new MobXGlobals(); function shareGlobalState() { var global = getGlobal(); var ownState = globalState; if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\"); if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\"); if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState; } function getGlobalState() { return globalState; } function registerGlobals() {} function resetGlobalState() { globalState.resetId++; var defaultGlobals = new MobXGlobals(); for (var key in defaultGlobals) { if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key]; }globalState.allowStateChanges = !globalState.strictMode; } function hasObservers(observable) { return observable.observers && observable.observers.length > 0; } function getObservers(observable) { return observable.observers; } function invariantObservers(observable) { var list = observable.observers; var map = observable.observersIndexes; var l = list.length; for (var i = 0; i < l; i++) { var id = list[i].__mapid; if (i) { invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\"); } else { invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\"); } } invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\"); } function addObserver(observable, node) { var l = observable.observers.length; if (l) { observable.observersIndexes[node.__mapid] = l; } observable.observers[l] = node; if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState; } function removeObserver(observable, node) { if (observable.observers.length === 1) { observable.observers.length = 0; queueForUnobservation(observable); } else { var list = observable.observers; var map_1 = observable.observersIndexes; var filler = list.pop(); if (filler !== node) { var index = map_1[node.__mapid] || 0; if (index) { map_1[filler.__mapid] = index; } else { delete map_1[filler.__mapid]; } list[index] = filler; } delete map_1[node.__mapid]; } } function queueForUnobservation(observable) { if (!observable.isPendingUnobservation) { observable.isPendingUnobservation = true; globalState.pendingUnobservations.push(observable); } } function startBatch() { globalState.inBatch++; } function endBatch() { if (--globalState.inBatch === 0) { runReactions(); var list = globalState.pendingUnobservations; for (var i = 0; i < list.length; i++) { var observable_1 = list[i]; observable_1.isPendingUnobservation = false; if (observable_1.observers.length === 0) { observable_1.onBecomeUnobserved(); } } globalState.pendingUnobservations = []; } } function reportObserved(observable) { var derivation = globalState.trackingDerivation; if (derivation !== null) { if (derivation.runId !== observable.lastAccessedBy) { observable.lastAccessedBy = derivation.runId; derivation.newObserving[derivation.unboundDepsCount++] = observable; } } else if (observable.observers.length === 0) { queueForUnobservation(observable); } } function invariantLOS(observable, msg) { var min = getObservers(observable).reduce(function (a, b) { return Math.min(a, b.dependenciesState); }, 2); if (min >= observable.lowestObserverState) return; throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState); } function propagateChanged(observable) { if (observable.lowestObserverState === IDerivationState.STALE) return; observable.lowestObserverState = IDerivationState.STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale(); d.dependenciesState = IDerivationState.STALE; } } function propagateChangeConfirmed(observable) { if (observable.lowestObserverState === IDerivationState.STALE) return; observable.lowestObserverState = IDerivationState.STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE; } } function propagateMaybeChanged(observable) { if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return; observable.lowestObserverState = IDerivationState.POSSIBLY_STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.UP_TO_DATE) { d.dependenciesState = IDerivationState.POSSIBLY_STALE; d.onBecomeStale(); } } } var Reaction = function () { function Reaction(name, onInvalidate) { if (name === void 0) { name = \"Reaction@\" + getNextId(); } this.name = name; this.onInvalidate = onInvalidate; this.observing = []; this.newObserving = []; this.dependenciesState = IDerivationState.NOT_TRACKING; this.diffValue = 0; this.runId = 0; this.unboundDepsCount = 0; this.__mapid = \"#\" + getNextId(); this.isDisposed = false; this._isScheduled = false; this._isTrackPending = false; this._isRunning = false; } Reaction.prototype.onBecomeStale = function () { this.schedule(); }; Reaction.prototype.schedule = function () { if (!this._isScheduled) { this._isScheduled = true; globalState.pendingReactions.push(this); runReactions(); } }; Reaction.prototype.isScheduled = function () { return this._isScheduled; }; Reaction.prototype.runReaction = function () { if (!this.isDisposed) { startBatch(); this._isScheduled = false; if (shouldCompute(this)) { this._isTrackPending = true; this.onInvalidate(); if (this._isTrackPending && isSpyEnabled()) { spyReport({ object: this, type: \"scheduled-reaction\" }); } } endBatch(); } }; Reaction.prototype.track = function (fn) { startBatch(); var notify = isSpyEnabled(); var startTime; if (notify) { startTime = Date.now(); spyReportStart({ object: this, type: \"reaction\", fn: fn }); } this._isRunning = true; var result = trackDerivedFunction(this, fn, undefined); this._isRunning = false; this._isTrackPending = false; if (this.isDisposed) { clearObserving(this); } if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause); if (notify) { spyReportEnd({ time: Date.now() - startTime }); } endBatch(); }; Reaction.prototype.reportExceptionInDerivation = function (error) { var _this = this; if (this.errorHandler) { this.errorHandler(error, this); return; } var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this; var messageToUser = getMessage(\"m037\"); console.error(message || messageToUser, error); if (isSpyEnabled()) { spyReport({ type: \"error\", message: message, error: error, object: this }); } globalState.globalReactionErrorHandlers.forEach(function (f) { return f(error, _this); }); }; Reaction.prototype.dispose = function () { if (!this.isDisposed) { this.isDisposed = true; if (!this._isRunning) { startBatch(); clearObserving(this); endBatch(); } } }; Reaction.prototype.getDisposer = function () { var r = this.dispose.bind(this); r.$mobx = this; r.onError = registerErrorHandler; return r; }; Reaction.prototype.toString = function () { return \"Reaction[\" + this.name + \"]\"; }; Reaction.prototype.whyRun = function () { var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) { return dep.name; }); return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n \" + joinStrings(observing) + \"\\n \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : '') + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\"; }; return Reaction; }(); exports.Reaction = Reaction; function registerErrorHandler(handler) { invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\"); invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\"); this.$mobx.errorHandler = handler; } function onReactionError(handler) { globalState.globalReactionErrorHandlers.push(handler); return function () { var idx = globalState.globalReactionErrorHandlers.indexOf(handler); if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1); }; } var MAX_REACTION_ITERATIONS = 100; var reactionScheduler = function reactionScheduler(f) { return f(); }; function runReactions() { if (globalState.inBatch > 0 || globalState.isRunningReactions) return; reactionScheduler(runReactionsHelper); } function runReactionsHelper() { globalState.isRunningReactions = true; var allReactions = globalState.pendingReactions; var iterations = 0; while (allReactions.length > 0) { if (++iterations === MAX_REACTION_ITERATIONS) { console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0])); allReactions.splice(0); } var remainingReactions = allReactions.splice(0); for (var i = 0, l = remainingReactions.length; i < l; i++) { remainingReactions[i].runReaction(); } } globalState.isRunningReactions = false; } var isReaction = createInstanceofPredicate(\"Reaction\", Reaction); function setReactionScheduler(fn) { var baseScheduler = reactionScheduler; reactionScheduler = function reactionScheduler(f) { return fn(function () { return baseScheduler(f); }); }; } function isSpyEnabled() { return !!globalState.spyListeners.length; } function spyReport(event) { if (!globalState.spyListeners.length) return; var listeners = globalState.spyListeners; for (var i = 0, l = listeners.length; i < l; i++) { listeners[i](event); } } function spyReportStart(event) { var change = objectAssign({}, event, { spyReportStart: true }); spyReport(change); } var END_EVENT = { spyReportEnd: true }; function spyReportEnd(change) { if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT); } function spy(listener) { globalState.spyListeners.push(listener); return once(function () { var idx = globalState.spyListeners.indexOf(listener); if (idx !== -1) globalState.spyListeners.splice(idx, 1); }); } exports.spy = spy; function hasInterceptors(interceptable) { return interceptable.interceptors && interceptable.interceptors.length > 0; } function registerInterceptor(interceptable, handler) { var interceptors = interceptable.interceptors || (interceptable.interceptors = []); interceptors.push(handler); return once(function () { var idx = interceptors.indexOf(handler); if (idx !== -1) interceptors.splice(idx, 1); }); } function interceptChange(interceptable, change) { var prevU = untrackedStart(); try { var interceptors = interceptable.interceptors; if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) { change = interceptors[i](change); invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\"); if (!change) break; } return change; } finally { untrackedEnd(prevU); } } function hasListeners(listenable) { return listenable.changeListeners && listenable.changeListeners.length > 0; } function registerListener(listenable, handler) { var listeners = listenable.changeListeners || (listenable.changeListeners = []); listeners.push(handler); return once(function () { var idx = listeners.indexOf(handler); if (idx !== -1) listeners.splice(idx, 1); }); } function notifyListeners(listenable, change) { var prevU = untrackedStart(); var listeners = listenable.changeListeners; if (!listeners) return; listeners = listeners.slice(); for (var i = 0, l = listeners.length; i < l; i++) { listeners[i](change); } untrackedEnd(prevU); } function asReference(value) { deprecated(\"asReference is deprecated, use observable.ref instead\"); return observable.ref(value); } exports.asReference = asReference; function asStructure(value) { deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\"); return observable.struct(value); } exports.asStructure = asStructure; function asFlat(value) { deprecated(\"asFlat is deprecated, use observable.shallow instead\"); return observable.shallow(value); } exports.asFlat = asFlat; function asMap(data) { deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\"); return observable.map(data || {}); } exports.asMap = asMap; function isModifierDescriptor(thing) { return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true; } exports.isModifierDescriptor = isModifierDescriptor; function createModifierDescriptor(enhancer, initialValue) { invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\"); return { isMobxModifierDescriptor: true, initialValue: initialValue, enhancer: enhancer }; } function deepEnhancer(v, _, name) { if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\"); if (isObservable(v)) return v; if (Array.isArray(v)) return observable.array(v, name); if (isPlainObject(v)) return observable.object(v, name); if (isES6Map(v)) return observable.map(v, name); return v; } function shallowEnhancer(v, _, name) { if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\"); if (v === undefined || v === null) return v; if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v; if (Array.isArray(v)) return observable.shallowArray(v, name); if (isPlainObject(v)) return observable.shallowObject(v, name); if (isES6Map(v)) return observable.shallowMap(v, name); return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\"); } function referenceEnhancer(newValue) { return newValue; } function deepStructEnhancer(v, oldValue, name) { if (deepEqual(v, oldValue)) return oldValue; if (isObservable(v)) return v; if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name); if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name); if (isPlainObject(v)) { var res = {}; asObservableObject(res, name); extendObservableHelper(res, deepStructEnhancer, [v]); return res; } return v; } function refStructEnhancer(v, oldValue, name) { if (deepEqual(v, oldValue)) return oldValue; return v; } var MAX_SPLICE_SIZE = 10000; var safariPrototypeSetterInheritanceBug = function () { var v = false; var p = {}; Object.defineProperty(p, \"0\", { set: function set() { v = true; } }); Object.create(p)[\"0\"] = 1; return v === false; }(); var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; var StubArray = function () { function StubArray() {} return StubArray; }(); StubArray.prototype = []; var ObservableArrayAdministration = function () { function ObservableArrayAdministration(name, enhancer, array, owned) { this.array = array; this.owned = owned; this.lastKnownLength = 0; this.interceptors = null; this.changeListeners = null; this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId()); this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name + \"[..]\"); }; } ObservableArrayAdministration.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) { if (fireImmediately === void 0) { fireImmediately = false; } if (fireImmediately) { listener({ object: this.array, type: \"splice\", index: 0, added: this.values.slice(), addedCount: this.values.length, removed: [], removedCount: 0 }); } return registerListener(this, listener); }; ObservableArrayAdministration.prototype.getArrayLength = function () { this.atom.reportObserved(); return this.values.length; }; ObservableArrayAdministration.prototype.setArrayLength = function (newLength) { if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength); var currentLength = this.values.length; if (newLength === currentLength) return;else if (newLength > currentLength) { var newItems = new Array(newLength - currentLength); for (var i = 0; i < newLength - currentLength; i++) { newItems[i] = undefined; }this.spliceWithArray(currentLength, 0, newItems); } else this.spliceWithArray(newLength, currentLength - newLength); }; ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) { if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\"); this.lastKnownLength += delta; if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1); }; ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) { var _this = this; checkIfStateModificationsAreAllowed(this.atom); var length = this.values.length; if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index); if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index)); if (newItems === undefined) newItems = []; if (hasInterceptors(this)) { var change = interceptChange(this, { object: this.array, type: \"splice\", index: index, removedCount: deleteCount, added: newItems }); if (!change) return EMPTY_ARRAY; deleteCount = change.removedCount; newItems = change.added; } newItems = newItems.map(function (v) { return _this.enhancer(v, undefined); }); var lengthDelta = newItems.length - deleteCount; this.updateArrayLength(length, lengthDelta); var res = this.spliceItemsIntoValues(index, deleteCount, newItems); if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res); return res; }; ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) { if (newItems.length < MAX_SPLICE_SIZE) { return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems)); } else { var res = this.values.slice(index, index + deleteCount); this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount)); return res; } var _a; }; ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) { var notifySpy = !this.owned && isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { object: this.array, type: \"update\", index: index, newValue: newValue, oldValue: oldValue } : null; if (notifySpy) spyReportStart(change); this.atom.reportChanged(); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) { var notifySpy = !this.owned && isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { object: this.array, type: \"splice\", index: index, removed: removed, added: added, removedCount: removed.length, addedCount: added.length } : null; if (notifySpy) spyReportStart(change); this.atom.reportChanged(); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; return ObservableArrayAdministration; }(); var ObservableArray = function (_super) { __extends(ObservableArray, _super); function ObservableArray(initialValues, enhancer, name, owned) { if (name === void 0) { name = \"ObservableArray@\" + getNextId(); } if (owned === void 0) { owned = false; } var _this = _super.call(this) || this; var adm = new ObservableArrayAdministration(name, enhancer, _this, owned); addHiddenFinalProp(_this, \"$mobx\", adm); if (initialValues && initialValues.length) { adm.updateArrayLength(0, initialValues.length); adm.values = initialValues.map(function (v) { return enhancer(v, undefined, name + \"[..]\"); }); adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY); } else { adm.values = []; } if (safariPrototypeSetterInheritanceBug) { Object.defineProperty(adm.array, \"0\", ENTRY_0); } return _this; } ObservableArray.prototype.intercept = function (handler) { return this.$mobx.intercept(handler); }; ObservableArray.prototype.observe = function (listener, fireImmediately) { if (fireImmediately === void 0) { fireImmediately = false; } return this.$mobx.observe(listener, fireImmediately); }; ObservableArray.prototype.clear = function () { return this.splice(0); }; ObservableArray.prototype.concat = function () { var arrays = []; for (var _i = 0; _i < arguments.length; _i++) { arrays[_i] = arguments[_i]; } this.$mobx.atom.reportObserved(); return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) { return isObservableArray(a) ? a.peek() : a; })); }; ObservableArray.prototype.replace = function (newItems) { return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems); }; ObservableArray.prototype.toJS = function () { return this.slice(); }; ObservableArray.prototype.toJSON = function () { return this.toJS(); }; ObservableArray.prototype.peek = function () { return this.$mobx.values; }; ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) { if (fromIndex === void 0) { fromIndex = 0; } this.$mobx.atom.reportObserved(); var items = this.$mobx.values, l = items.length; for (var i = fromIndex; i < l; i++) { if (predicate.call(thisArg, items[i], i, this)) return items[i]; }return undefined; }; ObservableArray.prototype.splice = function (index, deleteCount) { var newItems = []; for (var _i = 2; _i < arguments.length; _i++) { newItems[_i - 2] = arguments[_i]; } switch (arguments.length) { case 0: return []; case 1: return this.$mobx.spliceWithArray(index); case 2: return this.$mobx.spliceWithArray(index, deleteCount); } return this.$mobx.spliceWithArray(index, deleteCount, newItems); }; ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) { return this.$mobx.spliceWithArray(index, deleteCount, newItems); }; ObservableArray.prototype.push = function () { var items = []; for (var _i = 0; _i < arguments.length; _i++) { items[_i] = arguments[_i]; } var adm = this.$mobx; adm.spliceWithArray(adm.values.length, 0, items); return adm.values.length; }; ObservableArray.prototype.pop = function () { return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0]; }; ObservableArray.prototype.shift = function () { return this.splice(0, 1)[0]; }; ObservableArray.prototype.unshift = function () { var items = []; for (var _i = 0; _i < arguments.length; _i++) { items[_i] = arguments[_i]; } var adm = this.$mobx; adm.spliceWithArray(0, 0, items); return adm.values.length; }; ObservableArray.prototype.reverse = function () { this.$mobx.atom.reportObserved(); var clone = this.slice(); return clone.reverse.apply(clone, arguments); }; ObservableArray.prototype.sort = function (compareFn) { this.$mobx.atom.reportObserved(); var clone = this.slice(); return clone.sort.apply(clone, arguments); }; ObservableArray.prototype.remove = function (value) { var idx = this.$mobx.values.indexOf(value); if (idx > -1) { this.splice(idx, 1); return true; } return false; }; ObservableArray.prototype.move = function (fromIndex, toIndex) { function checkIndex(index) { if (index < 0) { throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\"); } var length = this.$mobx.values.length; if (index >= length) { throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length); } } checkIndex.call(this, fromIndex); checkIndex.call(this, toIndex); if (fromIndex === toIndex) { return; } var oldItems = this.$mobx.values; var newItems; if (fromIndex < toIndex) { newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1)); } else { newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1)); } this.replace(newItems); }; ObservableArray.prototype.toString = function () { this.$mobx.atom.reportObserved(); return Array.prototype.toString.apply(this.$mobx.values, arguments); }; ObservableArray.prototype.toLocaleString = function () { this.$mobx.atom.reportObserved(); return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments); }; return ObservableArray; }(StubArray); declareIterator(ObservableArray.prototype, function () { return arrayAsIterator(this.slice()); }); makeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]); Object.defineProperty(ObservableArray.prototype, \"length\", { enumerable: false, configurable: true, get: function get() { return this.$mobx.getArrayLength(); }, set: function set(newLength) { this.$mobx.setArrayLength(newLength); } }); [\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) { var baseFunc = Array.prototype[funcName]; invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\"); addHiddenProp(ObservableArray.prototype, funcName, function () { this.$mobx.atom.reportObserved(); return baseFunc.apply(this.$mobx.values, arguments); }); }); var ENTRY_0 = { configurable: true, enumerable: false, set: createArraySetter(0), get: createArrayGetter(0) }; function createArrayBufferItem(index) { var set = createArraySetter(index); var get = createArrayGetter(index); Object.defineProperty(ObservableArray.prototype, '' + index, { enumerable: false, configurable: true, set: set, get: get }); } function createArraySetter(index) { return function (newValue) { var adm = this.$mobx; var values = adm.values; if (index < values.length) { checkIfStateModificationsAreAllowed(adm.atom); var oldValue = values[index]; if (hasInterceptors(adm)) { var change = interceptChange(adm, { type: \"update\", object: adm.array, index: index, newValue: newValue }); if (!change) return; newValue = change.newValue; } newValue = adm.enhancer(newValue, oldValue); var changed = newValue !== oldValue; if (changed) { values[index] = newValue; adm.notifyArrayChildUpdate(index, newValue, oldValue); } } else if (index === values.length) { adm.spliceWithArray(index, 0, [newValue]); } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length); }; } function createArrayGetter(index) { return function () { var impl = this.$mobx; if (impl) { if (index < impl.values.length) { impl.atom.reportObserved(); return impl.values[index]; } console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\"); } return undefined; }; } function reserveArrayBuffer(max) { for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) { createArrayBufferItem(index); }OBSERVABLE_ARRAY_BUFFER_SIZE = max; } reserveArrayBuffer(1000); var isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration); function isObservableArray(thing) { return isObject(thing) && isObservableArrayAdministration(thing.$mobx); } exports.isObservableArray = isObservableArray; var ObservableMapMarker = {}; var ObservableMap = function () { function ObservableMap(initialData, enhancer, name) { if (enhancer === void 0) { enhancer = deepEnhancer; } if (name === void 0) { name = \"ObservableMap@\" + getNextId(); } this.enhancer = enhancer; this.name = name; this.$mobx = ObservableMapMarker; this._data = {}; this._hasMap = {}; this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true); this.interceptors = null; this.changeListeners = null; this.merge(initialData); } ObservableMap.prototype._has = function (key) { return typeof this._data[key] !== \"undefined\"; }; ObservableMap.prototype.has = function (key) { if (!this.isValidKey(key)) return false; key = '' + key; if (this._hasMap[key]) return this._hasMap[key].get(); return this._updateHasMapEntry(key, false).get(); }; ObservableMap.prototype.set = function (key, value) { this.assertValidKey(key); key = '' + key; var hasKey = this._has(key); if (hasInterceptors(this)) { var change = interceptChange(this, { type: hasKey ? \"update\" : \"add\", object: this, newValue: value, name: key }); if (!change) return this; value = change.newValue; } if (hasKey) { this._updateValue(key, value); } else { this._addValue(key, value); } return this; }; ObservableMap.prototype.delete = function (key) { var _this = this; this.assertValidKey(key); key = '' + key; if (hasInterceptors(this)) { var change = interceptChange(this, { type: \"delete\", object: this, name: key }); if (!change) return false; } if (this._has(key)) { var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"delete\", object: this, oldValue: this._data[key].value, name: key } : null; if (notifySpy) spyReportStart(change); runInTransaction(function () { _this._keys.remove(key); _this._updateHasMapEntry(key, false); var observable = _this._data[key]; observable.setNewValue(undefined); _this._data[key] = undefined; }); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); return true; } return false; }; ObservableMap.prototype._updateHasMapEntry = function (key, value) { var entry = this._hasMap[key]; if (entry) { entry.setNewValue(value); } else { entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false); } return entry; }; ObservableMap.prototype._updateValue = function (name, newValue) { var observable = this._data[name]; newValue = observable.prepareNewValue(newValue); if (newValue !== UNCHANGED) { var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"update\", object: this, oldValue: observable.value, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); observable.setNewValue(newValue); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); } }; ObservableMap.prototype._addValue = function (name, newValue) { var _this = this; runInTransaction(function () { var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false); newValue = observable.value; _this._updateHasMapEntry(name, true); _this._keys.push(name); }); var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"add\", object: this, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; ObservableMap.prototype.get = function (key) { key = '' + key; if (this.has(key)) return this._data[key].get(); return undefined; }; ObservableMap.prototype.keys = function () { return arrayAsIterator(this._keys.slice()); }; ObservableMap.prototype.values = function () { return arrayAsIterator(this._keys.map(this.get, this)); }; ObservableMap.prototype.entries = function () { var _this = this; return arrayAsIterator(this._keys.map(function (key) { return [key, _this.get(key)]; })); }; ObservableMap.prototype.forEach = function (callback, thisArg) { var _this = this; this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key, _this); }); }; ObservableMap.prototype.merge = function (other) { var _this = this; if (isObservableMap(other)) { other = other.toJS(); } runInTransaction(function () { if (isPlainObject(other)) Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });else if (Array.isArray(other)) other.forEach(function (_a) { var key = _a[0], value = _a[1]; return _this.set(key, value); });else if (isES6Map(other)) other.forEach(function (value, key) { return _this.set(key, value); });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other); }); return this; }; ObservableMap.prototype.clear = function () { var _this = this; runInTransaction(function () { untracked(function () { _this.keys().forEach(_this.delete, _this); }); }); }; ObservableMap.prototype.replace = function (values) { var _this = this; runInTransaction(function () { _this.clear(); _this.merge(values); }); return this; }; Object.defineProperty(ObservableMap.prototype, \"size\", { get: function get() { return this._keys.length; }, enumerable: true, configurable: true }); ObservableMap.prototype.toJS = function () { var _this = this; var res = {}; this.keys().forEach(function (key) { return res[key] = _this.get(key); }); return res; }; ObservableMap.prototype.toJSON = function () { return this.toJS(); }; ObservableMap.prototype.isValidKey = function (key) { if (key === null || key === undefined) return false; if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true; return false; }; ObservableMap.prototype.assertValidKey = function (key) { if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\"); }; ObservableMap.prototype.toString = function () { var _this = this; return this.name + \"[{ \" + this.keys().map(function (key) { return key + \": \" + ('' + _this.get(key)); }).join(\", \") + \" }]\"; }; ObservableMap.prototype.observe = function (listener, fireImmediately) { invariant(fireImmediately !== true, getMessage(\"m033\")); return registerListener(this, listener); }; ObservableMap.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; return ObservableMap; }(); exports.ObservableMap = ObservableMap; declareIterator(ObservableMap.prototype, function () { return this.entries(); }); function map(initialValues) { deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\"); return observable.map(initialValues); } exports.map = map; var isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap); exports.isObservableMap = isObservableMap; var ObservableObjectAdministration = function () { function ObservableObjectAdministration(target, name) { this.target = target; this.name = name; this.values = {}; this.changeListeners = null; this.interceptors = null; } ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) { invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\"); return registerListener(this, callback); }; ObservableObjectAdministration.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; return ObservableObjectAdministration; }(); function asObservableObject(target, name) { if (isObservableObject(target)) return target.$mobx; invariant(Object.isExtensible(target), getMessage(\"m035\")); if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId(); if (!name) name = \"ObservableObject@\" + getNextId(); var adm = new ObservableObjectAdministration(target, name); addHiddenFinalProp(target, \"$mobx\", adm); return adm; } function defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) { if (adm.values[propName]) { invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\"); adm.target[propName] = descriptor.value; return; } if (\"value\" in descriptor) { if (isModifierDescriptor(descriptor.value)) { var modifierDescriptor = descriptor.value; defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer); } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) { defineBoundAction(adm.target, propName, descriptor.value.originalFn); } else if (isComputedValue(descriptor.value)) { defineComputedPropertyFromComputedValue(adm, propName, descriptor.value); } else { defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer); } } else { defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true); } } function defineObservableProperty(adm, propName, newValue, enhancer) { assertPropertyConfigurable(adm.target, propName); if (hasInterceptors(adm)) { var change = interceptChange(adm, { object: adm.target, name: propName, type: \"add\", newValue: newValue }); if (!change) return; newValue = change.newValue; } var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false); newValue = observable.value; Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName)); notifyPropertyAddition(adm, adm.target, propName, newValue); } function defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) { if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName); adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter); if (asInstanceProperty) { Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName)); } } function defineComputedPropertyFromComputedValue(adm, propName, computedValue) { var name = adm.name + \".\" + propName; computedValue.name = name; if (!computedValue.scope) computedValue.scope = adm.target; adm.values[propName] = computedValue; Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName)); } var observablePropertyConfigs = {}; var computedPropertyConfigs = {}; function generateObservablePropConfig(propName) { return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = { configurable: true, enumerable: true, get: function get() { return this.$mobx.values[propName].get(); }, set: function set(v) { setPropertyValue(this, propName, v); } }); } function generateComputedPropConfig(propName) { return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = { configurable: true, enumerable: false, get: function get() { return this.$mobx.values[propName].get(); }, set: function set(v) { return this.$mobx.values[propName].set(v); } }); } function setPropertyValue(instance, name, newValue) { var adm = instance.$mobx; var observable = adm.values[name]; if (hasInterceptors(adm)) { var change = interceptChange(adm, { type: \"update\", object: instance, name: name, newValue: newValue }); if (!change) return; newValue = change.newValue; } newValue = observable.prepareNewValue(newValue); if (newValue !== UNCHANGED) { var notify = hasListeners(adm); var notifySpy = isSpyEnabled(); var change = notify || notifySpy ? { type: \"update\", object: instance, oldValue: observable.value, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); observable.setNewValue(newValue); if (notify) notifyListeners(adm, change); if (notifySpy) spyReportEnd(); } } function notifyPropertyAddition(adm, object, name, newValue) { var notify = hasListeners(adm); var notifySpy = isSpyEnabled(); var change = notify || notifySpy ? { type: \"add\", object: object, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); if (notify) notifyListeners(adm, change); if (notifySpy) spyReportEnd(); } var isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration); function isObservableObject(thing) { if (isObject(thing)) { runLazyInitializers(thing); return isObservableObjectAdministration(thing.$mobx); } return false; } exports.isObservableObject = isObservableObject; var UNCHANGED = {}; var ObservableValue = function (_super) { __extends(ObservableValue, _super); function ObservableValue(value, enhancer, name, notifySpy) { if (name === void 0) { name = \"ObservableValue@\" + getNextId(); } if (notifySpy === void 0) { notifySpy = true; } var _this = _super.call(this, name) || this; _this.enhancer = enhancer; _this.hasUnreportedChange = false; _this.value = enhancer(value, undefined, name); if (notifySpy && isSpyEnabled()) { spyReport({ type: \"create\", object: _this, newValue: _this.value }); } return _this; } ObservableValue.prototype.set = function (newValue) { var oldValue = this.value; newValue = this.prepareNewValue(newValue); if (newValue !== UNCHANGED) { var notifySpy = isSpyEnabled(); if (notifySpy) { spyReportStart({ type: \"update\", object: this, newValue: newValue, oldValue: oldValue }); } this.setNewValue(newValue); if (notifySpy) spyReportEnd(); } }; ObservableValue.prototype.prepareNewValue = function (newValue) { checkIfStateModificationsAreAllowed(this); if (hasInterceptors(this)) { var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue }); if (!change) return UNCHANGED; newValue = change.newValue; } newValue = this.enhancer(newValue, this.value, this.name); return this.value !== newValue ? newValue : UNCHANGED; }; ObservableValue.prototype.setNewValue = function (newValue) { var oldValue = this.value; this.value = newValue; this.reportChanged(); if (hasListeners(this)) { notifyListeners(this, { type: \"update\", object: this, newValue: newValue, oldValue: oldValue }); } }; ObservableValue.prototype.get = function () { this.reportObserved(); return this.value; }; ObservableValue.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; ObservableValue.prototype.observe = function (listener, fireImmediately) { if (fireImmediately) listener({ object: this, type: \"update\", newValue: this.value, oldValue: undefined }); return registerListener(this, listener); }; ObservableValue.prototype.toJSON = function () { return this.get(); }; ObservableValue.prototype.toString = function () { return this.name + \"[\" + this.value + \"]\"; }; ObservableValue.prototype.valueOf = function () { return toPrimitive(this.get()); }; return ObservableValue; }(BaseAtom); ObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf; var isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue); exports.isBoxedObservable = isObservableValue; function getAtom(thing, property) { if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) { if (isObservableArray(thing)) { invariant(property === undefined, getMessage(\"m036\")); return thing.$mobx.atom; } if (isObservableMap(thing)) { var anyThing = thing; if (property === undefined) return getAtom(anyThing._keys); var observable_2 = anyThing._data[property] || anyThing._hasMap[property]; invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\"); return observable_2; } runLazyInitializers(thing); if (isObservableObject(thing)) { if (!property) return fail(\"please specify a property\"); var observable_3 = thing.$mobx.values[property]; invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\"); return observable_3; } if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) { return thing; } } else if (typeof thing === \"function\") { if (isReaction(thing.$mobx)) { return thing.$mobx; } } return fail(\"Cannot obtain atom from \" + thing); } function getAdministration(thing, property) { invariant(thing, \"Expecting some object\"); if (property !== undefined) return getAdministration(getAtom(thing, property)); if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing; if (isObservableMap(thing)) return thing; runLazyInitializers(thing); if (thing.$mobx) return thing.$mobx; invariant(false, \"Cannot obtain administration from \" + thing); } function getDebugName(thing, property) { var named; if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing); return named.name; } function createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) { function classPropertyDecorator(target, key, descriptor, customArgs, argLen) { if (argLen === void 0) { argLen = 0; } invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\"); if (!descriptor) { var newDescriptor = { enumerable: enumerable, configurable: true, get: function get() { if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor); return _get.call(this, key); }, set: function set(v) { if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) { typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor); } else { _set.call(this, key, v); } } }; if (arguments.length < 3 || arguments.length === 5 && argLen < 3) { Object.defineProperty(target, key, newDescriptor); } return newDescriptor; } else { if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) { addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []); } var value_1 = descriptor.value, initializer_1 = descriptor.initializer; target.__mobxLazyInitializers.push(function (instance) { onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor); }); return { enumerable: enumerable, configurable: true, get: function get() { if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this); return _get.call(this, key); }, set: function set(v) { if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this); _set.call(this, key, v); } }; } } if (allowCustomArguments) { return function () { if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments); var outerArgs = arguments; var argLen = arguments.length; return function (target, key, descriptor) { return classPropertyDecorator(target, key, descriptor, outerArgs, argLen); }; }; } return classPropertyDecorator; } function typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) { if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {}); instance.__mobxInitializedProps[key] = true; onInitialize(instance, key, v, customArgs, baseDescriptor); } function runLazyInitializers(instance) { if (instance.__mobxDidRunLazyInitializers === true) return; if (instance.__mobxLazyInitializers) { addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true); instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) { return initializer(instance); }); } } function quacksLikeADecorator(args) { return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\"; } function iteratorSymbol() { return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\"; } var IS_ITERATING_MARKER = \"__$$iterating\"; function arrayAsIterator(array) { invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\"); addHiddenFinalProp(array, IS_ITERATING_MARKER, true); var idx = -1; addHiddenFinalProp(array, \"next\", function next() { idx++; return { done: idx >= this.length, value: idx < this.length ? this[idx] : undefined }; }); return array; } function declareIterator(prototType, iteratorFactory) { addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory); } var messages = { \"m001\": \"It is not allowed to assign new values to @action fields\", \"m002\": \"`runInAction` expects a function\", \"m003\": \"`runInAction` expects a function without arguments\", \"m004\": \"autorun expects a function\", \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\", \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\", \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\", \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\", \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\", \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\", \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\", \"m012\": \"computed takes one or two arguments if used as function\", \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\", \"m014\": \"extendObservable expected 2 or more arguments\", \"m015\": \"extendObservable expects an object as first argument\", \"m016\": \"extendObservable should not be used on maps, use map.merge instead\", \"m017\": \"all arguments of extendObservable should be objects\", \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\", \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\", \"m020\": \"modifiers can only be used for individual object properties\", \"m021\": \"observable expects zero or one arguments\", \"m022\": \"@observable can not be used on getters, use @computed instead\", \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\", \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\", \"m025\": \"whyRun can only be used on reactions and computed values\", \"m026\": \"`action` can only be invoked on functions\", \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\", \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\", \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \", \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \", \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \", \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n Didn't expect this computation to be suspended at this point?\\n 1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n 2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\", \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\", \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\", \"m035\": \"Cannot make the designated object observable; it is not extensible\", \"m036\": \"It is not possible to get index atoms from arrays\", \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\", \"m038\": \"Missing items in this list?\\n 1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n 2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\" }; function getMessage(id) { return messages[id]; } var EMPTY_ARRAY = []; Object.freeze(EMPTY_ARRAY); function getGlobal() { return global; } function getNextId() { return ++globalState.mobxGuid; } function fail(message, thing) { invariant(false, message, thing); throw \"X\"; } function invariant(check, message, thing) { if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : '')); } var deprecatedMessages = []; function deprecated(msg) { if (deprecatedMessages.indexOf(msg) !== -1) return false; deprecatedMessages.push(msg); console.error(\"[mobx] Deprecated: \" + msg); return true; } function once(func) { var invoked = false; return function () { if (invoked) return; invoked = true; return func.apply(this, arguments); }; } var noop = function noop() {}; function unique(list) { var res = []; list.forEach(function (item) { if (res.indexOf(item) === -1) res.push(item); }); return res; } function joinStrings(things, limit, separator) { if (limit === void 0) { limit = 100; } if (separator === void 0) { separator = \" - \"; } if (!things) return ''; var sliced = things.slice(0, limit); return '' + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : ''); } function isObject(value) { return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\"; } function isPlainObject(value) { if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false; var proto = Object.getPrototypeOf(value); return proto === Object.prototype || proto === null; } function objectAssign() { var res = arguments[0]; for (var i = 1, l = arguments.length; i < l; i++) { var source = arguments[i]; for (var key in source) { if (hasOwnProperty(source, key)) { res[key] = source[key]; } } } return res; } function valueDidChange(compareStructural, oldValue, newValue) { if (typeof oldValue === 'number' && isNaN(oldValue)) { return typeof newValue !== 'number' || !isNaN(newValue); } return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue; } var prototypeHasOwnProperty = Object.prototype.hasOwnProperty; function hasOwnProperty(object, propName) { return prototypeHasOwnProperty.call(object, propName); } function makeNonEnumerable(object, propNames) { for (var i = 0; i < propNames.length; i++) { addHiddenProp(object, propNames[i], object[propNames[i]]); } } function addHiddenProp(object, propName, value) { Object.defineProperty(object, propName, { enumerable: false, writable: true, configurable: true, value: value }); } function addHiddenFinalProp(object, propName, value) { Object.defineProperty(object, propName, { enumerable: false, writable: false, configurable: true, value: value }); } function isPropertyConfigurable(object, prop) { var descriptor = Object.getOwnPropertyDescriptor(object, prop); return !descriptor || descriptor.configurable !== false && descriptor.writable !== false; } function assertPropertyConfigurable(object, prop) { invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\"); } function getEnumerableKeys(obj) { var res = []; for (var key in obj) { res.push(key); }return res; } function deepEqual(a, b) { if (a === null && b === null) return true; if (a === undefined && b === undefined) return true; if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b; var aIsArray = isArrayLike(a); var aIsMap = isMapLike(a); if (aIsArray !== isArrayLike(b)) { return false; } else if (aIsMap !== isMapLike(b)) { return false; } else if (aIsArray) { if (a.length !== b.length) return false; for (var i = a.length - 1; i >= 0; i--) { if (!deepEqual(a[i], b[i])) return false; }return true; } else if (aIsMap) { if (a.size !== b.size) return false; var equals_1 = true; a.forEach(function (value, key) { equals_1 = equals_1 && deepEqual(b.get(key), value); }); return equals_1; } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") { if (a === null || b === null) return false; if (isMapLike(a) && isMapLike(b)) { if (a.size !== b.size) return false; return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries()); } if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false; for (var prop in a) { if (!(prop in b)) return false; if (!deepEqual(a[prop], b[prop])) return false; } return true; } return false; } function createInstanceofPredicate(name, clazz) { var propName = \"isMobX\" + name; clazz.prototype[propName] = true; return function (x) { return isObject(x) && x[propName] === true; }; } function isArrayLike(x) { return Array.isArray(x) || isObservableArray(x); } exports.isArrayLike = isArrayLike; function isMapLike(x) { return isES6Map(x) || isObservableMap(x); } function isES6Map(thing) { if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true; return false; } function primitiveSymbol() { return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\"; } function toPrimitive(value) { return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? '' + value : value; } /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4))) /***/ }), /* 2 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); var _icons = __webpack_require__(6); var _constants = __webpack_require__(0); function renderHeader(_ref, instance) { var meta = _ref.meta, user = _ref.user, reactions = _ref.reactions; var container = document.createElement('div'); container.lang = \"en-US\"; container.className = 'gitment-container gitment-header-container'; var likeButton = document.createElement('span'); var likedReaction = reactions.find(function (reaction) { return reaction.content === 'heart' && reaction.user.login === user.login; }); likeButton.className = 'gitment-header-like-btn'; likeButton.innerHTML = '\\n ' + _icons.heart + '\\n ' + (likedReaction ? 'Unlike' : 'Like') + '\\n ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 ' + meta.reactions.heart + ' Liked' : '') + '\\n '; if (likedReaction) { likeButton.classList.add('liked'); likeButton.onclick = function () { return instance.unlike(); }; } else { likeButton.classList.remove('liked'); likeButton.onclick = function () { return instance.like(); }; } container.appendChild(likeButton); var commentsCount = document.createElement('span'); commentsCount.innerHTML = '\\n ' + (meta.comments ? ' \\u2022 ' + meta.comments + ' Comments' : '') + '\\n '; container.appendChild(commentsCount); var issueLink = document.createElement('a'); issueLink.className = 'gitment-header-issue-link'; issueLink.href = meta.html_url; issueLink.target = '_blank'; issueLink.innerText = 'Issue Page'; container.appendChild(issueLink); return container; } function renderComments(_ref2, instance) { var meta = _ref2.meta, comments = _ref2.comments, commentReactions = _ref2.commentReactions, currentPage = _ref2.currentPage, user = _ref2.user, error = _ref2.error; var container = document.createElement('div'); container.lang = \"en-US\"; container.className = 'gitment-container gitment-comments-container'; if (error) { var errorBlock = document.createElement('div'); errorBlock.className = 'gitment-comments-error'; if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) { var initHint = document.createElement('div'); var initButton = document.createElement('button'); initButton.className = 'gitment-comments-init-btn'; initButton.onclick = function () { initButton.setAttribute('disabled', true); instance.init().catch(function (e) { initButton.removeAttribute('disabled'); alert(e); }); }; initButton.innerText = 'Initialize Comments'; initHint.appendChild(initButton); errorBlock.appendChild(initHint); } else { errorBlock.innerText = error; } container.appendChild(errorBlock); return container; } else if (comments === undefined) { var loading = document.createElement('div'); loading.innerText = 'Loading comments...'; loading.className = 'gitment-comments-loading'; container.appendChild(loading); return container; } else if (!comments.length) { var emptyBlock = document.createElement('div'); emptyBlock.className = 'gitment-comments-empty'; emptyBlock.innerText = 'No Comment Yet'; container.appendChild(emptyBlock); return container; } var commentsList = document.createElement('ul'); commentsList.className = 'gitment-comments-list'; comments.forEach(function (comment) { var createDate = new Date(comment.created_at); var updateDate = new Date(comment.updated_at); var commentItem = document.createElement('li'); commentItem.className = 'gitment-comment'; commentItem.innerHTML = '\\n \\n \\n \\n \\n \\n \\n ' + comment.user.login + '\\n \\n commented on\\n ' + createDate.toDateString() + '\\n ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 edited' : '') + '\\n ' + _icons.heart + ' ' + (comment.reactions.heart || '') + '\\n \\n ' + comment.body_html + '\\n \\n '; var likeButton = commentItem.querySelector('.gitment-comment-like-btn'); var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) { return reaction.content === 'heart' && reaction.user.login === user.login; }); if (likedReaction) { likeButton.classList.add('liked'); likeButton.onclick = function () { return instance.unlikeAComment(comment.id); }; } else { likeButton.classList.remove('liked'); likeButton.onclick = function () { return instance.likeAComment(comment.id); }; } // dirty // use a blank image to trigger height calculating when element rendered var imgTrigger = document.createElement('img'); var markdownBody = commentItem.querySelector('.gitment-comment-body'); imgTrigger.className = 'gitment-hidden'; imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"; imgTrigger.onload = function () { if (markdownBody.clientHeight > instance.maxCommentHeight) { markdownBody.classList.add('gitment-comment-body-folded'); markdownBody.style.maxHeight = instance.maxCommentHeight + 'px'; markdownBody.title = 'Click to Expand'; markdownBody.onclick = function () { markdownBody.classList.remove('gitment-comment-body-folded'); markdownBody.style.maxHeight = ''; markdownBody.title = ''; markdownBody.onclick = null; }; } }; commentItem.appendChild(imgTrigger); commentsList.appendChild(commentItem); }); container.appendChild(commentsList); if (meta) { var pageCount = Math.ceil(meta.comments / instance.perPage); if (pageCount > 1) { var pagination = document.createElement('ul'); pagination.className = 'gitment-comments-pagination'; if (currentPage > 1) { var previousButton = document.createElement('li'); previousButton.className = 'gitment-comments-page-item'; previousButton.innerText = 'Previous'; previousButton.onclick = function () { return instance.goto(currentPage - 1); }; pagination.appendChild(previousButton); } var _loop = function _loop(i) { var pageItem = document.createElement('li'); pageItem.className = 'gitment-comments-page-item'; pageItem.innerText = i; pageItem.onclick = function () { return instance.goto(i); }; if (currentPage === i) pageItem.classList.add('gitment-selected'); pagination.appendChild(pageItem); }; for (var i = 1; i \\n \\n \\n \\n \\n \\n \\n \\n \\n Styling with Markdown is supported\\n \\n 0 && arguments[0] !== undefined ? arguments[0] : window.location.search; if (!search) return {}; var queryString = search[0] === '?' ? search.substring(1) : search; var query = {}; queryString.split('&').forEach(function (queryStr) { var _queryStr$split = queryStr.split('='), _queryStr$split2 = _slicedToArray(_queryStr$split, 2), key = _queryStr$split2[0], value = _queryStr$split2[1]; if (key) query[key] = value; }); return query; }, stringify: function stringify(query) { var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?'; var queryString = Object.keys(query).map(function (key) { return key + '=' + encodeURIComponent(query[key] || ''); }).join('&'); return queryString ? prefix + queryString : ''; } }; function ajaxFactory(method) { return function (apiPath) { var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com'; var req = new XMLHttpRequest(); var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY); var url = '' + base + apiPath; var body = null; if (method === 'GET' || method === 'DELETE') { url += Query.stringify(data); } var p = new Promise(function (resolve, reject) { req.addEventListener('load', function () { var contentType = req.getResponseHeader('content-type'); var res = req.responseText; if (!/json/.test(contentType)) { resolve(res); return; } var data = req.responseText ? JSON.parse(res) : {}; if (data.message) { reject(new Error(data.message)); } else { resolve(data); } }); req.addEventListener('error', function (error) { return reject(error); }); }); req.open(method, url, true); req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json'); if (token) { req.setRequestHeader('Authorization', 'token ' + token); } if (method !== 'GET' && method !== 'DELETE') { body = JSON.stringify(data); req.setRequestHeader('Content-Type', 'application/json'); } req.send(body); return p; }; } var http = exports.http = { get: ajaxFactory('GET'), post: ajaxFactory('POST'), delete: ajaxFactory('DELETE'), put: ajaxFactory('PUT') }; /***/ }), /* 4 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; var g; // This works in non-strict mode g = function () { return this; }(); try { // This works if eval is allowed (see CSP) g = g || Function(\"return this\")() || (1, eval)(\"this\"); } catch (e) { // This works if the window reference is available if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window; } // g can still be undefined, but nothing to do about it... // We return undefined, instead of nothing here, so it's // easier to handle this case. if(!global) { ...} module.exports = g; /***/ }), /* 5 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _mobx = __webpack_require__(1); var _constants = __webpack_require__(0); var _utils = __webpack_require__(3); var _default = __webpack_require__(2); var _default2 = _interopRequireDefault(_default); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } var scope = 'public_repo'; function extendRenderer(instance, renderer) { instance[renderer] = function (container) { var targetContainer = (0, _utils.getTargetContainer)(container); var render = instance.theme[renderer] || instance.defaultTheme[renderer]; (0, _mobx.autorun)(function () { var e = render(instance.state, instance); if (targetContainer.firstChild) { targetContainer.replaceChild(e, targetContainer.firstChild); } else { targetContainer.appendChild(e); } }); return targetContainer; }; } var Gitment = function () { _createClass(Gitment, [{ key: 'accessToken', get: function get() { return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY); }, set: function set(token) { localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token); } }, { key: 'loginLink', get: function get() { var oauthUri = 'https://github.com/login/oauth/authorize'; var redirect_uri = this.oauth.redirect_uri || window.location.href; var oauthParams = Object.assign({ scope: scope, redirect_uri: redirect_uri }, this.oauth); return '' + oauthUri + _utils.Query.stringify(oauthParams); } }]); function Gitment() { var _this = this; var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, Gitment); this.defaultTheme = _default2.default; this.useTheme(_default2.default); Object.assign(this, { id: window.location.href, title: window.document.title, link: window.location.href, desc: '', labels: [], theme: _default2.default, oauth: {}, perPage: 20, maxCommentHeight: 250 }, options); this.useTheme(this.theme); var user = {}; try { var userInfo = localStorage.getItem(_constants.LS_USER_KEY); if (this.accessToken && userInfo) { Object.assign(user, JSON.parse(userInfo), { fromCache: true }); } } catch (e) { localStorage.removeItem(_constants.LS_USER_KEY); } this.state = (0, _mobx.observable)({ user: user, error: null, meta: {}, comments: undefined, reactions: [], commentReactions: {}, currentPage: 1 }); var query = _utils.Query.parse(); if (query.code) { var _oauth = this.oauth, client_id = _oauth.client_id, client_secret = _oauth.client_secret; var code = query.code; delete query.code; var search = _utils.Query.stringify(query); var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash; history.replaceState({}, '', replacedUrl); Object.assign(this, { id: replacedUrl, link: replacedUrl }, options); this.state.user.isLoggingIn = true; _utils.http.post('https://github.com/login/oauth/access_token', { code: code, client_id: client_id, client_secret: client_secret }, '').then(function (data) { _this.accessToken = data.access_token; _this.update(); }).catch(function (e) { _this.state.user.isLoggingIn = false; alert(e); }); } else { this.update(); } } _createClass(Gitment, [{ key: 'init', value: function init() { var _this2 = this; return this.createIssue().then(function () { return _this2.loadComments(); }).then(function (comments) { _this2.state.error = null; return comments; }); } }, { key: 'useTheme', value: function useTheme() { var _this3 = this; var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; this.theme = theme; var renderers = Object.keys(this.theme); renderers.forEach(function (renderer) { return extendRenderer(_this3, renderer); }); } }, { key: 'update', value: function update() { var _this4 = this; return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () { return Promise.all([_this4.loadComments().then(function () { return _this4.loadCommentReactions(); }), _this4.loadReactions()]); }).catch(function (e) { return _this4.state.error = e; }); } }, { key: 'markdown', value: function markdown(text) { return _utils.http.post('/markdown', { text: text, mode: 'gfm' }); } }, { key: 'createIssue', value: function createIssue() { var _this5 = this; var id = this.id, owner = this.owner, repo = this.repo, title = this.title, link = this.link, desc = this.desc, labels = this.labels; return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', { title: title, labels: labels.concat(['gitment', id]), body: link + '\\n\\n' + desc }).then(function (meta) { _this5.state.meta = meta; return meta; }); } }, { key: 'getIssue', value: function getIssue() { if (this.state.meta.id) return Promise.resolve(this.state.meta); return this.loadMeta(); } }, { key: 'post', value: function post(body) { var _this6 = this; return this.getIssue().then(function (issue) { return _utils.http.post(issue.comments_url, { body: body }, ''); }).then(function (data) { _this6.state.meta.comments++; var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage); if (_this6.state.currentPage === pageCount) { _this6.state.comments.push(data); } return data; }); } }, { key: 'loadMeta', value: function loadMeta() { var _this7 = this; var id = this.id, owner = this.owner, repo = this.repo; return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', { creator: owner, labels: id }).then(function (issues) { if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR); _this7.state.meta = issues[0]; return issues[0]; }); } }, { key: 'loadComments', value: function loadComments() { var _this8 = this; var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage; return this.getIssue().then(function (issue) { return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, ''); }).then(function (comments) { _this8.state.comments = comments; return comments; }); } }, { key: 'loadUserInfo', value: function loadUserInfo() { var _this9 = this; if (!this.accessToken) { this.logout(); return Promise.resolve({}); } return _utils.http.get('/user').then(function (user) { _this9.state.user = user; localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user)); return user; }); } }, { key: 'loadReactions', value: function loadReactions() { var _this10 = this; if (!this.accessToken) { this.state.reactions = []; return Promise.resolve([]); } return this.getIssue().then(function (issue) { if (!issue.reactions.total_count) return []; return _utils.http.get(issue.reactions.url, {}, ''); }).then(function (reactions) { _this10.state.reactions = reactions; return reactions; }); } }, { key: 'loadCommentReactions', value: function loadCommentReactions() { var _this11 = this; if (!this.accessToken) { this.state.commentReactions = {}; return Promise.resolve([]); } var comments = this.state.comments; var comentReactions = {}; return Promise.all(comments.map(function (comment) { if (!comment.reactions.total_count) return []; var owner = _this11.owner, repo = _this11.repo; return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {}); })).then(function (reactionsArray) { comments.forEach(function (comment, index) { comentReactions[comment.id] = reactionsArray[index]; }); _this11.state.commentReactions = comentReactions; return comentReactions; }); } }, { key: 'login', value: function login() { window.location.href = this.loginLink; } }, { key: 'logout', value: function logout() { localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY); localStorage.removeItem(_constants.LS_USER_KEY); this.state.user = {}; } }, { key: 'goto', value: function goto(page) { this.state.currentPage = page; this.state.comments = undefined; return this.loadComments(page); } }, { key: 'like', value: function like() { var _this12 = this; if (!this.accessToken) { alert('Login to Like'); return Promise.reject(); } var owner = this.owner, repo = this.repo; return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', { content: 'heart' }).then(function (reaction) { _this12.state.reactions.push(reaction); _this12.state.meta.reactions.heart++; }); } }, { key: 'unlike', value: function unlike() { var _this13 = this; if (!this.accessToken) return Promise.reject(); var _state = this.state, user = _state.user, reactions = _state.reactions; var index = reactions.findIndex(function (reaction) { return reaction.user.login === user.login; }); return _utils.http.delete('/reactions/' + reactions[index].id).then(function () { reactions.splice(index, 1); _this13.state.meta.reactions.heart--; }); } }, { key: 'likeAComment', value: function likeAComment(commentId) { var _this14 = this; if (!this.accessToken) { alert('Login to Like'); return Promise.reject(); } var owner = this.owner, repo = this.repo; var comment = this.state.comments.find(function (comment) { return comment.id === commentId; }); return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', { content: 'heart' }).then(function (reaction) { _this14.state.commentReactions[commentId].push(reaction); comment.reactions.heart++; }); } }, { key: 'unlikeAComment', value: function unlikeAComment(commentId) { if (!this.accessToken) return Promise.reject(); var reactions = this.state.commentReactions[commentId]; var comment = this.state.comments.find(function (comment) { return comment.id === commentId; }); var user = this.state.user; var index = reactions.findIndex(function (reaction) { return reaction.user.login === user.login; }); return _utils.http.delete('/reactions/' + reactions[index].id).then(function () { reactions.splice(index, 1); comment.reactions.heart--; }); } }]); return Gitment; }(); module.exports = Gitment; /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); /** * Modified from https://github.com/evil-icons/evil-icons */ var close = exports.close = ''; var github = exports.github = ''; var heart = exports.heart = ''; var spinner = exports.spinner = ''; /***/ }) /******/ ]); //# sourceMappingURL=gitment.browser.js.map"}],"posts":[{"title":"Android刘海屏、水滴屏全面屏适配方案","slug":"Android刘海屏、水滴屏全面屏适配方案","date":"2019-06-03T08:54:22.000Z","updated":"2019-06-04T08:54:33.749Z","comments":true,"path":"2019/06/03/Android刘海屏、水滴屏全面屏适配方案/","link":"","permalink":"http://smarxpan.github.io/2019/06/03/Android刘海屏、水滴屏全面屏适配方案/","excerpt":"","text":"我将适配方案整理后，封装成了一个库并上传至github，可参考使用 项目地址: https://github.com/smarxpan/NotchScreenTool 市面上的屏幕尺寸和全面屏方案五花八门。 这里我使用了小米的图来说明： 上述两种屏幕都可以统称为刘海屏，不过对于右侧较小的刘海，业界一般称为水滴屏或美人尖。为便于说明，后文提到的「刘海屏」「刘海区」都同时指代上图两种屏幕。 当我们在谈屏幕适配时，我们在谈什么 适应更长的屏幕 防止内容被刘海遮挡 其中第一点是所有应用都需要适配的，对应下文的声明最大长宽比 而第二点，如果应用本身不需要全屏显示或使用沉浸式状态栏，是不需要适配的。 针对需要适配第二点的应用，需要获取刘海的位置和宽高，然后将显示内容避开即可。 声明最大长宽比以前的普通屏长宽比为16：9，全面屏手机的屏幕长宽比增大了很多，如果不适配的话就会类似下面这样： 黑色区域为未利用的区域。 适配方式适配方式有两种： 将targetSdkVersion版本设置到API 24及以上 这个操作将会为&lt;application&gt; 标签隐式添加一个属性，android:resizeableActivity=&quot;true&quot;, 该属性的作用后面将详细说明。 在 &lt;application&gt; 标签中增加属性：android:resizeableActivity=&quot;false&quot; 同时在节点下增加一个meta-data标签： &lt;!-- Render on full screen up to screen aspect ratio of 2.4 --&gt; &lt;!-- Use a letterbox on screens larger than 2.4 --&gt; &lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.4&quot; /&gt; 原理说明这里涉及到的知识点是android:resizeableActivity属性。 在 Android 7.0（API 级别 24）或更高版本的应用，android:resizeableActivity属性默认为true（对应适配方式1）。这个属性是控制多窗口显示的，决定当前的应用或者Activity是否支持多窗口。 多窗口支持 在清单的&lt;activity&gt;或 &lt;application&gt;节点中设置该属性，启用或禁用多窗口显示： android:resizeableActivity=[&quot;true&quot; | &quot;false&quot;] 如果该属性设置为 true，Activity 将能以分屏和自由形状模式启动。 如果此属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示。 适配方式2即为设置屏幕的最大长宽比，这是官方提供的设置方式。 如果设置了最大长宽比，必须android:resizeableActivity=&quot;false&quot;。 否则最大长宽比没有任何作用。 适配刘海屏Android9.0及以上适配Android P（9.0）开始，官方提供了适配异形屏的方式。 Support display cutouts 通过全新的 DisplayCutout 类，可以确定非功能区域的位置和形状，这些区域不应显示内容。 要确定这些凹口屏幕区域是否存在及其位置，请使用 getDisplayCutout() 函数。 全新的窗口布局属性 layoutInDisplayCutoutMode 让您的应用可以为设备凹口屏幕周围的内容进行布局。 您可以将此属性设为下列值之一： LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER 默认值是LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT，刘海区域不会显示内容，需要将值设置为LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES 您可以按如下方法在任何运行 Android P 的设备或模拟器上模拟屏幕缺口： 启用开发者选项。 在 Developer options 屏幕中，向下滚动至 Drawing 部分并选择 Simulate a display with a cutout。 选择凹口屏幕的大小。 适配参考： // 延伸显示区域到刘海 WindowManager.LayoutParams lp = window.getAttributes(); lp.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; window.setAttributes(lp); // 设置页面全屏显示 final View decorView = window.getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); 其中延伸显示区域到刘海的代码，也可以通过修改Activity或应用的style实现，例如： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;xxx&quot;&gt; &lt;item name=&quot;android:windowLayoutInDisplayCutoutMode&quot;&gt;shortEdges&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; Android O 适配因Google官方的适配方案到Android P才推出，因此在Android O设备上，各家厂商有自己的实现方案。 我这里主要适配了华为、小米、oppo，这三家都给了完整的解决方案。至于vivo，vivo给了判断是否刘海屏的API，但是没用设置刘海区域显示到API，因此无需适配。 适配华为Android O设备方案一： 具体方式如下所示： &lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; 对Application生效，意味着该应用的所有页面，系统都不会做竖屏场景的特殊下移或者是横屏场景的右移特殊处理： &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:testOnly=&quot;false&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 对Activity生效，意味着可以针对单个页面进行刘海屏适配，设置了该属性的Activity系统将不会做特殊处理： &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:testOnly=&quot;false&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.LandscapeFullScreenActivity&quot; android:screenOrientation=&quot;sensor&quot;&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.FullScreenActivity&quot;&gt; &lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; &lt;/activity&gt; &lt;/application&gt; 方案二 对Application生效，意味着该应用的所有页面，系统都不会做竖屏场景的特殊下移或者是横屏场景的右移特殊处理 我的NotchScreenTool中使用的就是方案二，如果需要针对Activity，建议自行修改。 设置应用窗口在华为刘海屏手机使用刘海区 /*刘海屏全屏显示FLAG*/ public static final int FLAG_NOTCH_SUPPORT=0x00010000; /** * 设置应用窗口在华为刘海屏手机使用刘海区 * @param window 应用页面window对象 */ public static void setFullScreenWindowLayoutInDisplayCutout(Window window) { if (window == null) { return; } WindowManager.LayoutParams layoutParams = window.getAttributes(); try { Class layoutParamsExCls = Class.forName(&quot;com.huawei.android.view.LayoutParamsEx&quot;); Constructor con=layoutParamsExCls.getConstructor(LayoutParams.class); Object layoutParamsExObj=con.newInstance(layoutParams); Method method=layoutParamsExCls.getMethod(&quot;addHwFlags&quot;, int.class); method.invoke(layoutParamsExObj, FLAG_NOTCH_SUPPORT); } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |InstantiationException | InvocationTargetException e) { Log.e(&quot;test&quot;, &quot;hw add notch screen flag api error&quot;); } catch (Exception e) { Log.e(&quot;test&quot;, &quot;other Exception&quot;); } } 清除添加的华为刘海屏Flag，恢复应用不使用刘海区显示 /** * 设置应用窗口在华为刘海屏手机使用刘海区 * @param window 应用页面window对象 */ public static void setNotFullScreenWindowLayoutInDisplayCutout (Window window) { if (window == null) { return; } WindowManager.LayoutParams layoutParams = window.getAttributes(); try { Class layoutParamsExCls = Class.forName(&quot;com.huawei.android.view.LayoutParamsEx&quot;); Constructor con=layoutParamsExCls.getConstructor(LayoutParams.class); Object layoutParamsExObj=con.newInstance(layoutParams); Method method=layoutParamsExCls.getMethod(&quot;clearHwFlags&quot;, int.class); method.invoke(layoutParamsExObj, FLAG_NOTCH_SUPPORT); } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |InstantiationException | InvocationTargetException e) { Log.e(&quot;test&quot;, &quot;hw clear notch screen flag api error&quot;); } catch (Exception e) { Log.e(&quot;test&quot;, &quot;other Exception&quot;); } } 适配小米Android O设备 判断是否是刘海屏 private static boolean isNotch() { try { Method getInt = Class.forName(&quot;android.os.SystemProperties&quot;).getMethod(&quot;getInt&quot;, String.class, int.class); int notch = (int) getInt.invoke(null, &quot;ro.miui.notch&quot;, 0); return notch == 1; } catch (Throwable ignore) { } return false; } 设置显示到刘海区域 @Override public void setDisplayInNotch(Activity activity) { int flag = 0x00000100 | 0x00000200 | 0x00000400; try { Method method = Window.class.getMethod(&quot;addExtraFlags&quot;, int.class); method.invoke(activity.getWindow(), flag); } catch (Exception ignore) { } } 获取刘海宽高 public static int getNotchHeight(Context context) { int resourceId = context.getResources().getIdentifier(&quot;notch_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) { return context.getResources().getDimensionPixelSize(resourceId); } return 0; } public static int getNotchWidth(Context context) { int resourceId = context.getResources().getIdentifier(&quot;notch_width&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) { return context.getResources().getDimensionPixelSize(resourceId); } return 0; } 适配oppoAndroid O设备 判断是否是刘海屏 @Override public boolean hasNotch(Activity activity) { boolean ret = false; try { ret = activity.getPackageManager().hasSystemFeature(&quot;com.oppo.feature.screen.heteromorphism&quot;); } catch (Throwable ignore) { } return ret; } 获取刘海的左上角和右下角的坐标 /** * 获取刘海的坐标 * &lt;p&gt; * 属性形如：[ro.oppo.screen.heteromorphism]: [378,0:702,80] * &lt;p&gt; * 获取到的值为378,0:702,80 * &lt;p&gt; * &lt;p&gt; * (378,0)是刘海区域左上角的坐标 * &lt;p&gt; * (702,80)是刘海区域右下角的坐标 */ private static String getScreenValue() { String value = &quot;&quot;; Class&lt;?&gt; cls; try { cls = Class.forName(&quot;android.os.SystemProperties&quot;); Method get = cls.getMethod(&quot;get&quot;, String.class); Object object = cls.newInstance(); value = (String) get.invoke(object, &quot;ro.oppo.screen.heteromorphism&quot;); } catch (Throwable ignore) { } return value; } Oppo Android O机型不需要设置显示到刘海区域，只要设置了应用全屏就会默认显示。 因此Oppo机型必须适配。 适配总结根据上述功能，我将其整理成了一个依赖库：NotchScreenTool 使用起来很简单： // 支持显示到刘海区域 NotchScreenManager.getInstance().setDisplayInNotch(this); // 获取刘海屏信息 NotchScreenManager.getInstance().getNotchInfo(this, new INotchScreen.NotchScreenCallback() { @Override public void onResult(INotchScreen.NotchScreenInfo notchScreenInfo) { Log.i(TAG, &quot;Is this screen notch? &quot; + notchScreenInfo.hasNotch); if (notchScreenInfo.hasNotch) { for (Rect rect : notchScreenInfo.notchRects) { Log.i(TAG, &quot;notch screen Rect = &quot; + rect.toShortString()); } } } }); 获取刘海区域信息后就可以根据自己应用的需要，来避开重要的控件。 详情可参考我项目中的代码。 参考链接 声明受限屏幕支持：声明最大长宽比) Android 8.1 兼容性定义 多窗口支持 Support display cutouts 华为刘海屏手机安卓O版本适配指导 OPPO凹形屏适配说明 vivo 全面屏应用适配指南 小米刘海屏水滴屏 Android O 适配","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"Java7的try-with-resources声明","slug":"Java7的try-with-resources声明","date":"2019-05-09T06:53:10.000Z","updated":"2019-05-09T08:14:20.073Z","comments":true,"path":"2019/05/09/Java7的try-with-resources声明/","link":"","permalink":"http://smarxpan.github.io/2019/05/09/Java7的try-with-resources声明/","excerpt":"","text":"看《Effective Java》第三版的时候，看到了其中建议将try-finally替换为try-with-resources。这个语法糖还算有意思，特此成文。 用法辨析Java库中有很多资源需要手动关闭，比如InputStream、OutputStream、java.sql.Connection等等。在此之前，通常是使用try-finally的方式关闭资源；Java7之后，推出了try-with-resources声明来替代之前的方式。 try-with-resources 声明要求其中定义的变量实现 AutoCloseable 接口，这样系统可以自动调用它们的close方法，从而替代了finally中关闭资源的功能。 举个栗子，下面是一个复制文件的方法，按照原本try-catch-finally的写法： // 一个简单的复制文件方法。 public static void copy(String src, String dst) { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dst); byte[] buff = new byte[1024]; int n; while ((n = in.read(buff)) &gt;= 0) { out.write(buff, 0, n); } } catch (IOException e) { e.printStackTrace(); } finally { if (in != null) { try { in.close(); } catch (IOException e) { e.printStackTrace(); } } if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } } 可以看出，这种实现非常的丑陋。 下面来看使用了try-with-resources后的效果： public static void copy(String src, String dst) { try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst)) { byte[] buff = new byte[1024]; int n; while ((n = in.read(buff)) &gt;= 0) { out.write(buff, 0, n); } } catch (IOException e) { e.printStackTrace(); } } try-with-resources将会自动关闭try()中的资源，并且将先关闭后声明的资源。 如果不catch IOException就更加清爽了： public static void copy(String src, String dst) throws IOException { try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst)) { byte[] buff = new byte[1024]; int n; while ((n = in.read(buff)) &gt;= 0) { out.write(buff, 0, n); } } } 原理分析那么try-with-resources有什么神奇之处呢？到底做了什么呢？ 我们先来看下AutoCloseable接口： public interface AutoCloseable { void close() throws Exception; } 其中仅有一个close方法，实现AutoCloseable接口的类将在close方法中实现其关闭资源的功能。 而try-with-resources其实是个语法糖，它将在编译时编译成关闭资源的代码。我们将上述例子中的代码编译成class文件，再反编译回java文件，就能看到如下代码： public static void copy(String var0, String var1) throws IOException { FileInputStream var2 = new FileInputStream(var0); Throwable var3 = null; try { FileOutputStream var4 = new FileOutputStream(var1); Throwable var5 = null; try { byte[] var6 = new byte[1024]; int var7; while((var7 = var2.read(var6)) &gt;= 0) { var4.write(var6, 0, var7); } } catch (Throwable var29) { var5 = var29; throw var29; } finally { if (var4 != null) { if (var5 != null) { try { // 关闭FileOutputStream var4.close(); } catch (Throwable var28) { var5.addSuppressed(var28); } } else { var4.close(); } } } } catch (Throwable var31) { var3 = var31; throw var31; } finally { if (var2 != null) { if (var3 != null) { try { // 关闭FileInputStream var2.close(); } catch (Throwable var27) { var3.addSuppressed(var27); } } else { var2.close(); } } } } 除却处理异常相关的代码，其实就是调用了资源的close方法。 不过不得不说这个语法糖挺甜，真香。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://smarxpan.github.io/tags/Java/"}]},{"title":"kotlin语法之将函数作为参数","slug":"kotlin语法之将函数作为参数","date":"2019-05-06T12:24:56.000Z","updated":"2019-05-06T12:26:10.798Z","comments":true,"path":"2019/05/06/kotlin语法之将函数作为参数/","link":"","permalink":"http://smarxpan.github.io/2019/05/06/kotlin语法之将函数作为参数/","excerpt":"","text":"一个setOnClickListener的错误写了个demo，点击事件离奇的不生效。 开始实在是看不出有什么问题，错误代码如下： findViewById&lt;Button&gt;(R.id.btn).setOnClickListener { View.OnClickListener { ... } } 运行不报错，就是不触发OnClickListener中的代码。 那么正确的写法应该是怎样呢？ 如下所示： // 写法1：OnClickListener写法 findViewById&lt;Button&gt;(R.id.btn).setOnClickListener( View.OnClickListener { ... } ) 或者这样： // 写法2：闭包写法 findViewById&lt;Button&gt;(R.id.btn).setOnClickListener { ... } 为什么那个错误的写法不报错但是却不能正确运行呢？ 因为错误的写法实际上是在写法2的闭包里面又声明了一个OnClickListener，仅仅声明listener当然不能调用里面的代码了。 将函数作为参数传递为什么setOnClickListener有两种写法呢？ 实际上这里setOnClickListener这个方法有两个重载： // 参数是OnClickListener对象 fun setOnClickListener(l: View.OnClickListener?) // 参数是闭包 fun setOnClickListener(l: (v: View) -&gt; Unit) 因为有两个重载方法，setOnClickListener才可以有两种写法。 所谓闭包： 在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 kotlin中的闭包一般称为lambda表达式，详细内容可以查看： 高阶函数与 lambda 表达式 我们这里只看将函数作为参数传递的用法。 因为闭包这一特性的存在，上面setOnClickListener才可以不使用传统的OnClickListener， 下面我们自己定义一个简单的例子来说明。 传统写法： // 声明listener interface TestListener { fun test() } // 声明使用listener作为参数的方法 private fun setListener(listener: TestListener) { // 调用listener的test方法 listener.test() } // 方法中使用 fun main(){ setListener(object : TestListener { override fun test() { Log.i(&quot;test_tag&quot;, &quot;test Listener&quot;) } }) } 闭包写法： // 声明方法 private fun setListener(listener: () -&gt; Unit) { // 调用传入的方法 listener() } // 方法中使用 fun main(){ setListener { Log.i(&quot;test_tag&quot;, &quot;test unit&quot;) } } 明显简化了许多，再也不需要通过声明接口设置监听了。 需要额外说明将函数作为参数传递使用的几种变种： 带参数的闭包： // 带参数 private fun setListener(l: (c: Context) -&gt; Unit) { l(applicationContext) } // 使用，只有一个参数时，可以用it代替传入的参数 setListener { Toast.makeText(it, &quot;test param&quot;, Toast.LENGTH_SHORT).show() } 带参数且有返回值： private fun setListener(l: (c: Context) -&gt; Boolean) { val b = l(applicationContext) Toast.makeText(applicationContext, if (b) &quot;当前时间是偶数&quot; else &quot;当前时间是奇数&quot;, Toast.LENGTH_SHORT).show() } // 使用，只有一个参数时，可以用it代替传入的参数 setListener { Toast.makeText(it, &quot;test param&quot;, Toast.LENGTH_SHORT).show() // 当前时间是否是偶数 System.currentTimeMillis() % 2 == 0L }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"Android源码解析之MethodAndArgsCaller","slug":"Android源码解析之MethodAndArgsCaller","date":"2019-04-30T02:58:11.000Z","updated":"2019-05-06T12:25:50.329Z","comments":true,"path":"2019/04/30/Android源码解析之MethodAndArgsCaller/","link":"","permalink":"http://smarxpan.github.io/2019/04/30/Android源码解析之MethodAndArgsCaller/","excerpt":"","text":"Android源码解析之MethodAndArgsCaller如果你看过ZygoteInit.java的main方法可能会对这个类不陌生，在Android8.1之前，其main方法都是类似以下这样： 以下代码基于Android8.0 public static void main(String argv[]) { ZygoteServer zygoteServer = new ZygoteServer(); // Mark zygote start. This ensures that thread creation will throw // an error. ZygoteHooks.startZygoteNoThreadCreation(); try { ... // 创建server端的socket，name为&quot;zygote&quot; zygoteServer.registerServerSocket(socketName); ... if (startSystemServer) { // 启动SystemServer进程 startSystemServer(abiList, socketName, zygoteServer); } Log.i(TAG, &quot;Accepting command socket connections&quot;); // 等待AMS请求 zygoteServer.runSelectLoop(abiList); zygoteServer.closeServerSocket(); } catch (Zygote.MethodAndArgsCaller caller) { // 运行MethodAndArgsCaller的run方法 caller.run(); } catch (Throwable ex) { Log.e(TAG, &quot;System zygote died with exception&quot;, ex); zygoteServer.closeServerSocket(); throw ex; } } 其中比较让人疑惑的地方是caller.run();这句，为何一个Exception需要运行？ 我们先看下MethodAndArgsCaller这个类的源码： /** * Helper exception class which holds a method and arguments and * can call them. This is used as part of a trampoline to get rid of * the initial process setup stack frames. */ public static class MethodAndArgsCaller extends Exception implements Runnable { /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) { mMethod = method; mArgs = args; } public void run() { try { mMethod.invoke(null, new Object[] { mArgs }); } catch (IllegalAccessException ex) { throw new RuntimeException(ex); } catch (InvocationTargetException ex) { Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) { throw (RuntimeException) cause; } else if (cause instanceof Error) { throw (Error) cause; } throw new RuntimeException(ex); } } } 这个类的功能比较单一，可以看出这个类是协助反射调用的，调用了其run方法将通过反射调用传入的方法。 这个类继承了Exception类，我们看抛出这个异常的地方（RuntimeInit类中）： private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws Zygote.MethodAndArgsCaller { Class&lt;?&gt; cl; try { // 根据类名查找类 cl = Class.forName(className, true, classLoader); } catch (ClassNotFoundException ex) { throw new RuntimeException( &quot;Missing class when invoking static main &quot; + className, ex); } Method m; try { // 找到该类的main方法 m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class }); } catch (NoSuchMethodException ex) { throw new RuntimeException( &quot;Missing static main on &quot; + className, ex); } catch (SecurityException ex) { throw new RuntimeException( &quot;Problem getting static main on &quot; + className, ex); } int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) { throw new RuntimeException( &quot;Main method is not public and static on &quot; + className); } /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception&apos;s run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new Zygote.MethodAndArgsCaller(m, argv); } 到这个方法就可以看出，最终找到某个类的main方法和方法需要的参数，将其传入MethodAndArgsCaller这个Exception中，并在catch了这个Exception的地方调用。 那么为什么要使用这种奇技淫巧调用，而不直接调用某个类呢？ 其实这个注释已经解释了： /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception&apos;s run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new Zygote.MethodAndArgsCaller(m, argv); 通过抛异常然后调用Exception的run方法的方式，可以清除调用过程的堆栈信息。 解释一下，就是这样做之后，调用的堆栈信息会是类似这样： ... at com.android.server.SystemServer.main(SystemServer.java:175) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:738) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:628) 我们看到上面异常信息中只有SystemServer.main、MethodAndArgsCaller.run、ZygoteInit.main，而没有中间的调用过程。这样使得每个被ZygoteInit启动的类看起来都像是直接被启动了，而看不到启动前的设置过程，看起来比较清爽。 额外的收获我下载的源码是Android9.0，发现MethodAndArgsCaller方法已经不再继承Exception类了，而是仅实现了Runnable接口，同时ZygoteInit类的main方法也不再通过catch Exception的方法运行。 我就很奇怪，难道不再需要清除堆栈信息了吗？ 我按照Android9.0的代码实现了一遍上述的调用过程，代码如下： Main2.java import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; public class Main2 { public static void main(String[] args) { new Main2().b().run(); } private Runnable b(){ return a(); } private Runnable a() { return findStaticMain(&quot;method_invoke.ClassTwo&quot;, new String[]{&quot;111111&quot;}, this.getClass().getClassLoader()); } /** * Invokes a static &quot;main(argv[]) method on class &quot;className&quot;. * Converts various failing exceptions into RuntimeExceptions, with * the assumption that they will then cause the VM instance to exit. * * @param className Fully-qualified class name * @param argv Argument vector for main() * @param classLoader the classLoader to load {@className} with */ protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) { Class&lt;?&gt; cl; try { cl = Class.forName(className, true, classLoader); } catch (ClassNotFoundException ex) { throw new RuntimeException( &quot;Missing class when invoking static main &quot; + className, ex); } Method m; try { m = cl.getMethod(&quot;main&quot;, new Class[]{String[].class}); } catch (NoSuchMethodException ex) { throw new RuntimeException( &quot;Missing static main on &quot; + className, ex); } catch (SecurityException ex) { throw new RuntimeException( &quot;Problem getting static main on &quot; + className, ex); } int modifiers = m.getModifiers(); if (!(Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) { throw new RuntimeException( &quot;Main method is not public and static on &quot; + className); } /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception&apos;s run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ return new MethodAndArgsCaller(m, argv); } /** * Helper class which holds a method and arguments and can call them. This is used as part of * a trampoline to get rid of the initial process setup stack frames. */ static class MethodAndArgsCaller implements Runnable { /** * method to call */ private final Method mMethod; /** * argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) { mMethod = method; mArgs = args; } public void run() { try { mMethod.invoke(null, new Object[]{mArgs}); } catch (IllegalAccessException ex) { throw new RuntimeException(ex); } catch (InvocationTargetException ex) { Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) { throw (RuntimeException) cause; } else if (cause instanceof Error) { throw (Error) cause; } throw new RuntimeException(ex); } } } } ClassTwo.java public class ClassTwo { public static void main(String[] args) { System.out.println(args[0]); try { // 制造除0异常 System.out.println(1/0); } catch (InterruptedException e) { // 输出堆栈信息 e.printStackTrace(); } } } 发现其调用链信息同样是被清除了的： Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero at method_invoke.ClassTwo.main(ClassTwo.java:9) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at method_invoke.Main2$MethodAndArgsCaller.run(Main2.java:93) at method_invoke.Main2.main(Main2.java:10) 这没有用什么奇技淫巧，也没有额外的堆栈信息，Android哪个catch Exception的操作在搞什么？ 我这时以为是Runnable接口有什么魔力，然后自己写了个接口，让MethodAndArgsCaller继承，结果没有什么两样。 也就是说，将所需要的结果封装成一个对象，最终返回到main方法，main方法中调用就可以了–并不会有中间设置对象的堆栈信息被保留。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"GraphQL学习：Github GraphQL API v4初探","slug":"Github GraphQL API v4初探","date":"2018-12-20T12:58:11.000Z","updated":"2018-12-20T13:05:23.239Z","comments":true,"path":"2018/12/20/Github GraphQL API v4初探/","link":"","permalink":"http://smarxpan.github.io/2018/12/20/Github GraphQL API v4初探/","excerpt":"","text":"查看GithubAPI的时候，发现github API升级成了V4，并且叫GraphQL API v4。不禁大吃一惊，这是个什么东东。 什么是GraphQLGraphQL（Graph Query Language）：GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。 GraphQL是一门语言，专门用于API查询。可以类比到SQL，这种类型的语言学名叫DSL（domain-specific language），译作领域专用语言 为什么Github选用GraphQL呢？因为GraphQL具有以下好处： 更大的灵活性 精确定义所需数据的能力（GraphQL拥有强类型） 仅仅会返回你需要的数据（避免数据冗余） GraphQL允许您通过一次调用替换多个REST请求以获取指定的数据 放一张来自图说明下工作过程： 看起来与原本的REST API没什么两样。 是的，大致的工作流程就是如此，不过GraphQL作为一门语言，其中有许多的概念和语法。但是我不想纯粹做官方文档的copyer，而是作为官方文档的一个导学，具体的概念和语法可以去 GraphQL中文网学习。 相信你也不爱一下子看到超多陌生概念，我们还行边用边学吧 初探github提供了GraphQL Explorer来辅助GraphQL学习 一个小小案例打开GraphQL Explorer这里我们先来运行下面的代码： query { viewer { login } } 这段代码可以查询你github的用户名，注意，请先登录。 我运行的结果： { &quot;data&quot;: { &quot;viewer&quot;: { &quot;login&quot;: &quot;smarxpan&quot; } } } 这里你可能会产生疑惑，为什么接口可以这样请求，到底发生了什么魔法？ 打开抓包软件，我们来抓个包看看。 上面的请求，实际上发送的内容仍旧是个json： { &quot;query&quot;: &quot;query { \\n viewer { \\n login\\n }\\n}&quot;, &quot;variables&quot;: {} } 这里没有什么魔法，我们看到那段代码的内容作为query参数的值发送给了服务端，服务端按照语法对其进行解析，然后返回给我们需要的值。 小小案例的具体解释query { viewer { login } } 这一小段的第一句：query GraphQL中有两种操作：query和mutation。query代表查询，mutation是变更。查询就是请求数据，而变更，对应REST API的POST/PATCH/DELETE。 这两种操作使用的请求方式均为post，get请求在GraphQL不常用。 query的结构类似： query { JSON objects to return } 其内部定义的是要返回数据的json结构。 学习和使用指引最佳的示例当然是《Github GraphQL Guides》，其中有示例、可运行，里面的每段代码都可点击到explorer里运行。 语法学习还是推荐GraphQL中文网：《GraphQL 入门》 还有一篇博客我觉得特别棒，是Leetcode工作的一位大神的《阻碍你使用 GraphQL 的十个问题》 而真正使用到工作中，当然少不了库的使用 GraphQL服务端库 GraphQL客户端库 目前主流的开发语言均有具体实现，取决于你使用的是哪一种语言，选择自己的开发库用起来。 结语新技术无疑是让人兴奋的，GraphQL确实解决了不少痛点，如果项目没什么历史包袱可以搞一搞。Github作为世界上最大的同性交友网站，其在API上使用该语言相信会带动业界的进步，学就完了。","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://smarxpan.github.io/tags/编程/"}]},{"title":"理解Python协程(Coroutine)","slug":"理解Python协程","date":"2018-12-13T07:15:30.000Z","updated":"2018-12-18T01:53:39.810Z","comments":true,"path":"2018/12/13/理解Python协程/","link":"","permalink":"http://smarxpan.github.io/2018/12/13/理解Python协程/","excerpt":"","text":"理解Python的协程(Coroutine) 生成器(Generator) yield表达式的使用 生产者和消费者模型 yield from表达式 协程(Coroutine) @asyncio.coroutine async/await 总结 参考链接 由于GIL的存在，导致Python多线程性能甚至比单线程更糟。 GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。[1]即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。 于是出现了协程（Coroutine）这么个东西。 协程: 协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行. 协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。对于IO密集型任务非常适用，如果是cpu密集型，推荐多进程+协程的方式。 在Python3.4之前，官方没有对协程的支持，存在一些三方库的实现，比如gevent和Tornado。3.4之后就内置了asyncio标准库，官方真正实现了协程这一特性。 而Python对协程的支持，是通过Generator实现的，协程是遵循某些规则的生成器。因此，我们在了解协程之前，我们先要学习生成器。 生成器(Generator)我们这里主要讨论yield和yield from这两个表达式，这两个表达式和协程的实现息息相关。 Python2.5中引入yield表达式，参见PEP342 Python3.3中增加yield from语法，参见PEP380， 方法中包含yield表达式后，Python会将其视作generator对象，不再是普通的方法。 yield表达式的使用我们先来看该表达式的具体使用： def test(): print(&quot;generator start&quot;) n = 1 while True: yield_expression_value = yield n print(&quot;yield_expression_value = %d&quot; % yield_expression_value) n += 1 # ①创建generator对象 generator = test() print(type(generator)) print(&quot;\\n---------------\\n&quot;) # ②启动generator next_result = generator.__next__() print(&quot;next_result = %d&quot; % next_result) print(&quot;\\n---------------\\n&quot;) # ③发送值给yield表达式 send_result = generator.send(666) print(&quot;send_result = %d&quot; % send_result) 执行结果： &lt;class &apos;generator&apos;&gt; --------------- generator start next_result = 1 --------------- yield_expression_value = 666 send_result = 2 方法说明： __next__()方法: 作用是启动或者恢复generator的执行，相当于send(None) send(value)方法：作用是发送值给yield表达式。启动generator则是调用send(None) 执行结果的说明： ①创建generator对象：包含yield表达式的函数将不再是一个函数，调用之后将会返回generator对象 ②启动generator：使用生成器之前需要先调用__next__或者send(None)，否则将报错。启动generator后，代码将执行到yield出现的位置，也就是执行到yield n，然后将n传递到generator.__next__()这行的返回值。（注意，生成器执行到yield n后将暂停在这里，直到下一次生成器被启动） ③发送值给yield表达式：调用send方法可以发送值给yield表达式，同时恢复生成器的执行。生成器从上次中断的位置继续向下执行，然后遇到下一个yield，生成器再次暂停，切换到主函数打印出send_result。 理解这个demo的关键是：生成器启动或恢复执行一次，将会在yield处暂停。上面的第②步仅仅执行到了yield n，并没有执行到赋值语句，到了第③步，生成器恢复执行才给yield_expression_value赋值。 生产者和消费者模型上面的例子中，代码中断–&gt;切换执行，体现出了协程的部分特点。 我们再举一个生产者、消费者的例子，这个例子来自廖雪峰的Python教程： 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。 现在改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。 def consumer(): print(&quot;[CONSUMER] start&quot;) r = &apos;start&apos; while True: n = yield r if not n: print(&quot;n is empty&quot;) continue print(&quot;[CONSUMER] Consumer is consuming %s&quot; % n) r = &quot;200 ok&quot; def producer(c): # 启动generator start_value = c.send(None) print(start_value) n = 0 while n &lt; 3: n += 1 print(&quot;[PRODUCER] Producer is producing %d&quot; % n) r = c.send(n) print(&apos;[PRODUCER] Consumer return: %s&apos; % r) # 关闭generator c.close() # 创建生成器 c = consumer() # 传入generator producer(c) 执行结果： [CONSUMER] start start [PRODUCER] producer is producing 1 [CONSUMER] consumer is consuming 1 [PRODUCER] Consumer return: 200 ok [PRODUCER] producer is producing 2 [CONSUMER] consumer is consuming 2 [PRODUCER] Consumer return: 200 ok [PRODUCER] producer is producing 3 [CONSUMER] consumer is consuming 3 [PRODUCER] Consumer return: 200 ok 注意到consumer函数是一个generator，把一个consumer传入produce后： 首先调用c.send(None)启动生成器； 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； consumer通过yield拿到消息，处理，又通过yield把结果传回； produce拿到consumer处理的结果，继续生产下一条消息； produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 yield from表达式Python3.3版本新增yield from语法，新语法用于将一个生成器部分操作委托给另一个生成器。此外，允许子生成器（即yield from后的“参数”）返回一个值，该值可供委派生成器（即包含yield from的生成器）使用。并且在委派生成器中，可对子生成器进行优化。 我们先来看最简单的应用，例如： # 子生成器 def test(n): i = 0 while i &lt; n: yield i i += 1 # 委派生成器 def test_yield_from(n): print(&quot;test_yield_from start&quot;) yield from test(n) print(&quot;test_yield_from end&quot;) for i in test_yield_from(3): print(i) 输出： test_yield_from start 0 1 2 test_yield_from end 这里我们仅仅给这个生成器添加了一些打印，如果是正式的代码中，你可以添加正常的执行逻辑。 如果上面的test_yield_from函数中有两个yield from语句，将串行执行。比如将上面的test_yield_from函数改写成这样： def test_yield_from(n): print(&quot;test_yield_from start&quot;) yield from test(n) print(&quot;test_yield_from doing&quot;) yield from test(n) print(&quot;test_yield_from end&quot;) 将输出： test_yield_from start 0 1 2 test_yield_from doing 0 1 2 test_yield_from end 在这里，yield from起到的作用相当于下面写法的简写形式 for item in test(n): yield item 看起来这个yield from也没做什么大不了的事，其实它还帮我们处理了异常之类的。具体可以看stackoverflow上的这个问题：In practice, what are the main uses for the new “yield from” syntax in Python 3.3? 协程(Coroutine) Python3.4开始，新增了asyncio相关的API，语法使用`@asyncio.coroutine和yield from`实现协程 Python3.5中引入async/await语法，参见PEP492 我们先来看Python3.4的实现。 `@asyncio.coroutine`Python3.4中，使用`@asyncio.coroutine`装饰的函数称为协程。不过没有从语法层面进行严格约束。 对装饰器不了解的小伙伴可以看我的上一篇博客–《理解Python装饰器》 对于Python原生支持的协程来说，Python对协程和生成器做了一些区分，便于消除这两个不同但相关的概念的歧义： 标记了`@asyncio.coroutine装饰器的函数称为协程函数，iscoroutinefunction()`方法返回True 调用协程函数返回的对象称为协程对象，iscoroutine()函数返回True 举个栗子，我们给上面yield from的demo中添加`@asyncio.coroutine`： import asyncio ... @asyncio.coroutine def test_yield_from(n): ... # 是否是协程函数 print(asyncio.iscoroutinefunction(test_yield_from)) # 是否是协程对象 print(asyncio.iscoroutine(test_yield_from(3))) 毫无疑问输出结果是True。 可以看下`@asyncio.coroutine`的源码中查看其做了什么，我将其源码简化下，大致如下： import functools import types import inspect def coroutine(func): # 判断是否是生成器 if inspect.isgeneratorfunction(func): coro = func else: # 将普通函数变成generator @functools.wraps(func) def coro(*args, **kw): res = func(*args, **kw) res = yield from res return res # 将generator转换成coroutine wrapper = types.coroutine(coro) # For iscoroutinefunction(). wrapper._is_coroutine = True return wrapper 将这个装饰器标记在一个生成器上，就会将其转换成coroutine。 然后，我们来实际使用下`@asyncio.coroutine和yield from`： import asyncio @asyncio.coroutine def compute(x, y): print(&quot;Compute %s + %s ...&quot; % (x, y)) yield from asyncio.sleep(1.0) return x + y @asyncio.coroutine def print_sum(x, y): result = yield from compute(x, y) print(&quot;%s + %s = %s&quot; % (x, y, result)) loop = asyncio.get_event_loop() print(&quot;start&quot;) # 中断调用，直到协程执行结束 loop.run_until_complete(print_sum(1, 2)) print(&quot;end&quot;) loop.close() 执行结果： start Compute 1 + 2 ... 1 + 2 = 3 end print_sum这个协程中调用了子协程compute，它将等待compute执行结束才返回结果。 这个demo点调用流程如下图： tulip_coro.png EventLoop将会把print_sum封装成Task对象 流程图展示了这个demo的控制流程，不过没有展示其全部细节。比如其中“暂停”的1s，实际上创建了一个future对象, 然后通过BaseEventLoop.call_later()在1s后唤醒这个任务。 值得注意的是，`@asyncio.coroutine`将在Python3.10版本中移除。 async/awaitPython3.5开始引入async/await语法（PEP 492），用来简化协程的使用并且便于理解。 async/await实际上只是`@asyncio.coroutine和yield from`的语法糖： 把`@asyncio.coroutine替换为async` 把yield from替换为await 即可。 比如上面的例子： import asyncio async def compute(x, y): print(&quot;Compute %s + %s ...&quot; % (x, y)) await asyncio.sleep(1.0) return x + y async def print_sum(x, y): result = await compute(x, y) print(&quot;%s + %s = %s&quot; % (x, y, result)) loop = asyncio.get_event_loop() print(&quot;start&quot;) loop.run_until_complete(print_sum(1, 2)) print(&quot;end&quot;) loop.close() 我们再来看一个asyncio中Future的例子： import asyncio future = asyncio.Future() async def coro1(): print(&quot;wait 1 second&quot;) await asyncio.sleep(1) print(&quot;set_result&quot;) future.set_result(&apos;data&apos;) async def coro2(): result = await future print(result) loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait([ coro1() coro2() ])) loop.close() 输出结果： wait 1 second (大约等待1秒) set_result data 这里await后面跟随的future对象，协程中yield from或者await后面可以调用future对象，其作用是：暂停协程，直到future执行结束或者返回result或抛出异常。 而在我们的例子中，await future必须要等待future.set_result(&#39;data&#39;)后才能够结束。将coro2()作为第二个协程可能体现得不够明显，可以将协程的调用改成这样： loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait([ # coro1(), coro2(), coro1() ])) loop.close() 输出的结果仍旧与上面相同。 其实，async这个关键字的用法不止能用在函数上，还有async with异步上下文管理器，async for异步迭代器. 对这些感兴趣且觉得有用的可以网上找找资料，这里限于篇幅就不过多展开了。 总结本文就生成器和协程做了一些学习、探究和总结，不过并没有做过多深入深入的研究。权且作为入门到一个笔记，之后将会尝试自己实现一下异步API，希望有助于理解学习。 参考链接 Python协程 https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/ http://www.dabeaz.com/coroutines/Coroutines.pdf Coroutines How the heck does async/await work in Python 3.5 Python3.4协程文档 Python3.5协程文档 廖雪峰的Python教程–协程","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://smarxpan.github.io/tags/Python/"}]},{"title":"理解Python装饰器(Decorator)","slug":"理解Python装饰器","date":"2018-12-05T07:15:30.000Z","updated":"2018-12-17T11:14:00.993Z","comments":true,"path":"2018/12/05/理解Python装饰器/","link":"","permalink":"http://smarxpan.github.io/2018/12/05/理解Python装饰器/","excerpt":"","text":"理解Python装饰器(Decorator)Python装饰器看起来类似Java中的注解，然鹅和注解并不相同，不过同样能够实现面向切面编程。 想要理解Python中的装饰器，不得不先理解闭包（closure）这一概念。 看看维基百科中的解释： 在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 官方的解释总是不说人话，but–talk is cheap，show me the code: # print_msg是外围函数 def print_msg(): msg = &quot;I&apos;m closure&quot; # printer是嵌套函数 def printer(): print(msg) return printer # 这里获得的就是一个闭包 closure = print_msg() # 输出 I&apos;m closure closure() msg是一个局部变量，在print_msg函数执行之后应该就不会存在了。但是嵌套函数引用了这个变量，将这个局部变量封闭在了嵌套函数中，这样就形成了一个闭包。 结合这个例子再看维基百科的解释，就清晰明了多了。闭包就是引用了自有变量的函数，这个函数保存了执行的上下文，可以脱离原本的作用域独立存在。 下面来看看Python中的装饰器。 装饰器一个普通的装饰器一般是这样： import functools def log(func): @functools.wraps(func) def wrapper(*args, **kwargs): print(&apos;call %s():&apos; % func.__name__) print(&apos;args = {}&apos;.format(*args)) return func(*args, **kwargs) return wrapper 这样就定义了一个打印出方法名及其参数的装饰器。 调用之： @log def test(p): print(test.__name__ + &quot; param: &quot; + p) test(&quot;I&apos;m a param&quot;) 输出： call test(): args = I&apos;m a param test param: I&apos;m a param 装饰器在使用时，用了@语法，让人有些困扰。其实，装饰器只是个方法，与下面的调用方式没有区别： def test(p): print(test.__name__ + &quot; param: &quot; + p) wrapper = log(test) wrapper(&quot;I&apos;m a param&quot;) @语法只是将函数传入装饰器函数，并无神奇之处。 值得注意的是`@functools.wraps(func)，这是python提供的装饰器。它能把原函数的元信息拷贝到装饰器里面的 func 函数中。函数的元信息包括docstring、__name__、参数列表等等。可以尝试去除@functools.wraps(func)，你会发现test.name`的输出变成了wrapper。 带参数的装饰器装饰器允许传入参数，一个携带了参数的装饰器将有三层函数，如下所示： import functools def log_with_param(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): print(&apos;call %s():&apos; % func.__name__) print(&apos;args = {}&apos;.format(*args)) print(&apos;log_param = {}&apos;.format(text)) return func(*args, **kwargs) return wrapper return decorator @log_with_param(&quot;param&quot;) def test_with_param(p): print(test_with_param.__name__) 看到这个代码是不是又有些疑问，内层的decorator函数的参数func是怎么传进去的？和上面一般的装饰器不大一样啊。 其实道理是一样的，将其@语法去除，恢复函数调用的形式一看就明白了： # 传入装饰器的参数，并接收返回的decorator函数 decorator = log_with_param(&quot;param&quot;) # 传入test_with_param函数 wrapper = decorator(test_with_param) # 调用装饰器函数 wrapper(&quot;I&apos;m a param&quot;) 输出结果与正常使用装饰器相同： call test_with_param(): args = I&apos;m a param log_param = param test_with_param 至此，装饰器这个有点费解的特性也没什么神秘了。 装饰器这一语法体现了Python中函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，非常的灵活与强大。 Python中引入了很多函数式编程的特性，需要好好学习与体会。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://smarxpan.github.io/tags/Python/"}]},{"title":"理解Python中的元类(metaclass)","slug":"理解Python中的元类(metaclass)","date":"2018-11-30T07:15:30.000Z","updated":"2018-12-14T13:01:20.889Z","comments":true,"path":"2018/11/30/理解Python中的元类(metaclass)/","link":"","permalink":"http://smarxpan.github.io/2018/11/30/理解Python中的元类(metaclass)/","excerpt":"","text":"理解Python中的元类(metaclass)这篇文章基本上是What are metaclasses in Python?最高赞答案的翻译，同时我简化了一点东西，加了点自己的demo。可以直接去看原文。 类也是对象在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立： &gt;&gt;&gt; class ObjectCreator(object): ... pass ... &gt;&gt;&gt; my_object = ObjectCreator() &gt;&gt;&gt; print(my_object) &lt;__main__.ObjectCreator object at 0x8974f2c&gt; 但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象. 下面这段代码： class ObjectCreator(object): pass 将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是你可以对它做如下的操作： 你可以将它赋值给一个变量 你可以拷贝它 你可以为它增加属性 你可以将它作为函数参数进行传递 下面是示例： &gt;&gt;&gt; print ObjectCreator # 你可以打印一个类，因为它其实也是一个对象 &lt;class &apos;__main__.ObjectCreator&apos;&gt; &gt;&gt;&gt; def echo(o): … print o … &gt;&gt;&gt; echo(ObjectCreator) # 你可以将类做为参数传给函数 &lt;class &apos;__main__.ObjectCreator&apos;&gt; &gt;&gt;&gt; print hasattr(ObjectCreator, &apos;new_attribute&apos;) Fasle &gt;&gt;&gt; ObjectCreator.new_attribute = &apos;foo&apos; # 你可以为类增加属性 &gt;&gt;&gt; print hasattr(ObjectCreator, &apos;new_attribute&apos;) True &gt;&gt;&gt; print ObjectCreator.new_attribute foo &gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量 &gt;&gt;&gt; print ObjectCreatorMirror() &lt;__main__.ObjectCreator object at 0x8997b4c&gt; 动态地创建类因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可 &gt;&gt;&gt; def choose_class(name): … if name == &apos;foo&apos;: … class Foo(object): … pass … return Foo # 返回的是类，不是类的实例 … else: … class Bar(object): … pass … return Bar … &gt;&gt;&gt; MyClass = choose_class(&apos;foo&apos;) &gt;&gt;&gt; print MyClass # 函数返回的是类，不是类的实例 &lt;class &apos;__main__&apos;.Foo&gt; &gt;&gt;&gt; print MyClass() # 你可以通过这个类创建类实例，也就是对象 &lt;__main__.Foo object at 0x89c6d4c&gt; 但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。 type能动态的创建类，type可以接受一个类的描述作为参数，然后返回一个类。 type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）) 比如下面的代码： &gt;&gt;&gt; MyShinyClass = type(&apos;MyShinyClass&apos;, (), {}) # 返回一个类对象 &gt;&gt;&gt; print MyShinyClass &lt;class &apos;__main__.MyShinyClass&apos;&gt; &gt;&gt;&gt; print MyShinyClass() # 创建一个该类的实例 &lt;__main__.MyShinyClass object at 0x8997cec&gt; type 接受一个字典来为类定义属性，因此： &gt;&gt;&gt; class Foo(object): … bar = True 等同于： Foo = type(&apos;Foo&apos;, (), {&apos;bar&apos;:True}) 在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。 元类元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”。type就是Python的内建元类，当然了，你也可以创建自己的元类。 元类本身而言，它们其实是很简单的： 1) 拦截类的创建 2) 修改类 3) 返回修改之后的类 自定义元类元类的主要目的就是为了当创建类时能够自动地改变类。 Python 3中创建元类的语法: class NothingMetaclass(type): def __new__(mcs, name, bases, namespace): # 什么都没做，你可以在这里做点什么 return type.__new__(mcs, name, bases, namespace) class Foo(object, metaclass=NothingMetaclass): pass demo1 new是一个静态方法,而init是一个实例方法. new方法会返回一个创建的实例,而init什么都不返回. 只有在new返回一个cls的实例时后面的init才能被调用. 当创建一个新实例时调用new,初始化一个实例时用init. 看一个例子 # 请记住，&apos;type&apos;实际上是一个类，就像&apos;str&apos;和&apos;int&apos;一样 # 所以，你可以从type继承 class MetaA(type): # __new__ 是在__init__之前被调用的特殊方法 # __new__是用来创建对象并返回之的方法 # 而__init__只是用来将传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__(cls, name, bases, dct): print(&apos;MetaA.__new__&apos;) # 这种方式不会调用__init__方法 # return type(name, bases, dct) # 这种方式会调用__init__ return type.__new__(cls, name, bases, dct) def __init__(cls, name, bases, dct): print(&apos;MetaA.__init__&apos;) class A(object, metaclass=MetaA): pass print(A()) demo2class ListMetaclass(type): # 元类会自动将你通常传给‘type’的参数作为自己的参数传入 # mcs表示元类 # name表示创建类的类名（在这里创建类就是继承Model类的子类User） # bases表示创建类继承的所有父类 # namespace表示创建类的所有属性和方法（以键值对的字典的形式） def __new__(mcs, name, bases, namespace): namespace[&apos;add&apos;] = lambda self, value: self.append(value) return type.__new__(mcs, name, bases, namespace) # 通过metaclass，给该类动态添加了add方法 class MyList(list, metaclass=ListMetaclass): pass l = MyList() l.add(1) print(l) 究竟为什么要使用元类？现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它： “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters 元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义 class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() 然后可以通过简单点API操作数据库。其背后的魔法就是定义了元类，并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。 一个简单的orm democlass Field: def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return &apos;&lt;%s:%s&gt;&apos; % (self.__class__.__name__, self.name) class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, &apos;varchar(100)&apos;) class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, &apos;bigint&apos;) class ModelMetaclass(type): def __new__(mcs, name, bases, attrs): if name == &apos;Model&apos;: return type.__new__(mcs, name, bases, attrs) print(&quot;Found Model: %s&quot; % name) mapping = dict() fields = list() # 将属性保存到mapping中 for k, v in attrs.items(): if isinstance(v, Field): print(&apos;Found mapping : %s ==&gt; %s&apos; % (k, v)) mapping[k] = v fields.append(k) # 将Model中的Field删除 for k in mapping.keys(): attrs.pop(k) attrs[&apos;__fields__&apos;] = list(map(lambda f: &apos;`%s`&apos; % f, fields)) attrs[&apos;__mapping__&apos;] = mapping attrs[&apos;__table__&apos;] = name return type.__new__(mcs, name, bases, attrs) class Model(dict, metaclass=ModelMetaclass): def __init__(self, **kwargs): super(Model, self).__init__(kwargs) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r&quot;&apos;Model&apos; object has no attribute &apos;%s&apos;&quot; % key) def __setattr__(self, key, value): self[key] = value def save(self): fields = [] params = [] args = [] for k, v in self.__mapping__.items(): print(&quot;%s------%s&quot; % (k, v)) fields.append(v.name) params.append(&apos;?&apos;) args.append(getattr(self, k, None)) sql = &apos;insert into %s (%s) values (%s)&apos; % (self.__table__, &apos;,&apos;.join(self.__fields__), &apos;,&apos;.join(params)) print(&apos;SQL: %s&apos; % sql) print(&apos;ARGS: %s&apos; % str(args)) class User(Model): # 定义类的属性到列的映射： id = IntegerField(&apos;id&apos;) name = StringField(&apos;username&apos;) email = StringField(&apos;email&apos;) password = StringField(&apos;password&apos;) u = User(id=12345, name=&apos;Michael&apos;, email=&apos;test@orm.org&apos;, password=&apos;my-pwd&apos;) u.save() 结语Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类： 1）Monkey patching 2) 类装饰器 当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://smarxpan.github.io/tags/Python/"}]},{"title":"Android应用冷启动时间优化探究","slug":"Android应用冷启动时间优化探究","date":"2018-08-29T12:48:33.000Z","updated":"2018-12-17T11:11:44.066Z","comments":true,"path":"2018/08/29/Android应用冷启动时间优化探究/","link":"","permalink":"http://smarxpan.github.io/2018/08/29/Android应用冷启动时间优化探究/","excerpt":"","text":"Android应用冷启动时间优化探究启动时间过长原因探究因应用三网融合SDK点击后启动时间过长，因此探究其冷启动时间过长的原因。 编写了一个Demo，demo的启动Activity为com.zhexin.paymergesdk.MainActivity 使用以下命令启动应用： adb shell am start -S -W com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN 此命令可统计启动时间 最初Demo是正常接入SDK，执行命令后的输出结果为： Stopping: com.outfit7.mytalkingtomfree Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity } Status: ok Activity: com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity ThisTime: 7260 TotalTime: 7260 WaitTime: 7282 Complete 冷启动时间为7260ms，黑/白屏时间过长。 因我这边自己写的代码都是在子线程中运行，因此怀疑是咪咕或者联通SDK的初始化时间过长导致，下面注释掉咪咕的初始化。 咪咕的初始化代码是： System.loadLibrary(&quot;megjb&quot;); 将其注释掉之后，安装Demo后再次运行命令，输出结果为： Stopping: com.outfit7.mytalkingtomfree Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity } Status: ok Activity: com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity ThisTime: 3404 TotalTime: 3404 WaitTime: 3447 Complete 看到冷启动时间明显少了一半以上，已经确定了咪咕是个大毒瘤。 然后，再确认联通SDK的影响。 联通SDK的初始化是要求必须继承他们都Application–com.unicom.shield.UnicomApplicationWrapper 将这个Application替换为普通的Application，安装后再次执行命令，输出结果为： Stopping: com.outfit7.mytalkingtomfree Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity } Status: ok Activity: com.outfit7.mytalkingtomfree/com.zhexin.paymergesdk.MainActivity ThisTime: 593 TotalTime: 593 WaitTime: 610 Complete OK，案件告破，的确是咪咕和小沃这两个大毒瘤导致的。 解决方案探究下面该思考解决方案了，可是这两个都要求在Application中调用，而且咪咕还要求调用它的首屏Activity，基本上正规方式是没什么办法解决了，只能思考奇技淫巧，让这个问题看起来像是解决了。 修改启动Activity的主题 Activity可以设置theme属性，而theme属性中可以设置windowBackground，具体步骤如下： 在drawable目录中创建xml文件，文件内容是 &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt; &lt;!-- The background color, preferably the same as your normal theme --&gt; &lt;item android:drawable=&quot;@android:color/white&quot; /&gt; &lt;!-- 引入想要显示的静态图片，这里我随便弄了张 --&gt; &lt;item&gt; &lt;bitmap android:gravity=&quot;center&quot; android:src=&quot;@drawable/logo&quot; /&gt; &lt;/item&gt; &lt;/layer-list&gt; 在styles.xml中添加新的style &lt;style name=&quot;AppTheme.Launcher&quot; parent=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/background_test&lt;/item&gt; &lt;/style&gt; 给咪咕的启动Activity配置theme &lt;activity android:name=&quot;cn.cmgame.billing.api.GameOpenActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:screenOrientation=&quot;sensor&quot; android:theme=&quot;@style/AppTheme.Launcher&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;!-- 设置咪咕启动界面为首Activity --&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.CHINAMOBILE_OMS_GAME&quot; /&gt; &lt;category android:name=&quot;android.intent.category.CHINAMOBILE_GAMES&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 效果可参见我附件的Demo 将游戏的退出改成调用home键 这个操作看似和冷启动优化无关，其实这样做的目的是给用户一个假象：用户按返回键退出，但是实际上并没退出，app处于后台，下次点击图标时直接唤起 这样将冷启动变成了热启动，也算是优化了用户体验（虽然这样比较流氓）。 具体是将调用返回键的地方改为调用home键，代码如下： @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_BACK) { Intent intent = new Intent(Intent.ACTION_MAIN); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addCategory(Intent.CATEGORY_HOME); startActivity(intent); return true; } return super.onKeyDown(keyCode, event); } 这样做的应用很多，游戏应该很少，因为游戏的耗电、内存占用决定了其很难在后台常驻。 以上，接入三网支付SDK的游戏需要给咪咕的首屏设置theme 我在使用时发现，咪咕首屏在调用我方首屏时，设置的background会一闪而逝，因此建议将background的图片设置为咪咕的logo图片，这样不显得突兀 参考链接 https://developer.android.com/topic/performance/vitals/launch-time https://github.com/DanluTeam/ColdStart","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"游戏接入运营商三网Android SDK整理","slug":"运营商三网sdk接入整理","date":"2018-02-07T07:15:30.000Z","updated":"2018-12-15T03:43:57.868Z","comments":true,"path":"2018/02/07/运营商三网sdk接入整理/","link":"","permalink":"http://smarxpan.github.io/2018/02/07/运营商三网sdk接入整理/","excerpt":"","text":"游戏接入运营商三网Android SDK整理记录下坑爹的三网支付运营商接入。 融合支付移动、联通和电信都提供了三网融合支付。但是运营商提供的融合支付仅支持他们自有渠道，外放渠道均不支持。如需要使用wostore和爱游戏渠道，单接他们的短代sdk即可。 因此需要自行融合三网支付接入游戏。 咪咕的特殊之处（需验证是否符合需求）Q. 三网融合计费功能集成。 26005 SDK已经集成移动，电信，联通三家运营商的统一计费功能，能够满足一次集 成，运营商话费支付全覆盖的业务场景。无需自行集成三家运营商的计费SDK。 三网融合计费功能需在业务平台进行申请后才能够使用。( 暂时没有对合作伙伴开放申请) 联通联通沃商店提供的SDK中，自带有测试用计费文件(Multimode_UniPay_payinfo.jar包含计费文件），如果CP做成的版本是为在沃商店上线使用的，只需要在代码中，将支付接口中计费点编号与Cp开发者社区里面的审核过的计费点编号对应好，打包成APK后，自测通过，即可提交开发者社区，开发者社区会自动为CP替换正式的计费文件。如果CP使用SDK的三网支付能力，必须到开发者社区进行打包。如果CP自己下载计费点文件，自行打包，移动支付能力将不能使用渠道外放单网包，只有联通话费能力，电信、移动卡支付会跳转到沃币支付是正常的。打包方式：到社区》渠道商打包，下载外渠道商用计费文件替换payinfo.jar自行打包即可 不使用sdk自带第三方支付，如何配置？ A： &lt;meta-data android:name=&quot;wostore_billing_otherpay&quot;&gt;&lt;/meta-data&gt; android:value=&quot;false&quot;/&gt; 设置为false，并且支付宝的相关jar可以不加入工程libs目录 爱游戏融合融合只要在接入段自测联通即可，咪咕计费嵌入游戏后为测试计费点，提交包体，爱游戏OPEN系统送咪咕完成计费加固后，咪咕计费点正式生效。 http://open.play.cn/dev/wiki/p1?page=1 miguQ. 如果 不接入联通支付 或 自行拟合三网包 ，联通相关的文件和配置可以 省略吗?可以省略，但是如果有后续三网融合计费的业务需求，建议保留。如果不接入联通、电信支付，可以删除如下文件和配置: SDK/AndroidManifest.xml.activity.txt中联通相关配置，如下: &lt;service android:name=&quot;com.unicom.channel.paysecurity.TouchPayService&quot; /&gt; SDK/AndroidManifest.xml.permision.txt中联通相关配置，如下: &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt; &lt;!-- 联通pay --&gt; SDK\\libs\\armeabi目录下libsmsprotocol.so、libunipaychsec.so两个文件 SDK\\assets目录下feeInfo.dat、unicom_channel_classez.jar、unicom_channel_resource.dat 三个文件 咪咕游戏SDK和Baidu、360等其他SDK融合时的不兼容，如何解决? 开一个空的Activity，在这个Activity中完成其他SDK的初始化接口调用; 然后再加载咪咕的so文件(System.loadLibrary(“”megjb”“);); 同时在Activity 跳转到GameOpenActivity中; GameOpenActivity 会跳转到 cn.cmgame.demo.MainActivity ——在string.xml中的”g_class_name”指定的游戏Activity——中调用咪咕的初始化接口。 (避免两个初始化的接口在同一个Activity中调用) 注意要点 计费文件 先上传游戏，获取爱游戏的计费文件 沃商店的计费文件比较特殊，上传游戏之后就可以获取，但是每个渠道的 渠道打包 先提交通过审核一个通用包，再进行单独渠道包的上传 计费能力申报顺序 爱游戏和联通并行–&gt;获取爱游戏和联通计费能力后–&gt;融合爱游戏和联通到咪咕后台上传打包 混淆#---------------爱游戏短代------------- -keep class cn.egame.terminal.**{*;} #---------------爱游戏短代------------- #---------------联通短代--------------- -libraryjars libs/Multimode_UniPay_base.jar -libraryjars libs/miniapay.jar -libraryjars libs/alipaysdk.jar -libraryjars libs/MobileSecSdk.jar -libraryjars libs/utdid4all-1.0.4.jar -keep class com.unipay.account.**{*;} -keep class com.unicom.dcLoader.**{*;} -keep class com.unicom.wostore.unipay.paysecurity.**{*;} -keep class com.wow.shell.**{*;} -keep class cn.egame.terminal.miniapay.**{*;} -keep class egame.terminal.feesmslib.jni.**{*;} -keep class com.alipay.sdk.**{*;} -keep class com.alipay.auth.**{*;} -keep class com.alipay.android.app.**{*;} #---------------联通短代--------------- 支付和初始化API及配置相关联通初始化 继承UnicomApplicationWrapper 初始化 public void initPayContext(Activity activity, UnipayPayResultListener listener) 支付单机 Utils.getInstances().pay(Context mContext, String number,UnipayPayResultListener listener); 联网 Utils.getInstances().payOnline (Context mContext, String number, String monthType, String orderid,UnipayPayResultListener listener); 支付回调（listener）public class mCallback implements UnipayPayResultListener { public void PayResult(String paycode, int flag, int flag2, String error) { // flag为支付回调结果，flag2为回调类型，error为当前结果描述，paycode是完整的计费点编码 switch (flag) { case 1://success //此处放置支付请求已提交的相关处理代码 break; case 2://fail //此处放置支付请求失败的相关处理代码 break; case 3://cancel //此处放置支付请求被取消的相关处理代码 break; default: break; } } flag2参数，请参考如下定义： SMS_SEND = 5; VAC_SEND = 8; MONTH_SEND = 11; UNMONTH_SEND = 12; DX_SMS_SEND = 13; SUBCOMMIT_VAC = 20; // VAC支付提交 SUCCESS_SMS = 21; // 短代支付成功 SUBCOMMIT_WEBALIPAY = 22; // WEB支付宝提交 SUCCESS_KALIPAY = 23; // 支付宝快捷支付成功 SUBCOMMIT_SZF = 24; // 神州付提交 SUCCESS_EXCHANGECODE = 25; // 兑换成功 CANCEL_FIRSTPAGE = 26; // 第一次确认支付取消 CANCEL_VACPAYPAGE = 27; // VAC支付页面取消 CANCEL_OTHERPAYPAGE = 28; // 其他支付页面取消 CANCEL_CHANGECODE = 29; // 兑换码页面取消 CANCEL_VACYZM = 30; // 话费验证码页面取消 CANCEL_CHINAMOBILE = 31; SUCCESS_POINTPAY = 32; // 沃币支付成功 SUBCOMMIT_ANCI = 35; UNSUBCOMMIT_ANCI = 36; SUBCOMMIT_BANKCARD = 37; SUBCOMMIT_WEIXINPAY = 38; SUBCOMMIT_QQPAY = 39; 咪咕获取运营商IOperatorCallback operatorCallback = new IOperatorCallback() { @Override public void onResult(int resultCode) { switch (resultCode) { case IsOperator.CMCC://移动 break; case IsOperator.CUCC://联通 break; case IsOperator.CTCC://电信 break; case IsOperator.UNKNOWN://未知状态 break; }}}; GameInterface.CheckOperator(this, operatorCallback); 初始化application中加载so： System.loadLibrary(&quot;megjb&quot;); 设置咪咕为首屏Activity 游戏Activity中调用初始化 void GameInterface.initializeApp(Activity main, String loginNo, ILoginCallback callback); 支付IPayCallback billingCallback = new IPayCallback() { Override public void onResult(int resultCode, String billingIndex, Object arg) { // 游戏业务收到付费结果后的处理逻辑 switch (resultCode) { case BillingResult.SUCCESS: //成功 break; case BillingResult.FAILED://失败 break; ...... }; void GameInterface.doBilling(Context context, int propsType, String billingIndex, String cpParam, IPayCallback billingCallback); 只有成功和失败，没有错误代码 爱游戏&lt;meta-data android:name=&quot;EGAME_IAPPPAY&quot; android:value=&quot;false&quot; /&gt; &lt;meta-data android:name=&quot;EGAME_ALIPAY&quot; android:value=&quot;false&quot; /&gt; &lt;meta-data android:name=&quot;EGAME_UNIPAY&quot; android:value=&quot;false&quot; /&gt; &lt;meta-data android:name=&quot;EGAME_NOWWECHATPAY&quot; android:value=&quot;false&quot; /&gt; &lt;meta-data android:name=&quot;EGAME_BESTPAY&quot; android:value=&quot;false&quot; /&gt; &lt;meta-data android:name=&quot;EGAME_CARDPSWD&quot; android:value=&quot;false&quot;/&gt; &lt;meta-data android:name=&quot;EGAME_HUAFEI_CARD&quot; android:value=&quot;false&quot;/&gt; 初始化activity中初始化 EgamePay.init(this); 支付HashMap payParams=new HashMap(); payParams.put(EgamePay.PAY_PARAMS_KEY_TOOLS_ALIAS, &quot;TOOL888&quot;); EgamePay.pay(Activity activity, Map payParams,EgamePayListener listener); 错误代码错误代码 错误描述 -2 未获得到实例，init重复调用，或与pay方法调用间隔过短 -10 外部SDK无法读取，检查工程及打好的apk的assets/egame文件夹内是否缺少文件 -11 打开输出文件错误,外部SDK无法解包 -12 MD5校验错误 -13 文件拷贝错误 -14 无法初始化实例 -20 sdk初始化异常 -100 Activity对象为空 -101 feeInfo.dat计费文件未找到或者数据读取异常 -102 无法读取当前应用信息 -103 应用信息校验失败，请检查包名及app_name是否和申报一致(注：信息更新后需要重新下载计费配置文件) -104 非电信用户 -106 计费金额错误 -108 无可用计费通道 -109 manifest配置错误 -200 初始化失败，无法进行计费 -201 计费回调对象为空 -202 计费道具别名错误 -203 渠道ID数据异常 -204 SERVICE_CODE数据异常 -205 自定义参数格式异常 -206 计费方法调用过快 -207 计费短信发送失败,检查手机及卡 -209 :第3方支付失败，请检查对应第3方资源及manifest中相关注册是否遗漏，以及检查是否混淆 -300 获取计费流水号网络异常 -301 获取计费流水号数据异常，检查open平台游戏状态是否正常 -111 未使用最新SDK资源，检查so及jar包【针对4.1.6及以上】 客户端功能划分[46000] MCC:460 MNC:00 China China Mobile [46002] MCC:460 MNC:02 China China Mobile [46007] MCC:460 MNC:07 China China Mobile [46003] MCC:460 MNC:03 China China Telecom [46005] MCC:460 MNC:05 China China Telecom 接口请求 计费策略接口和日志接口。 接口内容已写完。 接入计费逻辑 其中包括接入三网计费，同时隐藏了一个计费文件，这个计费文件保存了我方计费点查询到运营商计费点的信息。这个计费文件需要从后台导出，放在游戏中。 接入计费逻辑的时候要考虑好接入过程。 计费逻辑已完成 本地计费策略的缓存和处理 包括计费策略的缓存和更新。缓存即存储到本地数据库。根据每次触发计费，处理策略的更新。 每次计费成功，需要更新本地的计费策略。 开始时设置一个计时器，用来处理计费策略的更新。 日志接口十分重要，需要思考好所有日志的类型–尽量细分。 初始化接口删除cellId,localAeraCode,meid 初始化时需将策略放入缓存","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"Retrofit2自定义拦截器和ConverterFactory实现客户端与服务端加密通信","slug":"Retrofit2自定义拦截器和ConverterFactory实现客户端与服务端加密通信","date":"2017-12-06T13:05:21.000Z","updated":"2018-12-17T12:11:38.295Z","comments":true,"path":"2017/12/06/Retrofit2自定义拦截器和ConverterFactory实现客户端与服务端加密通信/","link":"","permalink":"http://smarxpan.github.io/2017/12/06/Retrofit2自定义拦截器和ConverterFactory实现客户端与服务端加密通信/","excerpt":"","text":"网络请求框架使用的retrofit，客户端与服务端之间需要加密通信并且请求需要gzip压缩。为完成这一需求，需要拦截请求和响应。特此记录下修改请求的过程，希望可以帮助有需要的人。 处理requestretrofit2使用okhttp3.x，请求上的处理只需要给okhttp添加拦截器即可 这里与服务端通信相互之间对称加密，并且需要开启gzip压缩，因此这里定义了三个拦截器完成这一需求 修改请求头 public class RequestHeaderInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request originalRequest = chain.request(); Request updateRequest = originalRequest.newBuilder() .header(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;) .header(&quot;Accept&quot;, &quot;*/*&quot;) .header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;) .build(); return chain.proceed(updateRequest); } } 加密请求内容 public class RequestEncryptInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); RequestBody body = request.body(); Buffer buffer = new Buffer(); body.writeTo(buffer); Charset charset = Charset.forName(&quot;UTF-8&quot;); MediaType contentType = body.contentType(); if (contentType != null) { charset = contentType.charset(charset); } String paramsStr = buffer.readString(charset); try { paramsStr = EncryptUtils.encryptParams(paramsStr); } catch (Exception e) { LogUtils.e(e); } RequestBody requestBody = RequestBody.create(MediaType.parse(&quot;text/plain; charset=utf-8&quot;), paramsStr); request = request.newBuilder() .post(requestBody) .build(); return chain.proceed(request); } } 启用Gzip压缩 public class GzipRequsetInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request originalRequest = chain.request(); if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) { return chain.proceed(originalRequest); } Request compressedRequest = originalRequest.newBuilder() .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;) .method(originalRequest.method(), gzip(originalRequest.body())) .build(); return chain.proceed(compressedRequest); } private RequestBody gzip(final RequestBody body) { return new RequestBody() { @Override public MediaType contentType() { return body.contentType(); } @Override public long contentLength() throws IOException { return -1; } @Override public void writeTo(BufferedSink sink) throws IOException { BufferedSink gzipSink = Okio.buffer(new GzipSink(sink)); body.writeTo(gzipSink); gzipSink.close(); } }; } } 处理response对response处理需要未retrofit设置自定义的ConverterFactory，因客户端与服务端使用json通信，因此我们参考官方提供GsonConverterFactory编写 自定义GsonConverterFactory，其实相对于原版只修改了responseBodyConverter方法的内容，requestBodyConverter依旧用的原版内容。 注意,GsonRequestBodyConverter类的修饰符不是public，需要将其代码拷贝出来 public final class CustomGsonConverterFactory extends Converter.Factory { private final Gson gson; public static CustomGsonConverterFactory create() { return create(new Gson()); } @SuppressWarnings(&quot;ConstantConditions&quot;) // Guarding public API nullability. public static CustomGsonConverterFactory create(Gson gson) { if (gson == null) throw new NullPointerException(&quot;gson == null&quot;); return new CustomGsonConverterFactory(gson); } private CustomGsonConverterFactory(Gson gson) { this.gson = gson; } @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new CustomGsonResponseConverter&lt;&gt;(gson, adapter); } @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter&lt;&gt;(gson, adapter); } } 修改GsonResponseConverter，使其解密后再处理内容。 注意：这里预处理json的过程并非通用步骤，因我的json格式是 { &quot;code&quot;: 0, &quot;message&quot;: &quot;success&quot;, &quot;data&quot;: { ... } }这样的，如果你的不同请换一种方式。 class CustomGsonResponseConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; { private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; CustomGsonResponseConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) { this.gson = gson; this.adapter = adapter; } @Override public T convert(ResponseBody value) throws IOException { try { String originalBody = value.string(); // 解密 String body = EncryptUtils.decryptParams(originalBody); // 获取json中的code，对json进行预处理 JSONObject json = new JSONObject(body); int code = json.optInt(&quot;code&quot;); // 当code不为0时，设置data为{}，这样转化就不会出错了 if (code != 0) { json.put(&quot;data&quot;, new JSONObject()); body = json.toString(); } return adapter.fromJson(body); } catch (Exception e) { throw new RuntimeException(e.getMessage()); } finally { value.close(); } } 这里也贴一下原版的GsonRequestBodyConverter： class GsonRequestBodyConverter&lt;T&gt; implements Converter&lt;T, RequestBody&gt; { private static final MediaType MEDIA_TYPE = MediaType.parse(&quot;application/json; charset=UTF-8&quot;); private static final Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;); private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; GsonRequestBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) { this.gson = gson; this.adapter = adapter; } @Override public RequestBody convert(T value) throws IOException { Buffer buffer = new Buffer(); Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8); JsonWriter jsonWriter = gson.newJsonWriter(writer); adapter.write(jsonWriter, value); jsonWriter.close(); return RequestBody.create(MEDIA_TYPE, buffer.readByteString()); } } 这样build.gradle中就可以删掉引入的GsonConverterFactory了 整合使用使用方式如下 Retrofit retrofit = new Retrofit.Builder() .client(getOkHttpClient()) .addConverterFactory(CustomGsonConverterFactory.create()) .baseUrl(BASE_URL) .build(); 其中，okhttpClient方法： @NonNull private OkHttpClient getOkHttpClient() { OkHttpClient.Builder okHttpClientBuilder = new OkHttpClient.Builder(); okHttpClientBuilder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS) .writeTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS) .readTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS) .addInterceptor(new RequestHeaderInterceptor()) .addInterceptor(new RequestEncryptInterceptor()) .addInterceptor(new GzipRequsetInterceptor()); return okHttpClientBuilder.build(); } 就酱","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"CentOS6/7和Ubuntu安装shadowsocks-libev及使用","slug":"CentOS6-7和Ubuntu安装shadowsocks-libv","date":"2017-05-03T07:15:30.000Z","updated":"2019-05-11T03:10:30.536Z","comments":true,"path":"2017/05/03/CentOS6-7和Ubuntu安装shadowsocks-libv/","link":"","permalink":"http://smarxpan.github.io/2017/05/03/CentOS6-7和Ubuntu安装shadowsocks-libv/","excerpt":"","text":"CentOS6/7安装 安装Fedora软件源 cd /etc/yum.repos.d/ wget https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-6/librehat-shadowsocks-epel-6.repo update sudo yum update 安装 sudo yum install shadowsocks-libev Ubuntu安装sudo apt-get install software-properties-common -y sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev -y sudo apt-get update sudo apt install shadowsocks-libev 通用源码安装(针对无法直接安装的系统) 通过git下载源码（请先安装git） git clone https://github.com/shadowsocks/shadowsocks-libev.git cd shadowsocks-libev git submodule update --init --recursive 编译安装 安装依赖 # Installation of basic build dependencies ## Debian / Ubuntu sudo apt-get install --no-install-recommends gettext build-essential autoconf libtool libpcre3-dev asciidoc xmlto libev-dev libc-ares-dev automake libmbedtls-dev libsodium-dev ## CentOS / Fedora / RHEL sudo yum install gettext gcc autoconf libtool automake make asciidoc xmlto c-ares-devel libev-devel ## Arch sudo pacman -S gettext gcc autoconf libtool automake make asciidoc xmlto c-ares libev # Installation of Libsodium export LIBSODIUM_VER=1.0.13 wget https://download.libsodium.org/libsodium/releases/libsodium-$LIBSODIUM_VER.tar.gz tar xvf libsodium-$LIBSODIUM_VER.tar.gz pushd libsodium-$LIBSODIUM_VER ./configure --prefix=/usr &amp;&amp; make sudo make install popd sudo ldconfig # Installation of MbedTLS export MBEDTLS_VER=2.6.0 wget https://tls.mbed.org/download/mbedtls-$MBEDTLS_VER-gpl.tgz tar xvf mbedtls-$MBEDTLS_VER-gpl.tgz pushd mbedtls-$MBEDTLS_VER make SHARED=1 CFLAGS=-fPIC sudo make DESTDIR=/usr install popd sudo ldconfig 进入shadowsocks-libev源码目录 # Start building ./autogen.sh &amp;&amp; ./configure &amp;&amp; make sudo make install 启动服务ss-server -c /etc/shadowsocks.json json示例： { &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;server_port&quot;: 443, &quot;password&quot;: &quot;yourpassword&quot;, &quot;method&quot;: &quot;aes-256-gcm&quot; } 如果启动时报错： This system doesn&apos;t provide enough entropy to quickly generate high-quality random numbers Installing the rng-utils/rng-tools or haveged packages may help. On virtualized Linux environments, also consider using virtio-rng. The service will not start until enough entropy has been collected. 是说系统没有足够的熵，两种解决方式，1. 多等一会就好了 2.按提示所说安装rng-tools 安装rng-tools： # ubuntu apt-get install rng-tools # centos yum install rng-tools 启动BBR加速注意：仅KVM架构可用，OVZ不可以这样安装 Debian 8+ / Ubuntu 14.04+ 下载最新内核,最新内核查看这里 wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.16/linux-image-4.16.0-041600-generic_4.16.0-041600.201804012230_amd64.deb 安装内核 dpkg -i linux-image-4.*.deb 删除旧内核(可选) dpkg -l | grep linux-image apt-get purge 旧内核 更新 grub 系统引导文件并重启 update-grub reboot 开启bbr开机后 uname -r 看看是不是内核 &gt;= 4.9 执行 lsmod | grep bbr，如果结果中没有 tcp_bbr 的话就先执行 modprobe tcp_bbr echo &quot;tcp_bbr&quot; | sudo tee --append /etc/modules-load.d/modules.conf 执行 echo &quot;net.core.default_qdisc=fq&quot; | sudo tee --append /etc/sysctl.conf echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; | sudo tee --append /etc/sysctl.conf 保存生效 sysctl -p 执行 sysctl net.ipv4.tcp_available_congestion_control sysctl net.ipv4.tcp_congestion_control 如果结果都有 bbr, 则证明你的内核已开启 bbr 执行 lsmod | grep bbr, 看到有 tcp_bbr 模块即说明 bbr 已启动 启用simple-obfs（非必选）如需使用混淆请继续，不需要请离开 编译安装# Debian / Ubuntu sudo apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libev-dev asciidoc xmlto automake # CentOS / Fedora / RHEL sudo yum install gcc autoconf libtool automake make zlib-devel openssl-devel asciidoc xmlto # Arch sudo pacman -Syu gcc autoconf libtool automake make zlib openssl asciidoc xmlto # Alpine apk add gcc autoconf make libtool automake zlib-devel openssl asciidoc xmlto libpcre32 libev-dev g++ linux-headers git clone https://github.com/shadowsocks/simple-obfs.git cd simple-obfs git submodule update --init --recursive ./autogen.sh ./configure &amp;&amp; make sudo make install 使用客户端 ss-local -c config.json --plugin obfs-local --plugin-opts &quot;obfs=http;obfs-host=www.bing.com&quot; 服务端 ss-server -c config.json --plugin obfs-server --plugin-opts &quot;obfs=http&quot; 查询连接到该服务的人数netstat -anp|grep ip:port |grep ESTABLISHED","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://smarxpan.github.io/tags/Linux/"}]},{"title":"编程的智慧by王垠","slug":"编程的智慧by王垠","date":"2017-04-20T07:15:30.000Z","updated":"2018-12-17T11:06:12.060Z","comments":true,"path":"2017/04/20/编程的智慧by王垠/","link":"","permalink":"http://smarxpan.github.io/2017/04/20/编程的智慧by王垠/","excerpt":"","text":"编程的智慧by王垠编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而由于软件行业喜欢标新立异，喜欢把简单的事情搞复杂，我希望这些文字能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。 反复推敲代码既然“天才是百分之一的灵感，百分之九十九的汗水”，那我先来谈谈这汗水的部分吧。有人问我，提高编程水平最有效的办法是什么？我想了很久，终于发现最有效的办法，其实是反反复复地修改和推敲代码。 在IU的时候，由于Dan Friedman的严格教导，我们以写出冗长复杂的代码为耻。如果你代码多写了几行，这老顽童就会大笑，说：“当年我解决这个问题，只写了5行代码，你回去再想想吧……” 当然，有时候他只是夸张一下，故意刺激你的，其实没有人能只用5行代码完成。然而这种提炼代码，减少冗余的习惯，却由此深入了我的骨髓。 有些人喜欢炫耀自己写了多少多少万行的代码，仿佛代码的数量是衡量编程水平的标准。然而，如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。你会制造出越来越多平庸甚至糟糕的代码。在这种意义上，很多人所谓的“工作经验”，跟他代码的质量，其实不一定成正比。如果有几十年的工作经验，却从来不回头去提炼和反思自己的代码，那么他也许还不如一个只有一两年经验，却喜欢反复推敲，仔细领悟的人。 有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。 就像文学作品一样，代码是不可能一蹴而就的。灵感似乎总是零零星星，陆陆续续到来的。任何人都不可能一笔呵成，就算再厉害的程序员，也需要经过一段时间，才能发现最简单优雅的写法。有时候你反复提炼一段代码，觉得到了顶峰，没法再改进了，可是过了几个月再回头来看，又发现好多可以改进和简化的地方。这跟写文章一模一样，回头看几个月或者几年前写的东西，你总能发现一些改进。 所以如果反复提炼代码已经不再有进展，那么你可以暂时把它放下。过几个星期或者几个月再回头来看，也许就有焕然一新的灵感。这样反反复复很多次之后，你就积累起了灵感和智慧，从而能够在遇到新问题的时候直接朝正确，或者接近正确的方向前进。 写优雅的代码人们都讨厌“面条代码”（spaghetti code），因为它就像面条一样绕来绕去，没法理清头绪。那么优雅的代码一般是什么形状的呢？经过多年的观察，我发现优雅的代码，在形状上有一些明显的特征。 如果我们忽略具体的内容，从大体结构上来看，优雅的代码看起来就像是一些整整齐齐，套在一起的盒子。如果跟整理房间做一个类比，就很容易理解。如果你把所有物品都丢在一个很大的抽屉里，那么它们就会全都混在一起。你就很难整理，很难迅速的找到需要的东西。但是如果你在抽屉里再放几个小盒子，把物品分门别类放进去，那么它们就不会到处乱跑，你就可以比较容易的找到和管理它们。 优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。这是因为程序所做的几乎一切事情，都是信息的传递和分支。你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的if语句，它看起来就会像这个样子： 1234567891011if (...) &#123; if (...) &#123; ... &#125; else &#123; ... &#125;&#125; else if (...) &#123; ...&#125; else &#123; ...&#125; 注意到了吗？在我的代码里面，if语句几乎总是有两个分支。它们有可能嵌套，有多层的缩进，而且else分支里面有可能出现少量重复的代码。然而这样的结构，逻辑却非常严密和清晰。在后面我会告诉你为什么if语句最好有两个分支。 写模块化的代码有些人吵着闹着要让程序“模块化”，结果他们的做法是把代码分部到多个文件和目录里面，然后把这些目录或者文件叫做“module”。他们甚至把这些目录分放在不同的VCS repo里面。结果这样的作法并没有带来合作的流畅，而是带来了许多的麻烦。这是因为他们其实并不理解什么叫做“模块”，肤浅的把代码切割开来，分放在不同的位置，其实非但不能达到模块化的目的，而且制造了不必要的麻烦。 真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。 想要达到很好的模块化，你需要做到以下几点： 避免写太长的函数。如果发现函数太大了，就应该把它拆分成几个更小的。通常我写的函数长度都不超过40行。对比一下，一般笔记本电脑屏幕所能容纳的代码行数是50行。我可以一目了然的看见一个40行的函数，而不需要滚屏。只有40行而不是50行的原因是，我的眼球不转的话，最大的视角只看得到40行代码。 如果我看代码不转眼球的话，我就能把整片代码完整的映射到我的视觉神经里，这样就算忽然闭上眼睛，我也能看得见这段代码。我发现闭上眼睛的时候，大脑能够更加有效地处理代码，你能想象这段代码可以变成什么其它的形状。40行并不是一个很大的限制，因为函数里面比较复杂的部分，往往早就被我提取出去，做成了更小的函数，然后从原来的函数里面调用。 制造小的工具函数。如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。有些帮助函数也许就只有两行，然而它们却能大大简化主要函数里面的逻辑。 有些人不喜欢使用小的函数，因为他们想避免函数调用的开销，结果他们写出几百行之大的函数。这是一种过时的观念。现代的编译器都能自动的把小的函数内联（inline）到调用它的地方，所以根本不产生函数调用，也就不会产生任何多余的开销。 同样的一些人，也爱使用宏（macro）来代替小函数，这也是一种过时的观念。在早期的C语言编译器里，只有宏是静态“内联”的，所以他们使用宏，其实是为了达到内联的目的。然而能否内联，其实并不是宏与函数的根本区别。宏与函数有着巨大的区别（这个我以后再讲），应该尽量避免使用宏。为了内联而使用宏，其实是滥用了宏，这会引起各种各样的麻烦，比如使程序难以理解，难以调试，容易出错等等。 每个函数只做一件简单的事情。有些人喜欢制造一些“通用”的函数，既可以做这个又可以做那个，它的内部依据某些变量和条件，来“选择”这个函数所要做的事情。比如，你也许写出这样的函数： 12345678910111213void foo() &#123; if (getOS().equals(&quot;MacOS&quot;)) &#123; a(); &#125; else &#123; b(); &#125; c(); if (getOS().equals(&quot;MacOS&quot;)) &#123; d(); &#125; else &#123; e(); &#125;&#125; 写这个函数的人，根据系统是否为“MacOS”来做不同的事情。你可以看出这个函数里，其实只有c()是两种系统共有的，而其它的a(), b(), d(), e()都属于不同的分支。 这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数： 12345void fooMacOS() &#123; a(); c(); d();&#125; 和 12345void fooOther() &#123; b(); c(); e();&#125; 如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样： 12345678910void foo() &#123; a(); b() c(); if (getOS().equals(&quot;MacOS&quot;)) &#123; d(); &#125; else &#123; e(); &#125;&#125; 其中a()，b()，c()都是一样的，只有d()和e()根据系统有所不同。那么你可以把a()，b()，c()提取出去： 1234void preFoo() &#123; a(); b() c(); 然后制造两个函数： 1234void fooMacOS() &#123; preFoo(); d();&#125; 和 1234void fooOther() &#123; preFoo(); e();&#125; 这样一来，我们既共享了代码，又做到了每个函数只做一件简单的事情。这样的代码，逻辑就更加清晰。 避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。有些人写代码，经常用类成员来传递信息，就像这样： 1234567891011121314class A &#123; String x; void findX() &#123; ... x = ...; &#125; void foo() &#123; findX(); ... print(x); &#125;&#125; 首先，他使用findX()，把一个值写入成员x。然后，使用x的值。这样，x就变成了findX和print之间的数据通道。由于x属于class A，这样程序就失去了模块化的结构。由于这两个函数依赖于成员x，它们不再有明确的输入和输出，而是依赖全局的数据。findX和foo不再能够离开class A而存在，而且由于类成员还有可能被其他代码改变，代码变得难以理解，难以确保正确性。 如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个class，而且更加容易理解，不易出错： 123456789String findX() &#123; ... x = ...; return x;&#125;void foo() &#123; String x = findX(); print(x);&#125; 写可读的代码有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。 实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。 有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。这样的情况应该少出现，否则这意味着整个代码的设计都有问题。 如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要： 使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如： 12// put elephant1 into fridge2put(elephant1, fridge2); 由于我的函数名put，加上两个有意义的变量名elephant1和fridge2，已经说明了这是在干什么（把大象放进冰箱），所以上面那句注释完全没有必要。 局部变量应该尽量接近使用它的地方。有些人喜欢在函数最开头定义很多局部变量，然后在下面很远的地方使用它，就像这个样子： 1234567void foo() &#123; int index = ...; ... ... bar(index); ...&#125; 由于这中间都没有使用过index，也没有改变过它所依赖的数据，所以这个变量定义，其实可以挪到接近使用它的地方： 1234567void foo() &#123; ... ... int index = ...; bar(index); ...&#125; 这样读者看到bar(index)，不需要向上看很远就能发现index是如何算出来的。而且这种短距离，可以加强读者对于这里的“计算顺序”的理解。否则如果index在顶上，读者可能会怀疑，它其实保存了某种会变化的数据，或者它后来又被修改过。如果index放在下面，读者就清楚的知道，index并不是保存了什么可变的值，而且它算出来之后就没变过。 如果你看透了局部变量的本质——它们就是电路里的导线，那你就能更好的理解近距离的好处。变量定义离用的地方越近，导线的长度就越短。你不需要摸着一根导线，绕来绕去找很远，就能发现接收它的端口，这样的电路就更容易理解。 局部变量名字应该简短。这貌似跟第一点相冲突，简短的变量名怎么可能有意义呢？注意我这里说的是局部变量，因为它们处于局部，再加上第2点已经把它放到离使用位置尽量近的地方，所以根据上下文你就会容易知道它的意思： 比如，你有一个局部变量，表示一个操作是否成功： 123456boolean successInDeleteFile = deleteFile(&quot;foo.txt&quot;);if (successInDeleteFile) &#123; ...&#125; else &#123; ...&#125; 这个局部变量successInDeleteFile大可不必这么啰嗦。因为它只用过一次，而且用它的地方就在下面一行，所以读者可以轻松发现它是deleteFile返回的结果。如果你把它改名为success，其实读者根据一点上下文，也知道它表示”success in deleteFile”。所以你可以把它改成这样： 123456boolean success = deleteFile(&quot;foo.txt&quot;);if (success) &#123; ...&#125; else &#123; ...&#125; 这样的写法不但没漏掉任何有用的语义信息，而且更加易读。successInDeleteFile这种“camelCase”，如果超过了三个单词连在一起，其实是很碍眼的东西。所以如果你能用一个单词表示同样的意义，那当然更好。 不要重用局部变量。很多人写代码不喜欢定义新的局部变量，而喜欢“重用”同一个局部变量，通过反复对它们进行赋值，来表示完全不同意思。比如这样写： 12345678String msg;if (...) &#123; msg = &quot;succeed&quot;; log.info(msg);&#125; else &#123; msg = &quot;failed&quot;; log.info(msg);&#125; 虽然这样在逻辑上是没有问题的，然而却不易理解，容易混淆。变量msg两次被赋值，表示完全不同的两个值。它们立即被log.info使用，没有传递到其它地方去。这种赋值的做法，把局部变量的作用域不必要的增大，让人以为它可能在将来改变，也许会在其它地方被使用。更好的做法，其实是定义两个变量： 1234567if (...) &#123; String msg = &quot;succeed&quot;; log.info(msg);&#125; else &#123; String msg = &quot;failed&quot;; log.info(msg);&#125; 由于这两个msg变量的作用域仅限于它们所处的if语句分支，你可以很清楚的看到这两个msg被使用的范围，而且知道它们之间没有任何关系。 把复杂的逻辑提取出去，做成“帮助函数”。有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，这样你就可以使用有意义的函数名来代替注释。举一个例子： 12345678910...// put elephant1 into fridge2openDoor(fridge2);if (elephant1.alive()) &#123; ...&#125; else &#123; ...&#125;closeDoor(fridge2);... 如果你把这片代码提出去定义成一个函数： 123456789void put(Elephant elephant, Fridge fridge) &#123; openDoor(fridge); if (elephant.alive()) &#123; ... &#125; else &#123; ... &#125; closeDoor(fridge);&#125; 这样原来的代码就可以改成： 123...put(elephant1, fridge2);... 更加清晰，而且注释也没必要了。 把复杂的表达式提取出去，做成中间变量。有些人听说“函数式编程”是个好东西，也不理解它的真正含义，就在代码里大量使用嵌套的函数。像这样： 12Pizza pizza = makePizza(crust(salt(), butter()), topping(onion(), tomato(), sausage())); 这样的代码一行太长，而且嵌套太多，不容易看清楚。其实训练有素的函数式程序员，都知道中间变量的好处，不会盲目的使用嵌套的函数。他们会把这代码变成这样： 123Crust crust = crust(salt(), butter());Topping topping = topping(onion(), tomato(), sausage());Pizza pizza = makePizza(crust, topping); 这样写，不但有效地控制了单行代码的长度，而且由于引入的中间变量具有“意义”，步骤清晰，变得很容易理解。 在合理的地方换行。对于绝大部分的程序语言，代码的逻辑是和空白字符无关的，所以你可以在几乎任何地方换行，你也可以不换行。这样的语言设计是个好东西，因为它给了程序员自由控制自己代码格式的能力。然而，它也引起了一些问题，因为很多人不知道如何合理的换行。 有些人喜欢利用IDE的自动换行机制，编辑之后用一个热键把整个代码重新格式化一遍，IDE就会把超过行宽限制的代码自动折行。可是这种自动这行，往往没有根据代码的逻辑来进行，不能帮助理解代码。自动换行之后可能产生这样的代码： 1234if (someLongCondition1() &amp;&amp; someLongCondition2() &amp;&amp; someLongCondition3() &amp;&amp; someLongCondition4()) &#123; ...&#125; 由于someLongCondition4()超过了行宽限制，被编辑器自动换到了下面一行。虽然满足了行宽限制，换行的位置却是相当任意的，它并不能帮助人理解这代码的逻辑。这几个boolean表达式，全都用&amp;&amp;连接，所以它们其实处于平等的地位。为了表达这一点，当需要折行的时候，你应该把每一个表达式都放到新的一行，就像这个样子： 123456if (someLongCondition1() &amp;&amp; someLongCondition2() &amp;&amp; someLongCondition3() &amp;&amp; someLongCondition4()) &#123; ...&#125; 这样每一个条件都对齐，里面的逻辑就很清楚了。再举个例子： 12log.info(&quot;failed to find file &#123;&#125; for command &#123;&#125;, with exception &#123;&#125;&quot;, file, command, exception); 这行因为太长，被自动折行成这个样子。file，command和exception本来是同一类东西，却有两个留在了第一行，最后一个被折到第二行。它就不如手动换行成这个样子： 12log.info(&quot;failed to find file &#123;&#125; for command &#123;&#125;, with exception &#123;&#125;&quot;, file, command, exception); 把格式字符串单独放在一行，而把它的参数一并放在另外一行，这样逻辑就更加清晰。 为了避免IDE把这些手动调整好的换行弄乱，很多IDE（比如IntelliJ）的自动格式化设定里都有“保留原来的换行符”的设定。如果你发现IDE的换行不符合逻辑，你可以修改这些设定，然后在某些地方保留你自己的手动换行。 说到这里，我必须警告你，这里所说的“不需注释，让代码自己解释自己”，并不是说要让代码看起来像某种自然语言。有个叫Chai的JavaScript测试工具，可以让你这样写代码： 1234expect(foo).to.be.a(&apos;string&apos;);expect(foo).to.equal(&apos;bar&apos;);expect(foo).to.have.length(3);expect(tea).to.have.property(&apos;flavors&apos;).with.length(3); 这种做法是极其错误的。程序语言本来就比自然语言简单清晰，这种写法让它看起来像自然语言的样子，反而变得复杂难懂了。 写简单的代码程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。 并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，“新”的特性，我基本都只用经过千锤百炼，我觉得值得信赖的那一套。 现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。 避免使用自增减表达式（i++，++i，i–，–i）。这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。 其实这两个表达式完全可以分解成两步，把读和写分开：一步更新i的值，另外一步使用i的值。比如，如果你想写foo(i++)，你完全可以把它拆成int t = i; i += 1; foo(t);。如果你想写foo(++i)，可以拆成i += 1; foo(i); 拆开之后的代码，含义完全一致，却清晰很多。到底更新是在取值之前还是之后，一目了然。 有人也许以为i++或者++i的效率比拆开之后要高，这只是一种错觉。这些代码经过基本的编译器优化之后，生成的机器代码是完全没有区别的。自增减表达式只有在两种情况下才可以安全的使用。一种是在for循环的update部分，比如for(int i = 0; i &lt; 5; i++)。另一种情况是写成单独的一行，比如i++;。这两种情况是完全没有歧义的。你需要避免其它的情况，比如用在复杂的表达式里面，比如foo(i++)，foo(++i) + foo(i)，…… 没有人应该知道，或者去追究这些是什么意思。 永远不要省略花括号。很多语言允许你在某种情况下省略掉花括号，比如C，Java都允许你在if语句里面只有一句话的时候省略掉花括号： 12if (...) action1(); 咋一看少打了两个字，多好。可是这其实经常引起奇怪的问题。比如，你后来想要加一句话action2()到这个if里面，于是你就把代码改成： 123if (...) action1(); action2(); 为了美观，你很小心的使用了action1()的缩进。咋一看它们是在一起的，所以你下意识里以为它们只会在if的条件为真的时候执行，然而action2()却其实在if外面，它会被无条件的执行。我把这种现象叫做“光学幻觉”（optical illusion），理论上每个程序员都应该发现这个错误，然而实际上却容易被忽视。 那么你问，谁会这么傻，我在加入action2()的时候加上花括号不就行了？可是从设计的角度来看，这样其实并不是合理的作法。首先，也许你以后又想把action2()去掉，这样你为了样式一致，又得把花括号拿掉，烦不烦啊？其次，这使得代码样式不一致，有的if有花括号，有的又没有。况且，你为什么需要记住这个规则？如果你不问三七二十一，只要是if-else语句，把花括号全都打上，就可以想都不用想了，就当C和Java没提供给你这个特殊写法。这样就可以保持完全的一致性，减少不必要的思考。 有人可能会说，全都打上花括号，只有一句话也打上，多碍眼啊？然而经过实行这种编码规范几年之后，我并没有发现这种写法更加碍眼，反而由于花括号的存在，使得代码界限明确，让我的眼睛负担更小了。 合理使用括号，不要盲目依赖操作符优先级。利用操作符的优先级来减少括号，对于1 + 2 * 3这样常见的算数表达式，是没问题的。然而有些人如此的仇恨括号，以至于他们会写出2 &lt;&lt; 7 - 2 * 3这样的表达式，而完全不用括号。 这里的问题，在于移位操作&lt;&lt;的优先级，是很多人不熟悉，而且是违反常理的。由于x &lt;&lt; 1相当于把x乘以2，很多人误以为这个表达式相当于(2 &lt;&lt; 7) - (2 * 3)，所以等于250。然而实际上&lt;&lt;的优先级比加法+还要低，所以这表达式其实相当于2 &lt;&lt; (7 - 2 * 3)，所以等于4！ 解决这个问题的办法，不是要每个人去把操作符优先级表给硬背下来，而是合理的加入括号。比如上面的例子，最好直接加上括号写成2 &lt;&lt; (7 - 2 * 3)。虽然没有括号也表示同样的意思，但是加上括号就更加清晰，读者不再需要死记&lt;&lt;的优先级就能理解代码。 避免使用continue和break。循环语句（for，while）里面出现return是没问题的，然而如果你使用了continue或者break，就会让循环的逻辑和终止条件变得复杂，难以确保正确。 出现continue或者break的原因，往往是对循环的逻辑没有想清楚。如果你考虑周全了，应该是几乎不需要continue或者break的。如果你的循环里出现了continue或者break，你就应该考虑改写这个循环。改写循环的办法有多种： 如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。 如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。 有时候你可以把break替换成return，从而去掉break。 如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。 下面我对这些情况举一些例子。 情况1：下面这段代码里面有一个continue： 12345678List&lt;String&gt; goodNames = new ArrayList&lt;&gt;();for (String name: names) &#123; if (name.contains(&quot;bad&quot;)) &#123; continue; &#125; goodNames.add(name); ...&#125; 它说：“如果name含有’bad’这个词，跳过后面的循环代码……” 注意，这是一种“负面”的描述，它不是在告诉你什么时候“做”一件事，而是在告诉你什么时候“不做”一件事。为了知道它到底在干什么，你必须搞清楚continue会导致哪些语句被跳过了，然后脑子里把逻辑反个向，你才能知道它到底想做什么。这就是为什么含有continue和break的循环不容易理解，它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。 其实，我们只需要把continue的条件反向，这段代码就可以很容易的被转换成等价的，不含continue的代码： 1234567List&lt;String&gt; goodNames = new ArrayList&lt;&gt;();for (String name: names) &#123; if (!name.contains(&quot;bad&quot;)) &#123; goodNames.add(name); ... &#125;&#125; goodNames.add(name);和它之后的代码全部被放到了if里面，多了一层缩进，然而continue却没有了。你再读这段代码，就会发现更加清晰。因为它是一种更加“正面”地描述。它说：“在name不含有’bad’这个词的时候，把它加到goodNames的链表里面……” 情况2：for和while头部都有一个循环的“终止条件”，那本来应该是这个循环唯一的退出条件。如果你在循环中间有break，它其实给这个循环增加了一个退出条件。你往往只需要把这个条件合并到循环头部，就可以去掉break。 比如下面这段代码： 123456while (condition1) &#123; ... if (condition2) &#123; break; &#125;&#125; 当condition成立的时候，break会退出循环。其实你只需要把condition2反转之后，放到while头部的终止条件，就可以去掉这种break语句。改写后的代码如下： 123while (condition1 &amp;&amp; !condition2) &#123; ...&#125; 这种情况表面上貌似只适用于break出现在循环开头或者末尾的时候，然而其实大部分时候，break都可以通过某种方式，移动到循环的开头或者末尾。具体的例子我暂时没有，等出现的时候再加进来。 情况3：很多break退出循环之后，其实接下来就是一个return。这种break往往可以直接换成return。比如下面这个例子： 1234567891011public boolean hasBadName(List&lt;String&gt; names) &#123; boolean result = false; for (String name: names) &#123; if (name.contains(&quot;bad&quot;)) &#123; result = true; break; &#125; &#125; return result;&#125; 这个函数检查names链表里是否存在一个名字，包含“bad”这个词。它的循环里包含一个break语句。这个函数可以被改写成： 12345678public boolean hasBadName(List&lt;String&gt; names) &#123; for (String name: names) &#123; if (name.contains(&quot;bad&quot;)) &#123; return true; &#125; &#125; return false;&#125; 改进后的代码，在name里面含有“bad”的时候，直接用return true返回，而不是对result变量赋值，break出去，最后才返回。如果循环结束了还没有return，那就返回false，表示没有找到这样的名字。使用return来代替break，这样break语句和result这个变量，都一并被消除掉了。 我曾经见过很多其他使用continue和break的例子，几乎无一例外的可以被消除掉，变换后的代码变得清晰很多。我的经验是，99%的break和continue，都可以通过替换成return语句，或者翻转if条件的方式来消除掉。剩下的1%含有复杂的逻辑，但也可以通过提取一个帮助函数来消除掉。修改之后的代码变得容易理解，容易确保正确。 写直观的代码我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。比如，Unix命令行有一种“巧妙”的写法是这样： 1command1 &amp;&amp; command2 &amp;&amp; command3 由于Shell语言的逻辑操作a &amp;&amp; b具有“短路”的特性，如果a等于false，那么b就没必要执行了。这就是为什么当command1成功，才会执行command2，当command2成功，才会执行command3。同样， 1command1 || command2 || command3 操作符||也有类似的特性。上面这个命令行，如果command1成功，那么command2和command3都不会被执行。如果command1失败，command2成功，那么command3就不会被执行。 这比起用if语句来判断失败，似乎更加巧妙和简洁，所以有人就借鉴了这种方式，在程序的代码里也使用这种方式。比如他们可能会写这样的代码： 123if (action1() || action2() &amp;&amp; action3()) &#123; ...&#125; 你看得出来这代码是想干什么吗？action2和action3什么条件下执行，什么条件下不执行？也许稍微想一下，你知道它在干什么：“如果action1失败了，执行action2，如果action2成功了，执行action3”。然而那种语义，并不是直接的“映射”在这代码上面的。比如“失败”这个词，对应了代码里的哪一个字呢？你找不出来，因为它包含在了||的语义里面，你需要知道||的短路特性，以及逻辑或的语义才能知道这里面在说“如果action1失败……”。每一次看到这行代码，你都需要思考一下，这样积累起来的负荷，就会让人很累。 其实，这种写法是滥用了逻辑操作&amp;&amp;和||的短路特性。这两个操作符可能不执行右边的表达式，原因是为了机器的执行效率，而不是为了给人提供这种“巧妙”的用法。这两个操作符的本意，只是作为逻辑操作，它们并不是拿来给你代替if语句的。也就是说，它们只是碰巧可以达到某些if语句的效果，但你不应该因此就用它来代替if语句。如果你这样做了，就会让代码晦涩难懂。 上面的代码写成笨一点的办法，就会清晰很多： 12345if (!action1()) &#123; if (action2()) &#123; action3(); &#125;&#125; 这里我很明显的看出这代码在说什么，想都不用想：如果action1()失败了，那么执行action2()，如果action2()成功了，执行action3()。你发现这里面的一一对应关系吗？if=如果，!=失败，…… 你不需要利用逻辑学知识，就知道它在说什么。 写无懈可击的代码在之前一节里，我提到了自己写的代码里面很少出现只有一个分支的if语句。我写出的if语句，大部分都有两个分支，所以我的代码很多看起来是这个样子： 12345678910111213if (...) &#123; if (...) &#123; ... return false; &#125; else &#123; return true; &#125;&#125; else if (...) &#123; ... return false;&#125; else &#123; return true;&#125; 使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。 很多人写if语句喜欢省略else的分支，因为他们觉得有些else分支的代码重复了。比如我的代码里，两个else分支都是return true。为了避免重复，他们省略掉那两个else分支，只在最后使用一个return true。这样，缺了else分支的if语句，控制流自动“掉下去”，到达最后的return true。他们的代码看起来像这个样子： 12345678910if (...) &#123; if (...) &#123; ... return false; &#125;&#125; else if (...) &#123; ... return false;&#125;return true; 这种写法看似更加简洁，避免了重复，然而却很容易出现疏忽和漏洞。嵌套的if语句省略了一些else，依靠语句的“控制流”来处理else的情况，是很难正确的分析和推理的。如果你的if条件里使用了&amp;&amp;和||之类的逻辑运算，就更难看出是否涵盖了所有的情况。 由于疏忽而漏掉的分支，全都会自动“掉下去”，最后返回意想不到的结果。即使你看一遍之后确信是正确的，每次读这段代码，你都不能确信它照顾了所有的情况，又得重新推理一遍。这简洁的写法，带来的是反复的，沉重的头脑开销。这就是所谓“面条代码”，因为程序的逻辑分支，不是像一棵枝叶分明的树，而是像面条一样绕来绕去。 另外一种省略else分支的情况是这样： 1234String s = &quot;&quot;;if (x &lt; 5) &#123; s = &quot;ok&quot;;&#125; 写这段代码的人，脑子里喜欢使用一种“缺省值”的做法。s缺省为null，如果x&lt;5，那么把它改变（mutate）成“ok”。这种写法的缺点是，当x&lt;5不成立的时候，你需要往上面看，才能知道s的值是什么。这还是你运气好的时候，因为s就在上面不远。很多人写这种代码的时候，s的初始值离判断语句有一定的距离，中间还有可能插入一些其它的逻辑和赋值操作。这样的代码，把变量改来改去的，看得人眼花，就容易出错。 现在比较一下我的写法： 123456String s;if (x &lt; 5) &#123; s = &quot;ok&quot;;&#125; else &#123; s = &quot;&quot;;&#125; 这种写法貌似多打了一两个字，然而它却更加清晰。这是因为我们明确的指出了x&lt;5不成立的时候，s的值是什么。它就摆在那里，它是&quot;&quot;（空字符串）。注意，虽然我也使用了赋值操作，然而我并没有“改变”s的值。s一开始的时候没有值，被赋值之后就再也没有变过。我的这种写法，通常被叫做更加“函数式”，因为我只赋值一次。 如果我漏写了else分支，Java编译器是不会放过我的。它会抱怨：“在某个分支，s没有被初始化。”这就强迫我清清楚楚的设定各种条件下s的值，不漏掉任何一种情况。 当然，由于这个情况比较简单，你还可以把它写成这样： 1String s = x &lt; 5 ? &quot;ok&quot; : &quot;&quot;; 对于更加复杂的情况，我建议还是写成if语句为好。 正确处理错误使用有两个分支的if语句，只是我的代码可以达到无懈可击的其中一个原因。这样写if语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。 程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。 错误处理是一个古老的问题，可是经过了几十年，还是很多人没搞明白。Unix的系统API手册，一般都会告诉你可能出现的返回值和错误信息。比如，Linux的read系统调用手册里面有如下内容： RETURN VALUE On success, the number of bytes read is returned... On error, -1 is returned, and errno is set appropriately. ERRORS EAGAIN, EBADF, EFAULT, EINTR, EINVAL, ... 很多初学者，都会忘记检查read的返回值是否为-1，觉得每次调用read都得检查返回值真繁琐，不检查貌似也相安无事。这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就必须要对这个-1作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。 对于Java来说，这相对方便一些。Java的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union类型”。比如： 123String foo() throws MyException &#123; ...&#125; 这里MyException是一个错误返回。你可以认为这个函数返回一个union类型：{String, MyException}。任何调用foo的代码，必须对MyException作出合理的处理，才有可能确保程序的正确运行。Union类型是一种相当先进的类型，目前只有极少数语言（比如Typed Racket）具有这种类型，我在这里提到它，只是为了方便解释概念。掌握了概念之后，你其实可以在头脑里实现一个union类型系统，这样使用普通的语言也能写出可靠的代码。 由于Java的类型系统强制要求函数在类型里面声明可能出现的异常，而且强制调用者处理可能出现的异常，所以基本上不可能出现由于疏忽而漏掉的情况。但有些Java程序员有一种恶习，使得这种安全机制几乎完全失效。每当编译器报错，说“你没有catch这个foo函数可能出现的异常”时，有些人想都不想，直接把代码改成这样： 123try &#123; foo();&#125; catch (Exception e) &#123;&#125; 或者最多在里面放个log，或者干脆把自己的函数类型上加上throws Exception，这样编译器就不再抱怨。这些做法貌似很省事，然而都是错误的，你终究会为此付出代价。 如果你把异常catch了，忽略掉，那么你就不知道foo其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。这当然迟早会出问题，因为你根本不知道自己在干什么。 catch异常的时候，你不应该使用Exception这么宽泛的类型。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，因为它会不经意的catch住另外的异常（比如B）。你的代码逻辑是基于判断A是否出现，可你却catch所有的异常（Exception类），所以当其它的异常B出现的时候，你的代码就会出现莫名其妙的问题，因为你以为A出现了，而其实它没有。这种bug，有时候甚至使用debugger都难以发现。 如果你在自己函数的类型加上throws Exception，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着throws Exception，这毛病就传得更远。我的经验是，尽量在异常出现的当时就作出处理。否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。 另外，try { … } catch里面，应该包含尽量少的代码。比如，如果foo和bar都可能产生异常A，你的代码应该尽可能写成： 1234567try &#123; foo();&#125; catch (A e) &#123;...&#125;try &#123; bar();&#125; catch (A e) &#123;...&#125; 而不是 1234try &#123; foo(); bar();&#125; catch (A e) &#123;...&#125; 第一种写法能明确的分辨是哪一个函数出了问题，而第二种写法全都混在一起。明确的分辨是哪一个函数出了问题，有很多的好处。比如，如果你的catch代码里面包含log，它可以提供给你更加精确的错误信息，这样会大大地加速你的调试过程。 正确处理null指针穷举的思想是如此的有用，依据这个原理，我们可以推出一些基本原则，它们可以让你无懈可击的处理null指针。 首先你应该知道，许多语言（C，C++，Java，C#，……）的类型系统对于null的处理，其实是完全错误的。这个错误源自于Tony Hoare最早的设计，Hoare把这个错误称为自己的“billion dollar mistake”，因为由于它所产生的财产和人力损失，远远超过十亿美元。 这些语言的类型系统允许null出现在任何对象（指针）类型可以出现的地方，然而null其实根本不是一个合法的对象。它不是一个String，不是一个Integer，也不是一个自定义的类。null的类型本来应该是NULL，也就是null自己。根据这个基本观点，我们推导出以下原则： 尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制。虽然写法上有点别扭，然而Java的异常，和函数的返回值合并在一起，基本上可以当成union类型来用。比如，如果你有一个函数find，可以帮你找到一个String，也有可能什么也找不到，你可以这样写： 1234567public String find() throws NotFoundException &#123; if (...) &#123; return ...; &#125; else &#123; throw new NotFoundException(); &#125;&#125; Java的类型系统会强制你catch这个NotFoundException，所以你不可能像漏掉检查null一样，漏掉这种情况。Java的异常也是一个比较容易滥用的东西，不过我已经在上一节告诉你如何正确的使用异常。 Java的try…catch语法相当的繁琐和蹩脚，所以如果你足够小心的话，像find这类函数，也可以返回null来表示“没找到”。这样稍微好看一些，因为你调用的时候不必用try…catch。很多人写的函数，返回null来表示“出错了”，这其实是对null的误用。“出错了”和“没有”，其实完全是两码事。“没有”是一种很常见，正常的情况，比如查哈希表没找到，很正常。“出错了”则表示罕见的情况，本来正常情况下都应该存在有意义的值，偶然出了问题。如果你的函数要表示“出错了”，应该使用异常，而不是null。 不要catch NullPointerException。有些人写代码很nice，他们喜欢“容错”。首先他们写一些函数，这些函数里面不大小心，没检查null指针： 12345void foo() &#123; String found = find(); int len = found.length(); ...&#125; 当foo调用产生了异常，他们不管三七二十一，就把调用的地方改成这样： 12345try &#123; foo();&#125; catch (Exception e) &#123; ...&#125; 这样当found是null的时候，NullPointerException就会被捕获并且得到处理。这其实是很错误的作法。首先，上一节已经提到了，catch (Exception e)这种写法是要绝对避免的，因为它捕获所有的异常，包括NullPointerException。这会让你意外地捕获try语句里面出现的NullPointerException，从而把代码的逻辑搅得一塌糊涂。 另外就算你写成catch (NullPointerException e)也是不可以的。由于foo的内部缺少了null检查，才出现了NullPointerException。现在你不对症下药，倒把每个调用它的地方加上catch，以后你的生活就会越来越苦。正确的做法应该是改动foo，而不改调用它的代码。foo应该被改成这样： 123456789void foo() &#123; String found = find(); if (found != null) &#123; int len = found.length(); ... &#125; else &#123; ... &#125;&#125; 在null可能出现的当时就检查它是否是null，然后进行相应的处理。 不要把null放进“容器数据结构”里面。所谓容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。 解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。 需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。比如： 1234class A &#123; String name = null; ...&#125; 之所以可以这样，是因为null只可能在A对象的name成员里出现，你不用怀疑其它的成员因此成为null。所以你每次访问name成员时，检查它是否是null就可以了，不需要对其他成员也做同样的检查。 函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播。null很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”。有时候它表示“出错了”，“失败了”。有时候它甚至可以表示“成功了”，…… 这其中有很多误用之处，不过无论如何，你必须理解每一个null的意义，不能给混淆起来。 如果你调用的函数有可能返回null，那么你应该在第一时间对null做出“有意义”的处理。比如，上述的函数find，返回null表示“没找到”，那么调用find的代码就应该在它返回的第一时间，检查返回值是否是null，并且对“没找到”这种情况，作出有意义的处理。 “有意义”是什么意思呢？我的意思是，使用这函数的人，应该明确的知道在拿到null的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。如果你违反了这一点，就有可能采用一种不负责任，危险的写法： 123456public String foo() &#123; String found = find(); if (found == null) &#123; return null; &#125;&#125; 当看到find()返回了null，foo自己也返回null。这样null就从一个地方，游走到了另一个地方，而且它表示另外一个意思。如果你不假思索就写出这样的代码，最后的结果就是代码里面随时随地都可能出现null。到后来为了保护自己，你的每个函数都会写成这样： 123456public void foo(A a, B b, C c) &#123; if (a == null) &#123; ... &#125; if (b == null) &#123; ... &#125; if (c == null) &#123; ... &#125; ...&#125; 函数作者：明确声明不接受null参数，当参数是null时立即崩溃。不要试图对null进行“容错”，不要让程序继续往下执行。如果调用者使用了null作为参数，那么调用者（而不是函数作者）应该对程序的崩溃负全责。 上面的例子之所以成为问题，就在于人们对于null的“容忍态度”。这种“保护式”的写法，试图“容错”，试图“优雅的处理null”，其结果是让调用者更加肆无忌惮的传递null给你的函数。到后来，你的代码里出现一堆堆nonsense的情况，null可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了null是什么意思，该做什么，所有人都把null踢给其他人。最后这null像瘟疫一样蔓延开来，到处都是，成为一场噩梦。 正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是null，如果你给我null，程序崩溃了该你自己负责。至于调用者代码里有null怎么办，他自己该知道怎么处理（参考以上几条），不应该由函数作者来操心。 采用强硬态度一个很简单的做法是使用Objects.requireNonNull()。它的定义很简单： 1234567public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) &#123; throw new NullPointerException(); &#125; else &#123; return obj; &#125;&#125; 你可以用这个函数来检查不想接受null的每一个参数，只要传进来的参数是null，就会立即触发NullPointerException崩溃掉，这样你就可以有效地防止null指针不知不觉传递到其它地方去。 使用@NotNull和@Nullable标记。IntelliJ提供了@NotNull和@Nullable两种标记，加在类型前面，这样可以比较简洁可靠地防止null指针的出现。IntelliJ本身会对含有这种标记的代码进行静态分析，指出运行时可能出现NullPointerException的地方。在运行时，会在null指针不该出现的地方产生IllegalArgumentException，即使那个null指针你从来没有deference。这样你可以在尽量早期发现并且防止null指针的出现。 使用Optional类型。Java 8和Swift之类的语言，提供了一种叫Optional的类型。正确的使用这种类型，可以在很大程度上避免null的问题。null指针的问题之所以存在，是因为你可以在没有“检查”null的情况下，“访问”对象的成员。 Optional类型的设计原理，就是把“检查”和“访问”这两个操作合二为一，成为一个“原子操作”。这样你没法只访问，而不进行检查。这种做法其实是ML，Haskell等语言里的模式匹配（pattern matching）的一个特例。模式匹配使得类型判断和访问成员这两种操作合二为一，所以你没法犯错。 比如，在Swift里面，你可以这样写： 1234let found = find()if let content = found &#123; print(&quot;found: &quot; + content)&#125; 你从find()函数得到一个Optional类型的值found。假设它的类型是String?，那个问号表示它可能包含一个String，也可能是nil。然后你就可以用一种特殊的if语句，同时进行null检查和访问其中的内容。这个if语句跟普通的if语句不一样，它的条件不是一个Bool，而是一个变量绑定let content = found。 我不是很喜欢这语法，不过这整个语句的含义是：如果found是nil，那么整个if语句被略过。如果它不是nil，那么变量content被绑定到found里面的值（unwrap操作），然后执行print(&quot;found: &quot; + content)。由于这种写法把检查和访问合并在了一起，你没法只进行访问而不检查。 Java 8的做法比较蹩脚一些。如果你得到一个Optional类型的值found，你必须使用“函数式编程”的方式，来写这之后的代码： 12Optional&lt;String&gt; found = find();found.ifPresent(content -&gt; System.out.println(&quot;found: &quot; + content)); 这段Java代码跟上面的Swift代码等价，它包含一个“判断”和一个“取值”操作。ifPresent先判断found是否有值（相当于判断是不是null）。如果有，那么将其内容“绑定”到lambda表达式的content参数（unwrap操作），然后执行lambda里面的内容，否则如果found没有内容，那么ifPresent里面的lambda不执行。 Java的这种设计有个问题。判断null之后分支里的内容，全都得写在lambda里面。在函数式编程里，这个lambda叫做“continuation”，Java把它叫做 “Consumer”，它表示“如果found不是null，拿到它的值，然后应该做什么”。由于lambda是个函数，你不能在里面写return语句返回出外层的函数。比如，如果你要改写下面这个函数（含有null）： 12345678public static String foo() &#123; String found = find(); if (found != null) &#123; return found; &#125; else &#123; return &quot;&quot;; &#125;&#125; 就会比较麻烦。因为如果你写成这样： 1234567public static String foo() &#123; Optional&lt;String&gt; found = find(); found.ifPresent(content -&gt; &#123; return content; // can&apos;t return from foo here &#125;); return &quot;&quot;;&#125; 里面的return a，并不能从函数foo返回出去。它只会从lambda返回，而且由于那个lambda（Consumer.accept）的返回类型必须是void，编译器会报错，说你返回了String。由于Java里closure的自由变量是只读的，你没法对lambda外面的变量进行赋值，所以你也不能采用这种写法： 12345678public static String foo() &#123; Optional&lt;String&gt; found = find(); String result = &quot;&quot;; found.ifPresent(content -&gt; &#123; result = content; // can&apos;t assign to result &#125;); return result;&#125; 所以，虽然你在lambda里面得到了found的内容，如何使用这个值，如何返回一个值，却让人摸不着头脑。你平时的那些Java编程手法，在这里几乎完全废掉了。实际上，判断null之后，你必须使用Java 8提供的一系列古怪的函数式编程操作：map, flatMap, orElse之类，想法把它们组合起来，才能表达出原来代码的意思。比如之前的代码，只能改写成这样： 1234public static String foo() &#123; Optional&lt;String&gt; found = find(); return found.orElse(&quot;&quot;);&#125; 这简单的情况还好。复杂一点的代码，我还真不知道怎么表达，我怀疑Java 8的Optional类型的方法，到底有没有提供足够的表达力。那里面少数几个东西表达能力不咋的，论工作原理，却可以扯到functor，continuation，甚至monad等高深的理论…… 仿佛用了Optional之后，这语言就不再是Java了一样。 所以Java虽然提供了Optional，但我觉得可用性其实比较低，难以被人接受。相比之下，Swift的设计更加简单直观，接近普通的过程式编程。你只需要记住一个特殊的语法if let content = found {...}，里面的代码写法，跟普通的过程式语言没有任何差别。 总之你只要记住，使用Optional类型，要点在于“原子操作”，使得null检查与取值合二为一。这要求你必须使用我刚才介绍的特殊写法。如果你违反了这一原则，把检查和取值分成两步做，还是有可能犯错误。比如在Java 8里面，你可以使用found.get()这样的方式直接访问found里面的内容。在Swift里你也可以使用found!来直接访问而不进行检查。 你可以写这样的Java代码来使用Optional类型： 1234Option&lt;String&gt; found = find();if (found.isPresent()) &#123; System.out.println(&quot;found: &quot; + found.get());&#125; 如果你使用这种方式，把检查和取值分成两步做，就可能会出现运行时错误。if (found.isPresent())本质上跟普通的null检查，其实没什么两样。如果你忘记判断found.isPresent()，直接进行found.get()，就会出现NoSuchElementException。这跟NullPointerException本质上是一回事。所以这种写法，比起普通的null的用法，其实换汤不换药。如果你要用Optional类型而得到它的益处，请务必遵循我之前介绍的“原子操作”写法。 防止过度工程人的脑子真是奇妙的东西。虽然大家都知道过度工程（over-engineering）不好，在实际的工程中却经常不由自主的出现过度工程。我自己也犯过好多次这种错误，所以觉得有必要分析一下，过度工程出现的信号和兆头，这样可以在初期的时候就及时发现并且避免。 过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”…… 这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，把手头的问题先搞定了，再谈以后扩展的问题。 另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。为了让代码可以重用，最后被自己搞出来的各种框架捆住手脚，最后连可用的代码就没写好。如果可用的代码都写不好，又何谈重用呢？很多一开头就考虑太多重用的工程，到后来被人完全抛弃，没人用了，因为别人发现这些代码太难懂了，自己从头开始写一个，反而省好多事。 过度地关心“测试”，也会引起过度工程。有些人为了测试，把本来很简单的代码改成“方便测试”的形式，结果引入很多复杂性，以至于本来一下就能写对的代码，最后复杂不堪，出现很多bug。 世界上有两种“没有bug”的代码。一种是“没有明显的bug的代码”，另一种是“明显没有bug的代码”。第一种情况，由于代码复杂不堪，加上很多测试，各种coverage，貌似测试都通过了，所以就认为代码是正确的。第二种情况，由于代码简单直接，就算没写很多测试，你一眼看去就知道它不可能有bug。你喜欢哪一种“没有bug”的代码呢？ 根据这些，我总结出来的防止过度工程的原则如下： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://smarxpan.github.io/tags/编程/"}]},{"title":"Android权限管理适配","slug":"Android权限视频适配管理","date":"2017-04-18T07:15:30.000Z","updated":"2018-12-17T07:58:26.163Z","comments":true,"path":"2017/04/18/Android权限视频适配管理/","link":"","permalink":"http://smarxpan.github.io/2017/04/18/Android权限视频适配管理/","excerpt":"","text":"Android权限管理适配Android权限管理的变动从Android6.0开始，权限分为普通权限和许可权限。许可权限分类归组，一个权限授权之后，该组下的权限均可使用。 普通权限 只需要在xml申请即可，使用方法和之前6.0以前的一样。在应用安装应用时，会默认获得许可。 许可权限 当指定target&gt;=23时（Android6.0），需要开发者手动申请以下权限，如果没有手动申请，应用就不会获得这些权限 Permission Group|Permissions :–|:–| android.permission-group.CALENDAR |android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR android.permission-group.CAMERA |android.permission.CAMERA android.permission-group.CONTACTS |android.permission.READ_CONTACTSandroid.permission.WRITE_CONTACTSandroid.permission.GET_ACCOUNTS android.permission-group.LOCATION |android.permission.ACCESS_FINE_LOCATIONandroid.permission.ACCESS_COARSE_LOCATION android.permission-group.MICROPHONE|ndroid.permission.RECORD_AUDIO android.permission-group.PHONE|android.permission.READ_PHONE_STATEandroid.permission.CALL_PHONEandroid.permission.READ_CALL_LOGandroid.permission.WRITE_CALL_LOGcom.android.voicemail.permission.ADD_VOICEMAILandroid.permission.USE_SIPandroid.permission.PROCESS_OUTGOING_CALLS android.permission-group.SENSORS|android.permission.BODY_SENSORS android.permission-group.SMS|android.permission.SEND_SMSandroid.permission.RECEIVE_SMSandroid.permission.READ_SMSandroid.permission.RECEIVE_WAP_PUSHandroid.permission.RECEIVE_MMSandroid.permission.READ_CELL_BROADCASTS android.permission-group.STORAGE| android.permission.READ_EXTERNAL_STORAGEandroid.permission.WRITE_EXTERNAL_STORAGE 动态权限的适配较为麻烦 短信相关修改短信的权限，WRITE_SMS权限， 这个权限从Android4.4开始，Google已经不允许第三方应用使用该权限，但是仅隐藏了相关api，还是可以反射调用，从5.0才开始做了签名和权限的限制。因此5.0之后的手机除部分定制rom的厂商（比如小米、魅族、360OS）外，均无法删除短信。 关于MIUIMIUI系统订制内容较多，权限管理机制与官方差异很大。 短信相关的有通知类短信和删除短信的行为与官方不同。MIUI将短信分为普通短信与通知类短信，短信权限仅对普通短信生效，通知类短信的权限不对外提供，系统会默认拒绝。而验证码短信基本都是通知类短信，因此需要提醒用户开启。 /** * 跳转到MIUI应用权限设置页面 * * @param context context */ public static void jumpToMiuiPermissionEditorActivity(Context context) { try { // MIUI 8 Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;); localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName()); context.startActivity(localIntent); } catch (ActivityNotFoundException e) { try { // MIUI 5/6/7 Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;); localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName()); context.startActivity(localIntent); } catch (Exception e1) { Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(&quot;package&quot;, context.getPackageName(), null); intent.setData(uri); context.startActivity(intent); } } } MIUI的删除短信权限并未隐藏，还可以请求修改短信的权限来删除短信。 Android7.0出现FileUriExposedException当target指定为25时，如果给出一个file://格式的URI的话，应用会抛出FileUriExposedException。有三种解决方案： target设置为小于25的值 VmPolicy方式 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder(); StrictMode.setVmPolicy(builder.build()); } 放置一个不设防的VmPolicy，不检验uri FileProvider方式 替换 file://uri 为 content://uri: 增加FileProvider在 AndroidManifest.xml中 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ... &lt;application ... &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;${applicationId}.provider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/provider_paths&quot;/&gt; &lt;/provider&gt; &lt;/application&gt; &lt;/manifest&gt; 编写file_paths.xml &lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;files-path name=&quot;my_images&quot; path=&quot;images/&quot;/&gt; ... &lt;/paths&gt; 内部的element可以是files-path，cache-path，external-path，external-files-path，external-cache-path，分别对应Context.getFilesDir()，Context.getCacheDir()，Environment.getExternalStorageDirectory()，Context.getExternalFilesDir()，Context.getExternalCacheDir()等几个方法。 使用示例： Uri photoURI = FileProvider.getUriForFile(context, context.getApplicationContext().getPackageName() + &quot;.provider&quot;, createImageFile());","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"MIUI跳转至权限设置页面","slug":"MIUI跳转至权限设置页面","date":"2017-04-13T07:15:30.000Z","updated":"2018-12-17T07:58:05.204Z","comments":true,"path":"2017/04/13/MIUI跳转至权限设置页面/","link":"","permalink":"http://smarxpan.github.io/2017/04/13/MIUI跳转至权限设置页面/","excerpt":"","text":"网上基本只有比较古老的MIUI5/6的跳转方式： Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;); localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName()); context.startActivity(localIntent); 这种方式已经不能满足如今的新版MIUI，所以，自己动手丰衣足食 电脑打开cmd/terminal， 手机打开应用权限设置页面： 命令行输入： adb shell dumpsys activity | grep &quot;mFocusedActivity&quot; 输入结果： mFocusedActivity: ActivityRecord{11ae2ef u0 com.miui.securitycenter/com.miui.permcenter.permissions.PermissionsEditorActivity t192} 即为当前打开的权限设置页的Activity 观察到Activity包名与MIUI 5/6的相同，Activity名字不同，将跳转代码改为： // MIUI 7/8 Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;); localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName()); context.startActivity(localIntent); 成功跳转。 完整的工具类如下： public class MiuiUtils { /** * 跳转到MIUI应用权限设置页面 * * @param context context */ public static void jumpToPermissionSettings(Context context) { if (isMIUI()) { try { // MIUI 7/8 Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.PermissionsEditorActivity&quot;); localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName()); context.startActivity(localIntent); } catch (Exception e) { try { // MIUI 5/6 Intent localIntent = new Intent(&quot;miui.intent.action.APP_PERM_EDITOR&quot;); localIntent.setClassName(&quot;com.miui.securitycenter&quot;, &quot;com.miui.permcenter.permissions.AppPermissionsEditorActivity&quot;); localIntent.putExtra(&quot;extra_pkgname&quot;, context.getPackageName()); context.startActivity(localIntent); } catch (Exception e1) { // 否则跳转到应用详情 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(&quot;package&quot;, context.getPackageName(), null); intent.setData(uri); context.startActivity(intent); } } } } /** * 判断是否是MIUI */ private static boolean isMIUI() { String device = Build.MANUFACTURER; if (device.equals(&quot;Xiaomi&quot;)) { try { Properties prop = new Properties(); prop.load(new FileInputStream(new File(Environment.getRootDirectory(), &quot;build.prop&quot;))); return prop.getProperty(&quot;ro.miui.ui.version.code&quot;, null) != null || prop.getProperty(&quot;ro.miui.ui.version.name&quot;, null) != null || prop.getProperty(&quot;ro.miui.internal.storage&quot;, null) != null; } catch (IOException e) { e.printStackTrace(); } } return false; } }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"Looper解析","slug":"Looper的有趣问题","date":"2017-03-22T07:15:30.000Z","updated":"2018-12-14T12:59:01.129Z","comments":true,"path":"2017/03/22/Looper的有趣问题/","link":"","permalink":"http://smarxpan.github.io/2017/03/22/Looper的有趣问题/","excerpt":"","text":"Looper解析正确的主线程运行代码一个回调 public interface MyCallback { void onSuccess(String result); } 创建主线程的Handler，然后将回调post到主线程执行 public class SubThreadTest { static Handler handler = new Handler(Looper.getMainLooper()); public static void mockRequest(final String url, final MyCallback callback){ handler.post(new Runnable() { @Override public void run() { callback.onSuccess(url); } }); } } 调用过程 public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() { @Override public void run() { SubThreadTest.mockRequest(&quot;heheda&quot;, new MyCallback() { @Override public void onSuccess(String result) { System.out.println(Thread.currentThread().getName()+&quot; : &quot;+result); Toast.makeText(getApplicationContext(), result, 0).show(); } }); try { Thread.sleep(500); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } Looper.prepare(); System.out.println(Thread.currentThread().getName()+&quot; : &quot;); Toast.makeText(getApplicationContext(), &quot;result&quot;, 0).show(); TextView findViewById = (TextView) findViewById(R.id.tv); findViewById.setText(&quot;heheda&quot;); Looper.loop(); } }).start(); } } 一个有趣的问题public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(500); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } Looper.prepare(); System.out.println(Thread.currentThread().getName()+&quot; : &quot;); Toast.makeText(getApplicationContext(), &quot;result&quot;, 0).show(); TextView findViewById = (TextView) findViewById(R.id.tv); findViewById.setText(&quot;heheda&quot;); Looper.loop(); } }).start(); } } 子线程中其实可以弹Toast，只是需要使用Looper，而设置TextView却不行 待查看源码了解","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"Mac使用指南","slug":"Mac使用指南","date":"2017-02-04T07:15:30.000Z","updated":"2018-12-17T07:58:31.359Z","comments":true,"path":"2017/02/04/Mac使用指南/","link":"","permalink":"http://smarxpan.github.io/2017/02/04/Mac使用指南/","excerpt":"","text":"Mac使用指南之前购入mac时，整理了一篇Mac使用指南，部分内容来自强迫症的 Mac 设置指南。 系统设置功能键默认情况下，F1-F12 都是特殊功能，比如调节屏幕亮度。而当你需要键入 F1-F12 时（比如在使用 IntelliJ IDEA 的快捷键时），需要同时按住 Fn。这对于开发人员来说是非常不方便的。 在系统偏好设置-&gt;键盘-&gt;键盘中，选择将F1、F2等键用作基本功能键 对于新款带有Multi Touch Bar的macbook，此条并不适用 全键盘控制当你清理废纸篓时会遇到这样的对话框 按回车后会清理废纸篓，但是想要通过键盘控制取消却不可以，只能鼠标点击取消。 在系统偏好设置-&gt;键盘中，快捷键选项卡中选择所有控制，弹框会变成这样： 取消选项上就出现了蓝色边框，这时就可以通过空格键选择该选项，可以通过tab键切换选项 触摸板和鼠标设置系统偏好设置-&gt;触摸板、系统偏好设置-&gt;鼠标，里面所有的选项，除了静默点按不需要勾选，所有的选项都勾选，那些选项提供了很多快捷操作 更改Caps Lock键为Control键我本人总是使用按住Shift的方式输入大写，或者使用快捷键转换大写，基本用不掉Caps Lock键，因此将其转换为更常用的Control 在系统偏好设置-&gt;键盘-&gt;键盘中， 选择修饰键...， 大写锁定键下拉框中选择Control 允许安装任何来源的软件为了不受限制的安装软件，需要设置系统偏好设置-&gt;安全与隐私中，选择任何来源 新的macOS系统中，将安全与隐私中的任何来源隐藏了，需要在终端执行以下命令： sudo spctl --master-disable 这一步需要输入管理员密码，输入时密码不可见。 然后就能在安全与隐私中看到任何来源选项了。 显示隐藏文件夹打开“终端”，执行下面两行命令： defaults write com.apple.finder AppleShowAllFiles -bool true KillAll Finder 这样就可以默认显示隐藏文件夹，如果不想显示隐藏文件夹： defaults write com.apple.finder AppleShowAllFiles -bool false KillAll Finder 文件夹上方显示文件夹路径 终端中执行： defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES 常用快捷键Mac官方快捷键文档地址：https://support.apple.com/zh-cn/HT201236 下面特别提几个我最常用的几个操作： 文件操作 复制文件 Command + C 粘贴文件 Command + V 剪切（移动文件） Command + C，然后进入你想移动到的文件夹，Command + Option + V 删除文件 Command + Delete，清空回收站是Command + Shift + Delete 设置打开文件默认打开方式 使用Command + i呼出文件信息，看到“打开方式”，下拉框中选用想用的应用，选择好后点击“全部更改” 使用应用使用Mac上的各种应用时，一般是不需要将其最小化的，用到时用各种快捷键或者Misson Control切换来切换去，不想用时直接Cmd+Q关掉 切换应用 Command + tab，切换同一应用的不同窗口是Command + ` 关闭应用 Command + W 退出应用 Command + Q 呼出Spotlight搜索 Command + Space， 这是呼出搜索框，Mac上的搜索框很强大，可搜索文件、应用，离开这个功能简直活不下去（我隐藏了Dock栏，打开应用一般全用这个）。 调用Mission Control 触摸板三指上滑或者Control + ↑ 编辑操作编辑文件时的操作 删除当前行光标前的内容 Command + Delete 删除当前行光标后的内容 Control + K 光标移动至行首 Command + ←，此组合加入shift，Command + Shift + ←即为选中内容至行首 光标移动至行尾 Command + → 按单词移动光标 Option + →或Option + ←，同理，加入shift键即可按单词选中内容 授人以渔这么多快捷键，记不住怎么办？ 不要紧，记不住可以打小抄啊~ Mac上有这么个神器，帮你打小抄–CheatSheet。记不住看一眼小抄你就知道了。 官网地址：https://www.mediaatelier.com/CheatSheet/ 使用很简单，在任意应用中长按Command既可。 必备软件压缩、解压文件压缩文件可以直接右键压缩 解压文件才是我们日常使用的痛点，mac本身仅支持zip格式 这里推荐两款软件： The Unarchriver，直接去AppStore下载既可，免费的解压软件，支持格式众多，但是仅支持解压，不能压缩 keka，去官网下载免费：http://www.kekaosx.com/en/，支持压缩，需要打开软件，将要压缩的文件或文件夹拖进来即可以 CheatSheetCheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按⌘。 官网地址：https://www.mediaatelier.com/CheatSheet/ HomeBrewMac上的包管理工具，相当于Ubuntu上的apt，CentOS上的yum，用于安装各种开发环境，省去折腾开发环境的烦恼。 安装方式见官网：http://brew.sh/ Homebrew Cask使用各种命令行安装软件 官网地址：https://caskroom.github.io/ 例如安装Chrome： brew cask install google-chrome 常用应用都可以在上面找到，如果不知道应用id，可以搜索： brew cask search 应用名 iTerm2iTerm2 是最常用的终端应用，是 Terminal 应用的替代品。 安装： brew cask install iterm2 比Terminal强大的终端，具体使用可自行查找教程 Go2Shell在当前文件夹中打开命令行，安装方式： brew cask install go2shell 安装完成后文件夹上方会出现这个图标： 点击即可在当前文件夹打开命令行，可以打开应用设置默认打开的命令行是Terminal还是iTerm2 Oh My Zsh默认是shell是bash，zsh意为zshell，意味着终极shell，但是设置非常麻烦，直到Oh My Zsh出现，大大简化其设置。zsh拥有许多插件，让你的终端进入彩色时代，并且更为变得强大 安装方法见官网：http://ohmyz.sh/ MacDownMarkDown写作必备，Mac上最好的MarkDown写作工具。 安装： brew cask install macdown Sublime Text非常棒的文本编辑器，前端开发人员必备。 安装方式： brew cask install sublime-text LastPassLastPass 是管理密码的工具，支持二次验证，提供所有浏览器插件以及 Mac 桌面版本。 官网地址：https://lastpass.com/ CleanMyMac等同于Mac上的360，提供了卸载器、系统清理等常用功能，这个是付费软件，欢迎支持正版。 参考链接 https://github.com/macdao/ocds-guide-to-setting-up-mac#%E5%8A%9F%E8%83%BD%E9%94%AE","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://smarxpan.github.io/tags/Mac/"}]},{"title":"Mac设置开机启动","slug":"Mac设置开机启动","date":"2017-01-28T07:15:30.000Z","updated":"2018-12-14T12:57:34.483Z","comments":true,"path":"2017/01/28/Mac设置开机启动/","link":"","permalink":"http://smarxpan.github.io/2017/01/28/Mac设置开机启动/","excerpt":"","text":"Mac设置开机启动 本文针对命令行使用的开发工具或自己编写的脚本设置开机启动，图形化界面的程序仅需要设置-&gt;用户与群组-&gt;登录项中即可配置。 相比于Linux开机启动设置的简单方便–配置rc.local文件即可，mac设置开机启动略显麻烦。 如果是使用homebrew安装软件自然不用考虑开机启动这回事，但有时候想执行自己的脚本或者有特殊需求，就不得不自己处理开机启动了。 1. 使用登录项添加可执行脚本（推荐）在用户的家目录编写一个sh脚本，例如： test.sh #!/bin/bash # 在用户的家目录创建一个文件 touch ~/haha.txt 添加可执行权限 chmod 755 test.sh 进入设置-&gt;用户与群组-&gt;登录项，点+号，选择test.sh文件即可。 重启电脑，验证是否新建了文件，如存在说明配置成功，修改该文件内容为你想要的配置。 该文件将会在开机时执行，可在命令行中执行的开机启动项均可在此文件中配置。 PS: 开机后会显示一个“进程已结束”的终端，不太爽，需要进入终端的偏好设置-&gt;shell选项卡-&gt;当shell退出时, 选择“关闭窗口”。这样开机时就不会出现一个终端了 2. launchctl加载plist文件macOS开机启动一般使用launchctl加载plist文件 plist文件放置处： ~/Library/LaunchAgents 由用户自己定义的任务项 /Library/LaunchAgents 由管理员为用户定义的任务项 /Library/LaunchDaemons 由管理员定义的守护进程任务项 /System/Library/LaunchAgents 由Mac OS X为用户定义的任务项 /System/Library/LaunchDaemons 由Mac OS X定义的守护进程任务项 建议放在 ~/Library/LaunchAgents 下面。 下面再来理解几个基础概念： /System/Library和/Library和~/Library目录的区别？ /System/Library目录是存放Apple自己开发的软件。 /Library目录是系统管理员存放的第三方软件。 ~/Library/是用户自己存放的第三方软件。 LaunchDaemons和LaunchAgents的区别？ LaunchDaemons是用户未登陆前就启动的服务（守护进程）。 LaunchAgents是用户登陆后启动的服务（守护进程）。 plist文件示例 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd &gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.example.exampled&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;exampled&lt;/string&gt; &lt;/array&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; launchd.plist的部分键值说明，完整版见launchd.plist(5) Label (必须) 该项服务的名称 ProgramArguments 指定可执行文件路径及其参数，比如执行ls -a，对应到该配置中，应该写作： &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;ls&lt;/string&gt; &lt;string&gt;-a&lt;/string&gt; &lt;/array&gt; RunAtLoad (可选) 标识launchd在加载完该项服务之后立即启动路径指定的可执行文件。默认值为 false,设置为 true 即可实现开机运行脚本文件。 StartCalendarInterval (可选) 该关键字可以用来设置定时执行可执行程序，可使用 Month, Day, Hour, Minute, Second等子关键字，它可以指定脚本在多少月，天，小时，分钟，秒，星期几等时间上执行，若缺少某个关键字则表示任意该时间点，类似于 Unix 的 Crontab 计划任务的设置方式，比如在该例子中设置为每小时的20分的时候执行该命令。 KeepAlive（可选） 是否保持持续运行 所有key关键字详细使用说明可以在Mac OS X终端下使用命令 man launchd.plist 查询 修改 plist 文件权限 sudo chown root:wheel ~/Library/LaunchAgents/example.plist sudo chmod 644 ~/Library/LaunchAgents/example.plist 生效配置 # 载入配置 sudo launchctl load ~/Library/LaunchAgents/example.plist # 卸载配置 sudo launchctl unload ~/Library/LaunchAgents/example.plist # 检查语法是否正确 plutil ~/Library/LaunchAgents/example.plist # 查看服务运行状态 sudo launchctl list","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://smarxpan.github.io/tags/Mac/"}]},{"title":"Rails学习笔记","slug":"Rails学习笔记","date":"2017-01-23T07:15:30.000Z","updated":"2018-12-18T01:42:48.704Z","comments":true,"path":"2017/01/23/Rails学习笔记/","link":"","permalink":"http://smarxpan.github.io/2017/01/23/Rails学习笔记/","excerpt":"","text":"Rails学习笔记git操作使用 Git 之前，要做些一次性设置。这些设置对整个系统都有效，因此一台电脑只需设置一次： git config --global user.name &quot;Your Name&quot; git config --global user.email your.email@example.com 初始化一个新仓库： git init 把项目中的所有文件都放到仓库中： git add -A 提交： git commit -m &quot;Initialize repository&quot; 提交已加入版本控制文件的全部改动： git commit -am &quot;message&quot; 检查状态 git status 强制撤销未提交的改动： git checkout -f 添加至远程仓库，然后首次推送： git remote add origin git@bitbucket.org:&lt;username&gt;/hello_app.git git push -u origin --all 之后的推送只要git push即可 分支操作 # 查看分支 git branch # 查看所有分支（包含远程） git branch -a # 合并分支 git merge branch_name # 删除本地分支 git branch --delete branch_name # 删除远程分支 git push origin --delete branch_name # 创建并切换到该分支 git checkout -b xxx 撤销操作一般来说，下面这两个命令是相互抵消的： rails generate controller StaticPages home help rails destroy controller StaticPages home help # 生成Model rails generate model User name:string email:string # 删除Model rails destroy model User 数据库 # 数据迁移 rails db:migrate # 回滚 rails db:rollback # 回到最开始的状态 rails db:migrate VERSION=0 把数字 0 换成其他数字就会回到相应的版本，这些版本数字是按照迁移执行的顺序排列的。 Rails内建环境Rails 内建了三个环境，分别是测试环境、开发环境和生产环境。Rails 控制台默认使用的是开发环境： $ rails console Loading development environment &gt;&gt; Rails.env =&gt; &quot;development&quot; Rails 本地服务器和控制台一样，默认使用开发环境，不过也可以在其他环境中运行： $ rails server --environment production 如果想在生产环境中运行应用，要先有一个生产数据库。在生产环境中执行 rails db:migrate 命令可以生成这个数据库： $ rails db:migrate RAILS_ENV=production 把应用部署到 Heroku 后，可以使用 heroku run console 命令进入控制台查看所用的环境： $ heroku run console &gt;&gt; Rails.env =&gt; &quot;production&quot; 账户持久会话设计方案 生成随机字符串，用作记忆令牌； 把这个令牌存入浏览器的 cookie 中，并把过期时间设为未来的某个日期； 在数据库中存储令牌的摘要； 在浏览器的 cookie 中存储加密后的用户 ID； 如果 cookie 中有用户的 ID，就用这个 ID 在数据库中查找用户，并且检查 cookie 中的记忆令牌和数据库中的哈希摘要是否匹配。 部署heroku部署到 Heroku 之前要注意一个问题：推送之后，迁移完成之前，应用基本上处于不可用状态。在拥有巨大流量的线上网站中，更新前最好开启维护模式： $ heroku maintenance:on $ git push heroku $ heroku run rails db:migrate $ heroku maintenance:off","categories":[],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://smarxpan.github.io/tags/Rails/"}]},{"title":"heroku安装及部署rails项目教程","slug":"rails项目部署heroku教程","date":"2017-01-17T07:15:30.000Z","updated":"2018-12-18T01:42:39.236Z","comments":true,"path":"2017/01/17/rails项目部署heroku教程/","link":"","permalink":"http://smarxpan.github.io/2017/01/17/rails项目部署heroku教程/","excerpt":"","text":"heroku安装及部署rails项目教程开发了一个带数据库的小项目，部署至heroku看看效果。 安装macOS安装： brew install heroku 其他系统安装参见heroku官网 检查是否安装好： heroku version 确认 Heroku 命令行工具已经安装之后，使用 heroku 命令登录，然后添加 SSH 密钥： heroku login heroku keys:add 如果没有ssh key，请先生成 SSH 公钥 部署前准备1. 将项目添加至git进入项目目录，初始化git git init 然后执行 git add -A 命令，把项目中的所有文件都放到仓库中： git add -A 提交： git commit -m &quot;Initialize repository&quot; 这里的提交仅仅将代码提交到了本地，一般都会提交至服务端，这里我用了 Bitbucket，这是一个专门用来托管和分享 Git 仓库的网站 提交远程仓库之前要做下面三件事： 如果没有账户，先注册一个 Bitbucket 账户； 添加公钥到账户控制中 创建一个仓库 建好远程仓库后，需要将本地项目与远程仓库关联： git remote add origin git@bitbucket.org:&lt;username&gt;/&lt;project&gt;.git 提交本地项目 git push -u origin --all 2. 修改 Gemfile本地数据库使用的是sqlite，heroku不支持sqlite，因此需要配置对生产环境进行一些设置。 Gemfile中配置 group :development, :test do # Call &apos;byebug&apos; anywhere in the code to stop execution and get a debugger console gem &apos;byebug&apos;, platform: :mri # sqlite数据库移动到里 gem &apos;sqlite3&apos; end # 添加production组，内部配置postgresql的插件 group :production do gem &apos;pg&apos;, &apos;0.18.4&apos; end 修改完后需要运行 bundle install --without production 然后，提交这次改动： git commit -a -m &quot;Update Gemfile for Heroku&quot; 部署并迁移数据在 Heroku 中创建一个新应用，在项目目录运行 heroku create 部署 git push heroku master 创建postgresql数据库 heroku addons:create heroku-postgresql:hobby-dev 查找数据库地址 heroku config -s | grep HEROKU_POSTGRESQL 将这个地址粘贴出来，修改database.yml中的生产环境配置 production: adapter: postgresql encoding: unicode database: postgres://xxxxxxx pool: 5 timeout: 5000 运行数据迁移 # 数据迁移 heroku run rake db:migrate # 插入测试数据 heroku run rake db:seed 打开项目页面 heroku open 至此，部署彻底完成","categories":[],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://smarxpan.github.io/tags/Rails/"}]},{"title":"rails安装指南","slug":"rails安装指南","date":"2017-01-05T07:15:30.000Z","updated":"2018-12-18T01:42:53.419Z","comments":true,"path":"2017/01/05/rails安装指南/","link":"","permalink":"http://smarxpan.github.io/2017/01/05/rails安装指南/","excerpt":"","text":"Rails安装指南介绍 Mac、linux、windows 安装 rails 的方式 windows 安装 rails就别瞎折腾了，直接使用 RailsInstaller 一键安装包 官网地址：http://railsinstaller.org/en 安装完成后，rails极可能用不了，需要命令行执行 gem update --system &amp;&amp; gem update --no-document 当然，windows 部分的教程并没有到此结束，请直接跳到后面配置 RubyGems 镜像的教程。 *nix安装railsMac和Linux安装方式基本相同，此处我使用rbenv来安装，rbenv是管理多个ruby版本的工具，可以很方便的切换ruby的版本。 注意：尽量不要在root用户安装rails，要在普通用户安装 1. 安装rbenv首先安装git，已安装跳过此步 # mac brew install git # centos yum install git # ubuntu apt-get install git 然后安装rbenv # 安装rbenv到~/.rbenv目录 git clone git://github.com/sstephenson/rbenv.git ~/.rbenv 下面安装一些rbenv的插件 # 用来编译安装 ruby git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build # 用来管理 gemset, 可选, 因为有 bundler 也没什么必要 git clone git://github.com/jamis/rbenv-gemset.git ~/.rbenv/plugins/rbenv-gemset # 通过 gem 命令安装完 gem 后无需手动输入 rbenv rehash 命令, 推荐 git clone git://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash # 通过 rbenv update 命令来更新 rbenv 以及所有插件, 推荐 git clone git://github.com/rkh/rbenv-update.git ~/.rbenv/plugins/rbenv-update # 使用 Ruby China 的镜像安装 Ruby, 国内用户推荐 git clone git://github.com/AndorChen/rbenv-china-mirror.git ~/.rbenv/plugins/rbenv-china-mirror 然后需要将下面两句代码放在bash的配置文件中： export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot; eval &quot;$(rbenv init -)&quot; linux是一般是放在~/.bashrc中，mac是放在~/.bash_profile中 修改完成后，执行下面的命令使其生效 # linux source ~/.bashrc # mac source ~/.bash_profile 2. 安装rubyrbenv install --list # 列出所有 ruby 版本 例如安装2.3.3： rbenv install 2.3.3 设置使用的ruby版本, 有以下三种设置方式 rbenv global 2.3.3 # 默认使用2.3.3 rbenv shell 2.3.3 # 当前的 shell 使用2.3.3, 会设置一个 `RBENV_VERSION` 环境变量 rbenv local 2.3.3 # 当前目录使用2.3.3, 会生成一个 `.rbenv-version` 文件 3. 安装rails设置ruby版本后，安装rails： # 在当前的ruby版本中安装rails gem install rails 好了，这样就完成了rails的安装，rails已经可以使用了，但是为了更好的使用，请继续看后面的教程。 配置RubyGems镜像gem是ruby管理依赖包的工具，而RubyGems的默认地址因为万恶的墙的关系很难访问到，因此需要配置RubyGems 镜像。这里使用的是Ruby China的镜像地址 命令行输入 gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 可以通过下面这个命令查看设置的结果是不是https://gems.ruby-china.org： gem sources -l 对于Windows系统，会报下面这个错误： Error fetching https://gems.ruby-china.org/: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://gems.ruby-china.org/specs.4.8.gz) 报这个错的原因是 RailsInstaller 安装的 ruby 没有包含 SSL 证书，所以 https 的链接被服务器拒绝。 解决方法为： 下载证书文件 http://curl.haxx.se/ca/cacert.pem 然后设置 SSL_CERT_FILE 环境变量，变量值为cacert.pem文件的路径。 修改bundle的源地址bundler是rails管理gem依赖的工具，同样的，也需要修改其地址为ruby china的镜像 命令行输入 bundle config mirror.https://rubygems.org https://gems.ruby-china.org 至此，rails安装完成，下一步可以去学习Ruby on Rails 指南或者Ruby on Rails 教程","categories":[],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://smarxpan.github.io/tags/Rails/"}]},{"title":"Mac安装PostgreSQL","slug":"Mac安装PostgreSQL","date":"2017-01-04T07:15:30.000Z","updated":"2018-12-14T12:53:54.370Z","comments":true,"path":"2017/01/04/Mac安装PostgreSQL/","link":"","permalink":"http://smarxpan.github.io/2017/01/04/Mac安装PostgreSQL/","excerpt":"","text":"Mac安装PostgreSQL最近在学习rails，记录下安装psql的过程 安装及初始化这里使用homebrew安装 brew install postgresql 等待安装完成后，初始化： initdb /usr/local/var/postgres 启动服务： pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start 创建数据库和账户mac安装postgresql后不会创建用户名数据库，执行命令： createdb 然后登录PostgreSQL控制台： psql 使用\\l命令列出所有的数据库，看到已存在用户同名数据库、postgres数据库，但是postgres数据库的所有者是当前用户，没有postgres用户。按:q退出查看 之后需要做以下几件事： 创建postgres用户 CREATE USER postgres WITH PASSWORD &apos;password&apos;; 删除默认生成的postgres数据库 DROP DATABASE postgres; 创建属于postgres用户的postgres数据库 CREATE DATABASE postgres OWNER postgres; 将数据库所有权限赋予postgres用户 GRANT ALL PRIVILEGES ON DATABASE postgres to postgres; 给postgres用户添加创建数据库的属性 CREATE ROLE postgres CREATEDB; 这样就可以使用postgres作为数据库的登录用户了，并可以使用该用户管理数据库 配置开机启动编辑.bash_profile文件 vim ~/.bash_profile 按i进入插入模式，粘贴启动服务的命令到文件中： pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start 登录控制台指令psql -U [user] -d [database] -h [host] -p [post] -U指定用户，-d指定数据库，-h指定服务器，-p指定端口 上方直接使用psql登录控制台，实际上使用的是缺省数据 user：当前mac用户 database：用户同名数据库 主机：localhost 端口号：5432，postgresql的默认端口是5432 完整的登录命令，比如使用postgres用户登录 psql -U postgres -d postgres 常用控制台命令\\h：查看SQL命令的解释，比如\\h select。 \\?：查看psql命令列表。 \\l：列出所有数据库。 \\c [database_name]：连接其他数据库。 \\d：列出当前数据库的所有表格。 \\d [table_name]：列出某一张表格的结构。 \\du：列出所有用户。 \\e：打开文本编辑器。 \\conninfo：列出当前数据库和连接的信息。 \\password [user]: 修改用户密码 \\q：退出","categories":[],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://smarxpan.github.io/tags/Rails/"}]},{"title":"Linux使用指南","slug":"Linux使用指南","date":"2016-11-15T07:15:30.000Z","updated":"2018-12-14T12:58:22.211Z","comments":true,"path":"2016/11/15/Linux使用指南/","link":"","permalink":"http://smarxpan.github.io/2016/11/15/Linux使用指南/","excerpt":"","text":"Linux使用指南安装篇先要有个linux才能使用，其中有以下几种比较简单的方式可以快速拥有linux 安装SecureCRT、Xshell、putty等模拟终端连接远程linux 其中推荐使用SecureCrt, 安装并激活，相信你可以搞定的。 通过虚拟机安装 推荐安装VirtualBox虚拟机软件（点击下载），下载Ubuntu镜像（点击下载），安装教程如下： http://www.xuzefeng.com/post/84.html，虽然与教程中的版本不一样，但安装方式大同小异 这里安装的是Ubuntu，这个系统是有图形化界面的，不是纯命令行的，方便新手学习使用。与CentOS没有太大区别，仅仅安装软件的命令不太一样。 日常使用篇打开目录(cd命令)cd path 使用示例 cd /etc cd root 此处需要懂得一个小知识：绝对路径和相对路径。”/“开头的是绝对路径，不加斜杠的是相对路径，也就是相对于当前路径以下的路径。 思考题：返回上一层的命令是cd ..， 那么返回上上一层呢？ 查看当前路径的文件(ls命令)一般习惯使用ll命令，也就是ls -l命令查看当前路径的文件 查看全部文件（包含隐藏文件） ls -a 复制文件或文件夹（cp命令）复制文件 cp file path cp file new_file 复制文件夹 cp -a folder path cp -a folder new_folder 使用示例： cp hehe.txt /root #复制当前目录的hehe.txt到root目录下 cp /root/hehe.txt /home #复制root目录的hehe.txt到home目录 cp hehe.txt lala.txt #复制hehe.txt为lala.txt cp -a /home /root #复制home目录及其内部所有文件到root目录 移动文件（mv命令）mv file path mv folder path 删除文件（rm命令）rm -rf 文件或文件夹 安装应用yum install packagename 这里centos使用的是yum安装应用，而ubuntu使用的是apt-get命令 使用示例，如果我要安装压缩软件7z，通过百度“linux安装7z”，得知使用以下命令安装： yum install p7zip 小作业：为服务器45.78.17.172安装7z压缩程序 下载、上传文件以下命令仅限使用SecureCrt时使用： #上传文件 rz #下载文件 sz filen 注意：sz下载仅能下载一个文件，下载文件夹需要压缩成一个文件后才能下载 授人以渔上面的命令都是些常用命令，如果遇到一个操作想不起来或者不会做该怎么办呢？ 很简单，百度 “linux + 操作名称” 例如，“linux如何压缩文件”，“linux如何下载文件”、 小作业：学会如何在linux压缩文件 如果是已有的命令，却记不住怎么用该怎么办呢？推荐使用cheat命令 比如：cheat ls，会显示出以下结果： cheat ls # Displays everything in the target directory ls path/to/the/target/directory # Displays everything including hidden files ls -a # Displays all files, along with the size (with unit suffixes) and timestamp ls -lh # Display files, sorted by size ls -S # Display directories only ls -d */ # Display directories only, include hidden ls -d .*/ */ 压缩、解压自带的压缩工具有tar和zip 自带的解压软件有tar和unzip 使用方式可以使用cheat命令查看 推荐使用7z压缩和解压，一方面是该命令比较好用，另一方面压缩的比例比较高。上面的学习中应该已经安装了p7zip，因此可以使用7za这个命令 压缩 7za a 压缩后的文件名 要压缩的文件或文件夹 使用示例： 7za a hehe.7z hehe.txt 解压 7za x 压缩文件.7z 注意，压缩后的文件需使用.7z作为后缀，方便软件识别其为7z格式的压缩包","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://smarxpan.github.io/tags/Linux/"}]},{"title":"老司机来教你单例的正确姿势","slug":"how_to_use_singleton","date":"2016-06-29T02:15:28.000Z","updated":"2016-06-30T14:27:38.000Z","comments":true,"path":"2016/06/29/how_to_use_singleton/","link":"","permalink":"http://smarxpan.github.io/2016/06/29/how_to_use_singleton/","excerpt":"老司机来教你单例的正确姿势Java单例模式可能是最简单也是最常用的设计模式，一个完美的单例需要做到哪些事呢？ 单例（这不是废话吗） 延迟加载 线程安全 没有性能问题 防止序列化产生新对象 防止反射攻击 可以看到，真正要实现一个完美的单例是很复杂的，那么，让我这个司机带大家看一看正确姿势的单例。 最佳实践单例之枚举没错，直接就上最佳实践，就是这么任性 这货长这样： public enum Singleton{ INSTANCE; } 如果你不熟悉枚举，可能会说：这货是啥？！ 这种方式的好处是： 利用的枚举的特性实现单例 由JVM保证线程安全 序列化和反射攻击已经被枚举解决 调用方式为Singleton.INSTANCE, 出自《Effective Java》第二版第三条: 用私有构造器或枚举类型强化Singleton属性。 关于单例最佳实践的讨论可以看Stackoverflow：what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java 下面将会介绍更为常见的单例模式，但是均未处理反射攻击，如果想了解更多可以看这篇文章：如何防止单例模式被JAVA反射攻击","text":"老司机来教你单例的正确姿势Java单例模式可能是最简单也是最常用的设计模式，一个完美的单例需要做到哪些事呢？ 单例（这不是废话吗） 延迟加载 线程安全 没有性能问题 防止序列化产生新对象 防止反射攻击 可以看到，真正要实现一个完美的单例是很复杂的，那么，让我这个司机带大家看一看正确姿势的单例。 最佳实践单例之枚举没错，直接就上最佳实践，就是这么任性 这货长这样： public enum Singleton{ INSTANCE; } 如果你不熟悉枚举，可能会说：这货是啥？！ 这种方式的好处是： 利用的枚举的特性实现单例 由JVM保证线程安全 序列化和反射攻击已经被枚举解决 调用方式为Singleton.INSTANCE, 出自《Effective Java》第二版第三条: 用私有构造器或枚举类型强化Singleton属性。 关于单例最佳实践的讨论可以看Stackoverflow：what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java 下面将会介绍更为常见的单例模式，但是均未处理反射攻击，如果想了解更多可以看这篇文章：如何防止单例模式被JAVA反射攻击 最简单的单例之饿汉式public class Singleton { private static final Singleton INSTANCE = new Singleton(); // 私有化构造函数 private Singleton(){} public static Singleton getInstance(){ return INSTANCE; } } 这种单例的写法最简单，但是缺点是一旦类被加载，单例就会初始化，没有实现懒加载。而且当实现了Serializable接口后，反序列化时单例会被破坏。 实现Serializable接口需要重写readResolve，才能保证其反序列化依旧是单例： public class Singleton implements Serializable { private static final Singleton INSTANCE = new Singleton(); // 私有化构造函数 private Singleton(){} public static Singleton getInstance(){ return INSTANCE; } /** * 如果实现了Serializable, 必须重写这个方法 */ private Object readResolve() throws ObjectStreamException { return INSTANCE; } } OK，反序列化要注意的就是这一点，下面的内容中就不再复述了。 最体现技术的单例之懒汉式懒汉式即实现延迟加载的单例，为上述饿汉式的优化形式。而因其仍需要进一步优化，往往成为面试考点，让我们一起来看看坑爹的“懒汉式” 懒汉式的最初形式是这样的： public class Singleton { private static Singleton INSTANCE; private Singleton (){} public static Singleton getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton(); } return INSTANCE; } } 这种写法就轻松实现了单例的懒加载，只有调用了getInstance方法才会初始化。但是这样的写法出现了新的问题–线程不安全。当多个线程调用getInstance方法时，可能会创建多个实例，因此需要对其进行同步。 如何使其线程安全呢？简单，加个synchronized关键字就行了 public static synchronized Singleton getInstance() { if (INSTANCE == null) { INSTANCE = new Singleton(); } return INSTANCE; } 可是…这样又出现了性能问题，简单粗暴的同步整个方法，导致同一时间内只有一个线程能够调用getInstance方法。 因为仅仅需要对初始化部分的代码进行同步，所以再次进行优化： public static Singleton getSingleton() { if (INSTANCE == null) { // 第一次检查 synchronized (Singleton.class) { if (INSTANCE == null) { // 第二次检查 INSTANCE = new Singleton(); } } } return INSTANCE ; } 执行两次检测很有必要：当多线程调用时，如果多个线程同时执行完了第一次检查，其中一个进入同步代码块创建了实例，后面的线程因第二次检测不会创建新实例。 这段代码看起来很完美，但仍旧存在问题，以下内容引用自黑桃夹克大神的如何正确地写出单例模式 这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 我们只需要将 instance 变量声明成 volatile 就可以了。 public class Singleton { private volatile static Singleton INSTANCE; //声明成 volatile private Singleton (){} public static Singleton getSingleton() { if (INSTANCE == null) { synchronized (Singleton.class) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } } 使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 至此，这样的懒汉式才是没有问题的懒汉式。 内部类实现单例public class Singleton { /** * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系， * 而且只有被调用到才会装载，从而实现了延迟加载 */ private static class SingletonHolder{ /** * 静态初始化器，由JVM来保证线程安全 */ private static final Singleton instance = new Singleton(); } /** * 私有化构造方法 */ private Singleton(){ } public static Singleton getInstance(){ return SingletonHolder.instance; } } 使用内部类来维护单例的实例，当Singleton被加载时，其内部类并不会被初始化，故可以确保当 Singleton类被载入JVM时，不会初始化单例类。只有 getInstance() 方法调用时，才会初始化 instance。同时，由于实例的建立是时在类加载时完成，故天生对多线程友好，getInstance() 方法也无需使用同步关键字。 总结无疑，单例就应使用枚举实现，最佳实践诚不欺我 参考链接 What is an efficient way to implement a singleton pattern in Java Java Practices -&gt; Singleton Creating and Destroying Java Objects: Part 1 如何正确地写出单例模式 JAVA 枚举单例模式","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://smarxpan.github.io/tags/Java/"}]},{"title":"Android进阶之自定义注解","slug":"how_to_use_annotation","date":"2016-06-20T07:15:30.000Z","updated":"2018-12-14T12:46:39.324Z","comments":true,"path":"2016/06/20/how_to_use_annotation/","link":"","permalink":"http://smarxpan.github.io/2016/06/20/how_to_use_annotation/","excerpt":"Android进阶之自定义注解本篇文章内容包括: 注解的概念 元注解 自定义注解 Android自定义编译时注解 如果使用过ButterKnife, EventBus, Retrofit, Dagger等框架, 你对注解一定不会陌生. 但是注解背后究竟有什么魔法, 可以做这么不可思议的事情. 什么是注解先来看看Java文档中的定义 An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate. 注解是一种元数据, 可以添加到java代码中. 类、方法、变量、参数、包都可以被注解，注解对注解的代码没有直接影响. 首先, 明确一点: 注解并没有什么魔法, 之所以产生作用, 是对其解析后做了相应的处理. 注解仅仅只是个标记罢了. 定义注解用的关键字是@interface","text":"Android进阶之自定义注解本篇文章内容包括: 注解的概念 元注解 自定义注解 Android自定义编译时注解 如果使用过ButterKnife, EventBus, Retrofit, Dagger等框架, 你对注解一定不会陌生. 但是注解背后究竟有什么魔法, 可以做这么不可思议的事情. 什么是注解先来看看Java文档中的定义 An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate. 注解是一种元数据, 可以添加到java代码中. 类、方法、变量、参数、包都可以被注解，注解对注解的代码没有直接影响. 首先, 明确一点: 注解并没有什么魔法, 之所以产生作用, 是对其解析后做了相应的处理. 注解仅仅只是个标记罢了. 定义注解用的关键字是@interface 元注解java内置的注解有Override, Deprecated, SuppressWarnings等, 作用相信大家都知道. 现在查看Override注解的源码 @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 发现Override注解上面有两个注解, 这就是元注解. 元注解就是用来定义注解的注解.其作用就是定义注解的作用范围, 使用在什么元素上等等, 下面来详细介绍. 元注解共有四种@Retention, @Target, @Inherited, @Documented @Retention 保留的范围，默认值为CLASS. 可选值有三种 SOURCE, 只在源码中可用 CLASS, 在源码和字节码中可用 RUNTIME, 在源码,字节码,运行时均可用 @Target 可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER等，未标注则表示可修饰所有 @Inherited 是否可以被继承，默认为false @Documented 是否会保存到 Javadoc 文档中 其中, @Retention是定义保留策略, 直接决定了我们用何种方式解析. SOUCE级别的注解是用来标记的, 比如Override, SuppressWarnings. 我们真正使用的类型是CLASS(编译时)和RUNTIME(运行时) 自定义注解举个栗子, 结合例子讲解 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface TestAnnotation { String value(); String[] value2() default &quot;value2&quot;; } 元注解的的意义参考上面的讲解, 不再重复, 这里看注解值的写法: 类型 参数名() default 默认值; 其中默认值是可选的, 可以定义, 也可以不定义. 处理运行时注解Retention的值为RUNTIME时, 注解会保留到运行时, 因此使用反射来解析注解. 使用的注解就是上一步的@TestAnnotation, 解析示例如下: public class Demo { @TestAnnotation(&quot;Hello Annotation!&quot;) private String testAnnotation; public static void main(String[] args) { try { // 获取要解析的类 Class cls = Class.forName(&quot;myAnnotation.Demo&quot;); // 拿到所有Field Field[] declaredFields = cls.getDeclaredFields(); for(Field field : declaredFields){ // 获取Field上的注解 TestAnnotation annotation = field.getAnnotation(TestAnnotation.class); if(annotation != null){ // 获取注解值 String value = annotation.value(); System.out.println(value); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 此处只演示了解析成员变量上的注解, 其他类型与此类似. 解析编译时注解解析编译时注解需要继承AbstractProcessor类, 实现其抽象方法 public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) 该方法返回ture表示该注解已经被处理, 后续不会再有其他处理器处理; 返回false表示仍可被其他处理器处理. 处理示例: // 指定要解析的注解 @SupportedAnnotationTypes(&quot;myAnnotation.TestAnnotation&quot;) // 指定JDK版本 @SupportedSourceVersion(SourceVersion.RELEASE_7) public class MyAnnotationProcesser extends AbstractProcessor { @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { for (TypeElement te : annotations) { for (Element element : roundEnv.getElementsAnnotatedWith(te)) { TestAnnotation testAnnotation = element.getAnnotation(TestAnnotation.class); // do something } } return true; } } 这里先大致介绍是怎么个套路, 接下来说具体实践过程. Android中使用编译时注解注解是个什么东西我们已经知道了, 也知道了如何解析注解. 我们下一步的目标是如ButterKnife一般自动生成代码. 接下来的操作基于InteliJ IDEA(开发注解及其解析类, 打出jar包)和Android Studio(实测使用情况) note: AS的Android开发环境中没有AbstractProcessor类, 而我新建了Java Module后遇到了各种各样的花式错误(后面的报错之路会叙述), 无奈只能在IDEA中开发并打出jar包 开发注解库在IDEA中新建java项目, 并开启maven支持. 如果新建项目的页面没有maven选项, 建好项目后右键项目目录-&gt;”Add Framwork Support…”, 选择maven. 自定义编译时注解 @Retention(RetentionPolicy.CLASS) @Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE}) public @interface TestAnnotation { String value() default &quot;Hello Annotation&quot;; } 解析编译时注解 // 支持的注解类型, 此处要填写全类名 @SupportedAnnotationTypes(&quot;myannotation.TestAnnotation&quot;) // JDK版本, 我用的是java7 @SupportedSourceVersion(SourceVersion.RELEASE_7) public class MyAnnotationProcessor extends AbstractProcessor { // 类名的前缀后缀 public static final String SUFFIX = &quot;AutoGenerate&quot;; public static final String PREFIX = &quot;My_&quot;; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { for (TypeElement te : annotations) { for (Element e : roundEnv.getElementsAnnotatedWith(te)) { // 准备在gradle的控制台打印信息 Messager messager = processingEnv.getMessager(); // 打印 messager.printMessage(Diagnostic.Kind.NOTE, &quot;Printing: &quot; + e.toString()); messager.printMessage(Diagnostic.Kind.NOTE, &quot;Printing: &quot; + e.getSimpleName()); messager.printMessage(Diagnostic.Kind.NOTE, &quot;Printing: &quot; + e.getEnclosingElement().toString()); // 获取注解 TestAnnotation annotation = e.getAnnotation(TestAnnotation.class); // 获取元素名并将其首字母大写 String name = e.getSimpleName().toString(); char c = Character.toUpperCase(name.charAt(0)); name = String.valueOf(c+name.substring(1)); // 包裹注解元素的元素, 也就是其父元素, 比如注解了成员变量或者成员函数, 其上层就是该类 Element enclosingElement = e.getEnclosingElement(); // 获取父元素的全类名, 用来生成包名 String enclosingQualifiedName; if(enclosingElement instanceof PackageElement){ enclosingQualifiedName = ((PackageElement)enclosingElement).getQualifiedName().toString(); }else { enclosingQualifiedName = ((TypeElement)enclosingElement).getQualifiedName().toString(); } try { // 生成的包名 String genaratePackageName = enclosingQualifiedName.substring(0, enclosingQualifiedName.lastIndexOf(&apos;.&apos;)); // 生成的类名 String genarateClassName = PREFIX + enclosingElement.getSimpleName() + SUFFIX; // 创建Java文件 JavaFileObject f = processingEnv.getFiler().createSourceFile(genarateClassName); // 在控制台输出文件路径 messager.printMessage(Diagnostic.Kind.NOTE, &quot;Printing: &quot; + f.toUri()); Writer w = f.openWriter(); try { PrintWriter pw = new PrintWriter(w); pw.println(&quot;package &quot; + genaratePackageName + &quot;;&quot;); pw.println(&quot;\\npublic class &quot; + genarateClassName + &quot; { &quot;); pw.println(&quot;\\n /** 打印值 */&quot;); pw.println(&quot; public static void print&quot; + name + &quot;() {&quot;); pw.println(&quot; // 注解的父元素: &quot; + enclosingElement.toString()); pw.println(&quot; System.out.println(\\&quot;代码生成的路径: &quot;+f.toUri()+&quot;\\&quot;);&quot;); pw.println(&quot; System.out.println(\\&quot;注解的元素: &quot;+e.toString()+&quot;\\&quot;);&quot;); pw.println(&quot; System.out.println(\\&quot;注解的值: &quot;+annotation.value()+&quot;\\&quot;);&quot;); pw.println(&quot; }&quot;); pw.println(&quot;}&quot;); pw.flush(); } finally { w.close(); } } catch (IOException x) { processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString()); } } } return true; } } 看似代码很长, 其实很好理解. 只做了两件事, 1.解析注解并获取需要的值 2.使用JavaFileObject类生成java代码. 向JVM声明解析器 我们的解析器虽然定义好了, 但是jvm并不知道, 也不会调用, 因此我们需要声明. 如图所示 在java的同级目录新建resources目录, 新建META-INF/services/javax.annotation.processing.Processor文件, 文件中填写你自定义的Processor全类名 然后打出jar包以待使用(打包方式自行百度) Android中使用使用apt插件 项目根目录gradle中buildscript的dependencies添加 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; module目录的gradle中, 添加 apply plugin: &apos;android-apt&apos; 代码中调用 将之前打出的jar包导入项目中, 在MainActivity中写个测试方法 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); test(); } @TestAnnotation(&quot;hehe&quot;) public void test(){ } 运行一遍项目之后, 代码就会自动生成. 以下是生成的代码, 在路径yourmodule/build/generated/source/apt/debug/yourpackagename中: public class My_MainActivityAutoGenerate { /** 打印值 */ public static void printTest() { // 注解的父元素: com.example.pan.androidtestdemo.MainActivity System.out.println(&quot;代码生成的路径: file:/Users/Pan/AndroidStudioProjects/AndroidTestDemo/app/build/generated/source/apt/debug/My_MainActivityAutoGenerate.java&quot;); System.out.println(&quot;注解的元素: test()&quot;); System.out.println(&quot;注解的值: hehe&quot;); } } 然后在test方法中调用自动生成的方法 @TestAnnotation(&quot;hehe&quot;) public void test(){ My_MainActivityAutoGenerate.printTest(); } 会看到以下打印结果: 代码生成的路径: file:/Users/Pan/AndroidStudioProjects/AndroidTestDemo/app/build/generated/source/apt/debug/com/example/pan/androidtestdemo/MainActivityAutoGenerate.java 注解的元素: test() 注解的值: hehe 报错之路开始时, 我在Android Studio的Java Library中编写解析类, 然后在Android Module依赖Java库, 然后报下面这个错误 For more information see https://docs.gradle.org/current/userguide/build_environment.html Error:Error converting bytecode to dex: Cause: Dex cannot parse version 52 byte code. This is caused by library dependencies that have been compiled using Java 8 or above. If you are using the &apos;java&apos; gradle plugin in a library submodule add targetCompatibility = &apos;1.7&apos; sourceCompatibility = &apos;1.7&apos; to that submodule&apos;s build.gradle file. 我tm本来就是Java8啊, 一番Google, 需要开启手动开启才能支持java8, 步骤如下: android { compileSdkVersion 23 // 开启Java8, buildTools版本必须24以上 buildToolsVersion &quot;24&quot; ... defaultConfig { ... // Java8需要jack工具链支持 jackOptions{ enabled true } } ... // 指定编译版本 compileOptions{ targetCompatibility = &apos;1.8&apos; sourceCompatibility = &apos;1.8&apos; } } 然而…又报了这个错误 Error: Could not find the property &apos;options&apos; on the task&apos; : app: compileDebugJavaWithJack &apos;. 来自JakeWharton大神的回复, jack编译器目前并不支持apt插件https://github.com/JakeWharton/butterknife/issues/571 摔! 不用java8报错, 用了又尼玛报. 自动生成代码是必须要用apt插件的. 那就只能用java7在IDEA里开发了. 时至今日(2016年06月23日), Google并没有解决这个问题, 目前jack编译器还处于预览版, 相信以后会解决吧 总结有了本文所述的注解知识, 对Dagger,ButterKnife等框架就不难理解了. 如果在时间精力允许的情况下, 我们也完全可以自定义个注解框架. 本文中自动生成代码的部分十分简单, 也隐含bug: 在for循环中创建了文件, 如果一个类中使用了两次该注解, 第二次是无法创建新文件的. 真正的实际项目中, 肯定是将需要的信息保存起来, 之后统一创建java类. 更进一步的应用大家可以查看其他注解框架的源码, 调试注解大家可以查看这篇文章如何debug自定义AbstractProcessor, 我这里就不过多赘述了 水平有限, 如有错误欢迎指正. 参考链接 公共技术点之 Java 注解 Annotation Annotation实战【自定义AbstractProcessor】 android 中运用apt自定义一个AbstractProcessor 打造一个 Android 的注解库","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"Activity跳转最佳实践","slug":"android-navigator-best-practice","date":"2016-06-08T07:15:28.000Z","updated":"2016-06-30T14:24:44.000Z","comments":true,"path":"2016/06/08/android-navigator-best-practice/","link":"","permalink":"http://smarxpan.github.io/2016/06/08/android-navigator-best-practice/","excerpt":"Activity跳转最佳实践学习Android-CleanArchitecture时, 注意到它用了一个Navigator类统一管理Activity跳转, 统一管理的好处相信不用我多说, 让我们一起来学习一个. 传统写法跳转不需要参数时: Intent intent = new Intent(this, SecondActivity.class); startActivity(intent); 跳转需要参数那就是 Intent intent = new Intent(this, SecondActivity.class); intent.putExtra(&quot;key&quot;,&quot;someValue&quot;); startActivity(intent); 这样写可能会发生一不小心写错了key, 或者传递的数据需要修改时, 改动的地方较多. 而统一使用一个类控制, 会干净舒服很多.","text":"Activity跳转最佳实践学习Android-CleanArchitecture时, 注意到它用了一个Navigator类统一管理Activity跳转, 统一管理的好处相信不用我多说, 让我们一起来学习一个. 传统写法跳转不需要参数时: Intent intent = new Intent(this, SecondActivity.class); startActivity(intent); 跳转需要参数那就是 Intent intent = new Intent(this, SecondActivity.class); intent.putExtra(&quot;key&quot;,&quot;someValue&quot;); startActivity(intent); 这样写可能会发生一不小心写错了key, 或者传递的数据需要修改时, 改动的地方较多. 而统一使用一个类控制, 会干净舒服很多. 干净的写法在SecondActivity中定义静态方法 public static Intent getCallingIntent(Context context){ Intent callingIntent = new Intent(context, SecondActivity.class); return callingIntent; } 创建Navigator类, 控制跳转 public enum Navigator { INSTANCE; public void navigateToSecond(Context context){ if(context != null){ Intent callingIntent = SecondActivity.getCallingIntent(context); context.startActivity(callingIntent); } } } Tips: 此处使用枚举实现单例, 枚举实现单例是单例的最佳实践, 参见What is an efficient way to implement a singleton pattern in Java?, 或者看Effective Java第三条 调用方式: Navigator.INSTANCE.navigateToSecond(this); 同理, 如果是需要传值, SecondActivity中: private static String EXTRA_KEY = &quot;key&quot;; public static Intent getCallingIntent(Context context, String value){ Intent callingIntent = new Intent(context, SecondActivity.class); callingIntent.putExtra(EXTRA_KEY, value); return callingIntent; } 将extra的key与需要该值的Activity写在一起, 而不是与跳转逻辑写在一起, 减少出错的可能. Navigator改为 public enum Navigator { INSTANCE; public void navigateToSecond(Context context, String value){ if(context != null){ Intent callingIntent = SecondActivity.getCallingIntent(context, value); context.startActivity(callingIntent); } } } 总结这样的写法将Activity跳转逻辑抽取了出来, 减少了人为犯错的可能, 还是值得大家在项目中实际使用的. 参考链接 Android-CleanArchitecture Navigator.java What is an efficient way to implement a singleton pattern in Java?","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"是时候学习一波Lambda表达式了","slug":"Lamada表达式","date":"2016-04-22T16:01:56.000Z","updated":"2018-12-17T11:14:55.167Z","comments":true,"path":"2016/04/23/Lamada表达式/","link":"","permalink":"http://smarxpan.github.io/2016/04/23/Lamada表达式/","excerpt":"是时候学习一波Lambda表达式了Android N预览版的发布, 支持了一些java 8的新特性, lambda表达式算是最重要的新特性之一. 本篇文章将会探讨及使用Lambda表达式, 跟紧Google粑粑的脚步 什么是Lambda首先Lambda并不是新鲜事物, 其为java8最重要的新特性之一. 我们Android开发者开始一直用java7, 直到AndroidN的发布终于能过使用Lambda. 要明白什么是Lambda, 先要知道什么是闭包)(Closure). 闭包来源于函数式编程, 关于闭包的概念各类定义总是深(bu)奥(shuo)难(ren)懂(hua). 用人话来说就是: “定义在函数内部的函数”, 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁–来自阮一峰技术博客 而Lambda表达式是java对闭包这一特性的实现方式. 在java中实际使用时就是将函数参数中某类匿名内部类改写成不明觉屌的Lambda表达式. 等等, 这个某类匿名内部类是神马意思? 这类能用Lambda表达式替代的匿名内部类有两个条件: 必须是接口类型; 只有一个抽象方法.","text":"是时候学习一波Lambda表达式了Android N预览版的发布, 支持了一些java 8的新特性, lambda表达式算是最重要的新特性之一. 本篇文章将会探讨及使用Lambda表达式, 跟紧Google粑粑的脚步 什么是Lambda首先Lambda并不是新鲜事物, 其为java8最重要的新特性之一. 我们Android开发者开始一直用java7, 直到AndroidN的发布终于能过使用Lambda. 要明白什么是Lambda, 先要知道什么是闭包)(Closure). 闭包来源于函数式编程, 关于闭包的概念各类定义总是深(bu)奥(shuo)难(ren)懂(hua). 用人话来说就是: “定义在函数内部的函数”, 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁–来自阮一峰技术博客 而Lambda表达式是java对闭包这一特性的实现方式. 在java中实际使用时就是将函数参数中某类匿名内部类改写成不明觉屌的Lambda表达式. 等等, 这个某类匿名内部类是神马意思? 这类能用Lambda表达式替代的匿名内部类有两个条件: 必须是接口类型; 只有一个抽象方法. Lambda的使用语法基本语法 (parameters) -&gt; { expression or statements } 下面是一些例子: // 无参数, 返回1+2的结果 () -&gt; 1+2 // 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 接收2个参数(数字),返回表达式运算的结果 (x, y) -&gt; x + y // 多个语句要用大括号包裹, 并且返回值要用return指明 (x, y) -&gt; { int result = x + y; System.out.print(result); return result; } // 接收string 对象, 并在控制台打印 s -&gt; System.out.print(s) 其中参数的类型可以不声明, 编译器会结合上下文智能推断, 比如这句 s -&gt; System.out.print(s) 等价于 (String s) -&gt; System.out.print(s) 注意: 无参数时()不能省略 语法非常简单, 就是因为简单, 反而更让人摸不着头脑, 接下来开始介绍具体使用 java中使用Lambda先看看我们常写的Runnable接口如何改写成Lambda形式 使用匿名内部类的写法 new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;Hello Lambda!&quot;); } }).start(); 使用Lambda表达式 new Thread(() -&gt; System.out.println(&quot;Hello Lambda!&quot;)).start(); 改写过程一目了然, 就是原本写匿名内部类的地方, 改写成了 参数 -&gt; 表达式或者代码库块 再来总结一下Lambda表达式的使用条件: 函数(可以是构造函数)的参数是接口 这个接口只包含一个抽象方法 这样就可以使用酷炫拽的Lambda表达式了 自定义接口使用Lambda下面尝试自定义接口使用Lambda, 对使用方式理解更清晰 第一步, 创建一个Person类 public class Person { public String name; public int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return &quot;Person{&quot; + &quot;age=&quot; + age + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;}&apos;; } } 第二步, 创建一个接口, 用来打印Person public interface IPersonPrinter { void printPerson(Person p); } 第三步, 创建方法打印Person private static void printPerson(Person p, IPersonPrinter personPrinter){ personPrinter.printPerson(p); } 接下来要在main函数中调用第三步的方法, 先来看不使用Lambda表达式的代码 Person person = new Person(&quot;Smarx&quot;, 23); printPerson(person, new IPersonPrinter() { @Override public void printPerson(Person p) { System.out.println(p.toString()); } }); 很简单的操作却要使用这么多行代码, 只有一行代码是有效的. 而使用Lambda表达式后, 只需要一行代码: printPerson(person, p -&gt; System.out.println(p.toString())); 完整的调用代码如下: public class LambdaDemo { public static void main(String[] args) { Person person = new Person(&quot;Smarx&quot;, 23); printPerson(person, p -&gt; System.out.println(p.toString())); } private static void printPerson(Person p, IPersonPrinter personPrinter){ personPrinter.printPerson(p); } } 如何使Android Studio支持Lambda在Android N出现之前, 大家都是使用gradle-retrolambda插件支持的. 网上相关的文章很多, 如果需要可自行学习这个库的配置及使用. 下面介绍使用Android N支持Lambda表达式 首先确保你的jdk已经升级到了1.8, 然后在将工程根目录的build.gradle中的gradle版本改成最新版本, 目前最新的版本是2.1.0-alpha4 dependencies { classpath &apos;com.android.tools.build:gradle:2.1.0-alpha4&apos; } module目录的build.gradle配置如下: android { compileSdkVersion &apos;android-N&apos; // buildTools必须用24以上 buildToolsVersion &quot;24.0.0 rc3&quot; defaultConfig { applicationId &quot;com.github.smarxpan&quot; minSdkVersion &apos;N&apos; //使用Android N最小版本也要是Android N targetSdkVersion &apos;N&apos; versionCode 1 versionName &quot;1.0&quot; // 使用jack(Java Android Compiler Kit)工具链 jackOptions{ enabled true } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } // 配置JDK为1.8 compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 这样就能愉快的将我们常写的某些匿名内部类写成Lambda表达式了, such as: findViewById(R.id.btn).setOnClickListener( view -&gt; { Toast.makeText(MainActivity.this, &quot;Hello Lambda&quot;, Toast.LENGTH_SHORT).show(); }); Lambda和匿名内部类的区别看起来Lambda表达式只是简化了匿名内部类的书写, 事实上Lambda并非匿名内部类的语法糖, Lambda的效率比匿名内部类要高. 以下内容主要学习自深入探索Java 8 Lambda表达式 , 我不过拾人牙慧, 不值一哂 匿名内部类形式我们依旧使用前面自定义Lambda表达式的例子研究, 先来看匿名内部类的代码: public class LambdaDemo { public static void main(String[] args) { Person person = new Person(&quot;Smarx&quot;, 23); printPerson(person, new IPersonPrinter() { public void printPerson(Person p) { System.out.println(p.toString()); } }); } private static void printPerson(Person p, IPersonPrinter personPrinter){ personPrinter.printPerson(p); } } 进入这个文件所在的目录, 使用命令行编译 javac LambdaDemo.java 再使用javap命令查看字节码 javap -c -v LambdaDemo 可以看到匿名内部类生成的字节码如下: 12: aload_1 13: new #5 // class LambdaDemo$1 16: dup 17: invokespecial #6 // Method LambdaDemo$1.&quot;&lt;init&gt;&quot;:()V 20: invokestatic #7 // Method printPerson:(LPerson;LIPersonPrinter;)V 23: return 上述字节码的含义如下： 第13行，使用字节码操作new创建了类型LambdaDemo$1的一个对象，同时将新创建的对象的的引用压入栈中。 第16行，使用dup操作复制栈上的引用。 第17行，上面的复制的引用被指令invokespecial消耗使用，用来初始化匿名内部类实例。 第20行，调用本类的静态方法printPerson Lambdas表达式和invokedynamic将匿名内部类改写成Lambda printPerson(person, p -&gt; System.out.println(p.toString())); 重新编译后再查看字节码 12: aload_1 13: invokedynamic #5, 0 // InvokeDynamic #0:printPerson:()LIPersonPrinter; 18: invokestatic #6 // Method printPerson:(LPerson;LIPersonPrinter;)V 21: return 可以看到字节码与匿名内部类的版本并不相同, Lambda表达式转化成字节码实际上做了如下两步: 生成一个invokedynamic调用点，也叫做Lambda工厂。当调用时返回一个Lambda表达式转化成的函数式接口实例。 将Lambda表达式的方法体转换成方法供invokedynamic指令调用。 也就是说, Lambda表达式其实被翻译成了本类的一个静态方法, 比如我们上面的代码, 会被翻译成类似这样的方法: static void lambda$1(String s){ System.out.println(p.toString()); } 需要注意的是，这里的$1并不是代表内部类，这里仅仅是为了展示编译后的代码而已。 需要注意的是编译器对于Lambda表达式的翻译策略并非固定的，因为这样invokedynamic可以使编译器在后期使用不同的翻译实现策略。比如，被捕获的变量可以放入数组中。如果Lambda表达式用到了类的实例的属性，其对应生成的方法可以是实例方法，而不是静态方法，这样可以避免传入多余的参数。 总结经过上述的学习, 相信大家对Lambda表达式的使用已经有了清晰了了解. 目前Lambda的支持还未能向下兼容, 还处于预览版的状态, 相信Google很快会推出支持方案. 参考链接 深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法） 深入探索Java 8 Lambda表达式 Lambda Expressions Java 8 Language Features 在 Android N 预览版中使用 Java 8 的新特性","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://smarxpan.github.io/tags/Java/"}]},{"title":"Dagger2学习之相关概念详解","slug":"Dagger2学习之概念全攻略","date":"2016-04-17T03:47:53.000Z","updated":"2016-06-30T14:27:19.000Z","comments":true,"path":"2016/04/17/Dagger2学习之概念全攻略/","link":"","permalink":"http://smarxpan.github.io/2016/04/17/Dagger2学习之概念全攻略/","excerpt":"Dagger2学习之相关概念详解// TODO 尚未完成 经过上一篇文章Hello Dagger2的实践, 相信大家都已经能把Dagger2的Demo跑起来了. 大家肯定对相关概念产生了一万个疑问, 而这篇文章将会为实际应用Dagger铺平道路. 这里, 你将会学到以下知识点. 什么是依赖注入 @Module, @Component, @Provides, @Inject @Singleton和自定义Scope @SubComponent 什么是依赖注入依赖注入(DI), Dependency Injection, 听起来十分高大上的概念, 事实上你每天都在用. 接下来将用Dagger官方的咖啡机例子来举例说明.","text":"Dagger2学习之相关概念详解// TODO 尚未完成 经过上一篇文章Hello Dagger2的实践, 相信大家都已经能把Dagger2的Demo跑起来了. 大家肯定对相关概念产生了一万个疑问, 而这篇文章将会为实际应用Dagger铺平道路. 这里, 你将会学到以下知识点. 什么是依赖注入 @Module, @Component, @Provides, @Inject @Singleton和自定义Scope @SubComponent 什么是依赖注入依赖注入(DI), Dependency Injection, 听起来十分高大上的概念, 事实上你每天都在用. 接下来将用Dagger官方的咖啡机例子来举例说明. 没有依赖注入之前// 咖啡机 class CoffeeMaker { // 加热器 private final Heater heater; // 泵 private final Pump pump; CoffeeMaker() { // 电加热器 this.heater = new ElectricHeater(); // 虹吸泵 this.pump = new Thermosiphon(heater); } // 煮 public void brew() { /* ... */ } } 使用咖啡机 CoffeMaker maker = new CoffeeMaker(); maker.brew(); // 沖泡 maker.brew(); // 沖泡 可以看出耦合非常严重, 加热器和泵的构造器发生改变, 都需要去修改咖啡机的代码. 使用依赖注入后class CoffeeMaker { private final Heater heater; private final Pump pump; CoffeeMaker(Heater heater, Pump pump) { this.heater = heater; this.pump = pump; } public void brew() { /* ... */ } } 开始泡咖啡 Heater heater = new ElectricHeater(); Pump pump = new Thermosiphon(heater); CoffeeMaker maker = new CoffeeMaker(heater, pump); CoffeeMaker maker2 = new CoffeeMaker(heater, pump); maker.brew(); maker2.brew(); 这样就是向咖啡机注入了加热器和泵, 对加热器和泵的修改不需要改变咖啡机的代码. 看出区别没有? 是不是发出一声”卧槽, 这就是依赖注入啊!” 没错, 就是这么个我们天天写的东西. 而Dagger这个框架, 可以做到自动生成依赖注入的模板代码, 让我们从重复代码中解脱出来. dependense和subcomponent给其他Component提供依赖时, 必须暴露依赖方法, 否则找不到对象 而SubComponent不同, 子依赖能拿到父类所有对象, 不需要傻傻的提供. Scope对于直接使用 @Inject 构造函数的依赖，如果把 scope 注解放到它的类上，而不是构造函数上，就能达到局部单例的效果了； Scope的作用是实现一定范围内的单例 如何实现的? 在ScopeProvider创建对象 自定义Scope作用代码很简单 @Scope @Retention(RetentionPolicy.RUNTIME) public @interface ActivityScope { } 然后使用也很简单 在Module中这样, 在Component上面也要用 你会问, 这样就能保证生命周期了? 这是什么魔法? 那么, 我们就来揭示一下魔法的真相吧. 事实上并不存在魔法, Scope注解只是个注解, 并不能替你管理什么生命周期, 而是最终还是你自己做的处理 Singleton最好使用在Application里面 使用自定义Scope注解和Singleton注解生成的代码相同 事实上Singleton的含义并不明确, 应该自己去自定义一个而不是使用Singleton, 如果你很想使用Singleton 自定义的Scope并不存在魔法, 之所以要自定义Scope, Component只能依赖拥有不同Scope注解的Component Scope使用错误示例以下是一个错误的Scope使用示例，稍后会解释为何这样不能实现单例 Module是酱式儿的 @Module public class ActivityModule { @Provides @Singleton static UserModel provideUserModel(){ return new UserModel(); } } Component是酱紫的 @Singleton @Component(modules = ActivityModule.class) public interface ActivityComponent { void inject(MainActivity activity); void inject(SecondActivity activity); } MainActivity和SecondActivity是这样的 public class MainActivity extends AppCompatActivity { @Inject UserModel userModel; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ActivityComponent activityComponent = DaggerActivityComponent.create(); activityComponent.inject(this); TextView textview = (TextView) findViewById(R.id.tv); textview.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(intent); } }); Log.e(&quot;TAG&quot;, userModel + &quot;---MainActivity&quot;); } } public class SecondActivity extends AppCompatActivity { @Inject UserModel userModel; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); ActivityComponent activityComponent = DaggerActivityComponent.create(); activityComponent.inject(this); Log.e(&quot;TAG&quot;, userModel + &quot;---SecondActivity&quot;); } } 运行结果: UserModel@52765aac---MainActivity UserModel@52787e5c---SecondActivity","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"算法系列(2)--不那么简单的排序之希尔、归并、快速排序","slug":"算法系列-2-不那么简单的排序","date":"2016-04-14T14:48:23.000Z","updated":"2018-12-18T01:41:58.317Z","comments":true,"path":"2016/04/14/算法系列-2-不那么简单的排序/","link":"","permalink":"http://smarxpan.github.io/2016/04/14/算法系列-2-不那么简单的排序/","excerpt":"也不知道与简单排序对应的应该叫什么, 就叫不那么简单的排序好了. 本篇博客主要学习了希尔排序、归并排序and快速排序。 注: 这一篇和上一篇简单排序都算是学习白话算法系列的学习笔记吧 希尔排序希尔排序是基于插入排序而来, 插入排序的最好时间复杂度是O(n), 当数组基本有序时, 效率是很高的. 而希尔排序, 设定一个增量, 按增量将数组分组. 例如数组{1,2,3,4}, 增量是2, 那么数组就可以分为{1,3}, {2,4}两组, 增量是1那就是1,2,3,4四组. 分组之后在组内进行插入排序, 再缩小增量重新分组再次排序, 直到增量是1(等同于正常的插入排序), 再插入排序一次, 排序完成. void shellSort(int arr[], int n){ for (int gap = n/2; gap&gt;0; gap/=2) { for (int i = gap; i&lt;n; i++) { if (arr[i] &lt; arr[i - gap]) { int temp = arr[i]; int j; // 思路与插入排序相同, 用临时变量保存要插入的数, 向数组前面查找插入的位置, 一边查找, 一边将前面较大的数字后移 // 临时变量不小于前面的某数时, 说明找到了正确的位置, 只要放在那个数后面就可以了 for (j = i-gap; j&gt;=0 &amp;&amp; temp&lt;arr[j]; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } } }","text":"也不知道与简单排序对应的应该叫什么, 就叫不那么简单的排序好了. 本篇博客主要学习了希尔排序、归并排序and快速排序。 注: 这一篇和上一篇简单排序都算是学习白话算法系列的学习笔记吧 希尔排序希尔排序是基于插入排序而来, 插入排序的最好时间复杂度是O(n), 当数组基本有序时, 效率是很高的. 而希尔排序, 设定一个增量, 按增量将数组分组. 例如数组{1,2,3,4}, 增量是2, 那么数组就可以分为{1,3}, {2,4}两组, 增量是1那就是1,2,3,4四组. 分组之后在组内进行插入排序, 再缩小增量重新分组再次排序, 直到增量是1(等同于正常的插入排序), 再插入排序一次, 排序完成. void shellSort(int arr[], int n){ for (int gap = n/2; gap&gt;0; gap/=2) { for (int i = gap; i&lt;n; i++) { if (arr[i] &lt; arr[i - gap]) { int temp = arr[i]; int j; // 思路与插入排序相同, 用临时变量保存要插入的数, 向数组前面查找插入的位置, 一边查找, 一边将前面较大的数字后移 // 临时变量不小于前面的某数时, 说明找到了正确的位置, 只要放在那个数后面就可以了 for (j = i-gap; j&gt;=0 &amp;&amp; temp&lt;arr[j]; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } } } 归并排序归并二字就是递归&amp;合并 归并排序的关键在于合并有序数组, 合并两个有序数组的方式是先比较两数组的第一个元素, 更小的取出放入新数组, 再依次向后比较, 直到某个数组的元素取光, 把另一个数组的元素依次放入新数组既可. //先来演示合并数组 void mergeArray(int a[], int m, int b[], int n){ int c[m+n]; int i, j, k; //必须初始化, 否则会有残值 i = j = k = 0; // 此处不能用for循环, 除非只写第二个表达式, 否则ijk哪个做自增都不合适 // 其中k看似合适, 但for循环最后会执行一次第三个表达式, k会+1 while (i &lt; m &amp;&amp; j &lt; n) { if (a[i] &lt; b[j]) { c[k++] = a[i++]; }else{ c[k++] = b[j++]; } } while (i &lt; m) { c[k++] = a[i++]; } while (j &lt; n) { c[k++] = b[j++]; } printfArray(c, m+n); } 下面开始撸正式的归并排序 // 合并有序序列 void mergearray(int arr[], int first, int last, int mid, int temp[]){ int tempIndex = 0; int firstSequenceIndex = first; int secondSequeceIndex = mid + 1; // 因为这里用的是数组角标, 而不是长度, 所以用&lt;= 而不是&lt; while (firstSequenceIndex &lt;= mid &amp;&amp; secondSequeceIndex &lt;= last) { // 取较小值放入临时数组 if (arr[firstSequenceIndex] &lt; arr[secondSequeceIndex] ) { temp[tempIndex++] = arr[firstSequenceIndex++]; }else{ temp[tempIndex++] = arr[secondSequeceIndex++]; } } // 如果前一个序列还有值, 依次放入临时数组 while (firstSequenceIndex &lt;= mid) { temp[tempIndex++] = arr[firstSequenceIndex++]; } // 如果后一个序列还有值, 依次放入临时数组 while (secondSequeceIndex &lt;= last) { temp[tempIndex++] = arr[secondSequeceIndex++]; } // 将排好序的部分赋值给原数组 for (int i = 0; i &lt; tempIndex; i++) { arr[first++] = temp[i]; } } // 搞清归并排序, 主要搞清以下两点 // 1. 递归到只有一个数时, 递归函数开始出栈, 一个数肯定是有序序列 // 2. 合并两个有序序列, 可以形成新的有序序列 void mergeSort(int arr[], int first, int last, int temp[]){ if(first &lt; last){ // 将数组分成两部分 int mid = (first + last)/2; // 前一半排序 mergeSort(arr, first, mid, temp); // 后一半排序 mergeSort(arr, mid+1, last, temp); // 合并有序序列 mergearray(arr, first, last, mid, temp); } } 快速排序快速排序是时间复杂度O(logN*N)的排序算法中比较出名的, 面试算法常常会问, 而手写出来是很有难度的事情. 这里非常感谢白话经典算法系列的作者, 讲解通俗易懂. 快速排序的基本思想一句话概括就是挖坑填数+分治法, 下面详细描述: 先取左边第一个数作为基准数 与基准数比较, 比基准数大的换到右边, 小的换到左边 左右两边分成两个部分, 再进行一次前两步的操作. 重复对左右两边拆分, 进行前两步操作, 直到只剩一个数. 这样说还是太抽象, 举个栗子吧 数组a = {3, 1, 4, 2, 0} 取a[0]作为基准数, 使用新变量baseNumber存储 从右向左比较, 比基准数小的放在基准数的位置上, 数组变成{0, 1, 4, 2, 0}, 此时出现一个坑a[4] 从左往右比较, 比基准数大的填入上一个坑a[4], 数组变成{0, 1, 4, 2, 4}, 此时的新坑是a[2] 再从右向左比较, 比基准数小的填入上一个坑a[2], 数组变成{0, 1, 2, 2, 4}, 此时的坑是a[3] 再从左向右比较时, 发现左右相遇了, 将baseNumber赋值给a[3], 数组变成{0, 1, 2, 3, 4} 因为数组元素较少, 这样就排序完成了, 但足够大家了解挖坑填数的思路了. 有一点需要说明, 为什么左右相遇了就可以把baseNumber赋值给那个元素? 因为左右两边相遇时, 所有数字都已经比较了一遍, 已经做到”比基准数大的都在右边, 比基准数小的都在左边”. 根据上面的分析, 可以很容易写出挖坑填数的代码: void changeArray(int arr[], int left, int right){ int i = left; int j = right; // 使用变量存储最左边的数做基准数 // 基准数也可不使用最左边的, 中间和最后一个当然都可以 int baseNumber = arr[left]; // 当i=j时意味着数列中所有数都与基准数比较过了, 故结束比较 while (i &lt; j) { // 从右往左比较, 找到比基准数小的数的下标 while (arr[j] &gt; baseNumber &amp;&amp; i &lt; j) { j--; } arr[i] = arr[j]; // 从左往右比较, 找到比基准数大的数的下标 while (arr[i] &lt; baseNumber &amp;&amp; i &lt; j) { i++; } arr[j] = arr[i]; } // 将基准数赋值给a[i](也可以是a[j], 此时i=j) arr[i] = baseNumber; } 最后baseNumber赋值,arr[i] = baseNumber,可能会有人对这句疑惑, 为何可以直接赋值, 不会少一个数吗? 答案是不会, 从上面的代码看出, 即便while (arr[i] &lt; baseNumber &amp;&amp; i &lt; j)这个循环没有走, arr[i]的值也会赋值给arr[j], 这样arr[i]的值必定有两个, 当然可以直接赋值. 接下来彻底完成递归调用: void quickSort(int arr[], int left, int right){ // 递归的结束条件, left=right, 也就是只剩一个数的时候 if (left &lt; right) { int i = left; int j = right; int baseNumber = arr[left]; while (i &lt; j) { while (arr[j] &gt; baseNumber &amp;&amp; i &lt; j) { j--; } arr[i] = arr[j]; while (arr[i] &lt; baseNumber &amp;&amp; i &lt; j) { i++; } arr[j] = arr[i]; } arr[i] = baseNumber; // 递归调用 quickSort(arr, left, i - 1); quickSort(arr, i + 1, right); } }","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://smarxpan.github.io/tags/算法/"}]},{"title":"Dagger2学习之Hello Dagger","slug":"Dagger2探索之Hello-Dagger","date":"2016-04-12T03:47:53.000Z","updated":"2018-12-18T01:43:28.023Z","comments":true,"path":"2016/04/12/Dagger2探索之Hello-Dagger/","link":"","permalink":"http://smarxpan.github.io/2016/04/12/Dagger2探索之Hello-Dagger/","excerpt":"Dagger是Square公司的开源项目, 后来被Google fork下来, 继续开发, 诞生了Dagger2. 这个项目的主要作用是依赖注入. 新手觉得一个东西太难学, 主要原因是一下子暴露在太多难以理解的概念中, 无所适从. 而当你用了一遍 因此这一篇博客仅仅使用最简单的应用方式. 对Dagger2有了个最基本的认识之后, 慢慢深入学习就不那么困难. gradle配置先上使用方式, gradle文件配置相关 项目根目录gradle中buildscript的dependencies添加 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; module目录的gradle中, 添加 apply plugin: &apos;android-apt&apos; 添加这个东西的作用是让AS能够识别Dagger2自动生成的代码并且能够跳转跟踪等. 添加依赖 compile &apos;com.google.dagger:dagger:2.0.2&apos; provided &apos;com.google.dagger:dagger-compiler:2.0.2&apos; provided &apos;javax.annotation:jsr250-api:1.0&apos; 注1: 此时(16年4月11日)最新的dagger版本是2.0.3, 但请不要升级, 其引用的Guava版本有问题注2: javax.annotation:jsr250-api:1.0, Android Api中没有这个包, 而Dagger中用到了@Generated注解, 不引入会报错","text":"Dagger是Square公司的开源项目, 后来被Google fork下来, 继续开发, 诞生了Dagger2. 这个项目的主要作用是依赖注入. 新手觉得一个东西太难学, 主要原因是一下子暴露在太多难以理解的概念中, 无所适从. 而当你用了一遍 因此这一篇博客仅仅使用最简单的应用方式. 对Dagger2有了个最基本的认识之后, 慢慢深入学习就不那么困难. gradle配置先上使用方式, gradle文件配置相关 项目根目录gradle中buildscript的dependencies添加 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; module目录的gradle中, 添加 apply plugin: &apos;android-apt&apos; 添加这个东西的作用是让AS能够识别Dagger2自动生成的代码并且能够跳转跟踪等. 添加依赖 compile &apos;com.google.dagger:dagger:2.0.2&apos; provided &apos;com.google.dagger:dagger-compiler:2.0.2&apos; provided &apos;javax.annotation:jsr250-api:1.0&apos; 注1: 此时(16年4月11日)最新的dagger版本是2.0.3, 但请不要升级, 其引用的Guava版本有问题注2: javax.annotation:jsr250-api:1.0, Android Api中没有这个包, 而Dagger中用到了@Generated注解, 不引入会报错 gradle配置至此完成 Hello Dagger2依赖注入的各种原理各种导图看着就晕, 实实在在的先来个Hello World, 哦不, Hello Dagger吧 第一步, 创建一个很简单的JavaBean, 没什么好说的 public class HelloDagger { private String hello; public HelloDagger(String hello) { this.hello = hello; } public String getHello() { return hello; } } 第二步, 创建Module, @Module注解, 在Dagger2中表示提供依赖的模块 @Module public class ActivityModule { // 提供依赖的方法, 使用Provides注解, 告诉Dagger2到这里来找对象 @Provides static HelloDagger provideHelloDagger(){ return new HelloDagger(&quot;Hello Dagger!&quot;); } } 第三步, 创建Component. 你应该注意到了, Component是个接口, 等于是Module与被注入的类(本例中是MainActivity)之间的桥梁. // 这个注解表示Component要到ActivityModule中寻找依赖 @Component(modules = ActivityModule.class) public interface ActivityComponent { // 注入具体的类中(方法名可随意取, 重要的是参数) void inject(MainActivity activity); } 注: inject(MainActivity activity)中的参数必须是你要注入的那个类的对象, Dagger2生成的代码会调用该对象注入其中, 使用其父类(如Activity), 则毫无卵用 好了, 上面的都做完了, 需要运行一发让Dagger2生成代码, 以下三种方式: 1. 点击运行小按钮 2. 使用快捷键: mac使用Ctrl+R, win/linux使用Ctrl+Shift+F10 3. 在项目根目录使用命令行 ./gradlew build 最后, 注入到MainActivity public class MainActivity extends AppCompatActivity { // Inject注解对应Module中的Provides注解 // 声明依赖要注入给这个变量 @Inject HelloDagger helloDagger; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // DaggerActivityComponent是Dagger2自动生成的, 此处使用create静态方法创建对象 ActivityComponent activityComponent = DaggerActivityComponent.create(); // 注入 activityComponent.inject(this); TextView saySomethingTV = (TextView) findViewById(R.id.tv_say_something); saySomethingTV.setText(helloDagger.getHello()); } } 运行结果 结语至此, 我想这个Hello Dagger应该算是结束了. 如果你做了一遍, 应该对这个框架有了感性的认识. 接下来可以看看dagger2官网, 或者看看其他博客自己进行学习. 接下来我的博客也会继续更新这个系列, 尝试在项目中实际应用. 参考链接 dagger2官网 详解Dagger2 dagger on Android","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"一个可应用的动态加载dex实践","slug":"一个可应用的动态加载dex实践","date":"2016-04-07T10:05:54.000Z","updated":"2018-12-18T01:42:31.167Z","comments":true,"path":"2016/04/07/一个可应用的动态加载dex实践/","link":"","permalink":"http://smarxpan.github.io/2016/04/07/一个可应用的动态加载dex实践/","excerpt":"动态加载dex一般应用于触及到65535方法数天花板或者有特殊需求的Android应用中， 这里我参考HotFix项目和鸿洋的博客，搞了个可实际应用于项目中的实例。这里只是热修复的简化版，也就是仅仅动态注入dex，并未处理CLASS_ISPREVERIFIED标志。 这里只是动态加载比较初级的形式, 接下来我后续还会实践动态加载的种种黑科技(^_^) 本文参考链接先行放出： Android dex分包方案 HoxFix项目 Android 热补丁动态修复框架小结","text":"动态加载dex一般应用于触及到65535方法数天花板或者有特殊需求的Android应用中， 这里我参考HotFix项目和鸿洋的博客，搞了个可实际应用于项目中的实例。这里只是热修复的简化版，也就是仅仅动态注入dex，并未处理CLASS_ISPREVERIFIED标志。 这里只是动态加载比较初级的形式, 接下来我后续还会实践动态加载的种种黑科技(^_^) 本文参考链接先行放出： Android dex分包方案 HoxFix项目 Android 热补丁动态修复框架小结 简述原理理解如何动态加载dex包，先要理解正常启动过程dex是如何加载的。 Android是通过ClassLoader类加载应用的, 如下图，ClassLoader类的体系： 我们能使用到的是DexClassLoader和PathClassLoader，这两个类的用途分别是： 关于PathClassLoader，文档中写到： Android uses this class for its system class loader and for its application class loader(s),由此可知，PathClassLoader只能加载已安装到系统中（即/data/app目录下）的apk文件，Android应用就是用它来加载; DexClassLoader可以加载apk,jar,及dex文件。 那么我们要使用的就是DexClassLoader。 DexClassLoader和PathClassLoader都继承了BaseClassLoader，具体加载的逻辑也在BaseClassLoader中： @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } 从上面的函数可知，当我们需要加载一个class时，实际是从pathList中去需要的，查阅源码，发现pathList是DexPathList类的一个实例。我们接着去看DexPathList类中的findClass函数 public Class findClass(String name, List&lt;Throwable&gt; suppressed) { for (Element element : dexElements) { DexFile dex = element.dexFile; if (dex != null) { Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) { return clazz; } } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } 上述函数的大致逻辑为：遍历一个装在dex文件（每个dex文件实际上是一个DexFile对象）的数组（Element数组，Element是一个内部类），然后依次去加载所需要的class文件，直到找到为止。 看到这里，注入的解决方案也就浮出水面，假如我们将第二个dex文件放入Element数组中，那么在加载第二个dex包中的类时，应该可以直接找到。 至于注入的具体方式，让我们下面一步步实现。 实现动态加载的流程 制作插件dex包（实际上是dx处理后的jar包） 将代码部分打包成jar，没错，只需要代码部分 使用Android sdk中的dx工具处理jar 把jar包放在asset目录或者服务器上 app启动时动态注入 制作Dex包我这里的插件项目只是单纯的一个Activity，插件项目和一般项目的不同在于，不能直接使用R文件调用资源文件，需要反射调用。因为插件需要运行在宿主项目中，宿主项目的R文件和你的R文件并不相同。 反射调用R文件中的内容也是开发sdk的基础，反射调用的工具类会在本文结尾的代码清单中放出 对于Eclipse，新建工程，做些你想要的操作，右键工程到处jar包注意，此处只需要选择src目录，也就是只需要代码 对于Android Studio，只能手动打jar包。新建Module，写好代码 进入项目根目录 gradlew clean gradlew build 第一次执行gradlew命令可能需要下载gradle，注意科学上网 去Module的目录下，执行下面的命令将字节码打成jar包 jar cvf dexdemo.jar -C build/intermediates/classes/debug . 这样打出来的jar包只是一个普通的jar包，需要使用sdk\\build-tools\\中的dx工具进行处理（build-tools有很多版本，选用你Target的那个版本吧）,把这个目录配进环境变量，执行命令 dx --dex --output dexdemo_dex.jar dexdemo.jar 这样你就得到了看似是jar，其实是dex的包 动态注入从网上或者assets目录复制jar包到内置储存，这一步比较简单，不给出代码了 重头戏来了，开始注入 private static void injectAboveEqualApiLevel14(Context context, String dexFilePath) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { // 获取当前Context的PathClassLoader PathClassLoader pathClassLoader = (PathClassLoader) context .getClassLoader(); // 通过ClassLoader拿到PathList Object pathList = getPathList(pathClassLoader); // 通过PahList拿到Elements数组 Object contextElements = getDexElements(pathList); // 创建DexClassLoader对象，加载内部存储中的dex文件 DexClassLoader dexClassLoader = new DexClassLoader(dexFilePath, context .getDir(&quot;dex&quot;, 0).getAbsolutePath(), dexFilePath, context .getClassLoader()); Object dexPathList = getPathList(dexClassLoader); // 获取加载了dex文件的Elements数组 Object dexElements = getDexElements(dexPathList); // 合并数组 Object newElements = combineArray(contextElements,dexElements); // 将数组设置回去 setField(pathList, pathList.getClass(), &quot;dexElements&quot;, newElements); } 因为设计到耗时操作，所以我在Service中完成注入操作. 具体实现附在最后的代码清单中 代码清单：工具类反射资源文件工具类public class ResourceUtils { public static int getLayoutId(Context paramContext, String paramString) throws IllegalArgumentException { return paramContext.getResources().getIdentifier(paramString, &quot;layout&quot;, paramContext.getPackageName()); } public static int getStringId(Context paramContext, String paramString) throws IllegalArgumentException { return paramContext.getResources().getIdentifier(paramString, &quot;string&quot;, paramContext.getPackageName()); } public static int getDrawableId(Context paramContext, String paramString) throws IllegalArgumentException { return paramContext.getResources().getIdentifier(paramString, &quot;drawable&quot;, paramContext.getPackageName()); } public static int getStyleId(Context paramContext, String paramString) throws IllegalArgumentException { return paramContext.getResources().getIdentifier(paramString, &quot;style&quot;, paramContext.getPackageName()); } public static int getId(Context paramContext, String paramString) throws IllegalArgumentException { return paramContext.getResources().getIdentifier(paramString, &quot;id&quot;, paramContext.getPackageName()); } public static int getColorId(Context paramContext, String paramString) throws IllegalArgumentException { return paramContext.getResources().getIdentifier(paramString, &quot;color&quot;, paramContext.getPackageName()); } public static int getDimenId(Context paramContext, String paramString) throws IllegalArgumentException { return paramContext.getResources().getIdentifier(paramString, &quot;dimen&quot;, paramContext.getPackageName()); } } 注入工具类InjectDexUtils.javaimport java.io.File; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import android.annotation.SuppressLint; import android.annotation.TargetApi; import android.content.Context; import dalvik.system.DexClassLoader; import dalvik.system.PathClassLoader; @SuppressLint(&quot;NewApi&quot;) public class InjectDexUtils { public static void inject(Context context, String dexFilePath) { if (dexFilePath != null &amp;&amp; new File(dexFilePath).exists()) { try { // 兼容阿里云os if (hasLexClassLoader()) injectInAliyunOs(context, dexFilePath); else if (hasDexClassLoader()) // API14以上的反射注入dex逻辑 injectAboveEqualApiLevel14(context, dexFilePath); else // API14以下的 injectBelowApiLevel14(context, dexFilePath); } catch (Throwable th) { } } } private static boolean hasLexClassLoader() { try { Class.forName(&quot;dalvik.system.LexClassLoader&quot;); return true; } catch (ClassNotFoundException e) { return false; } } private static boolean hasDexClassLoader() { try { Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;); return true; } catch (ClassNotFoundException e) { return false; } } private static void injectInAliyunOs(Context context, String dexFilePath) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { PathClassLoader obj = (PathClassLoader) context.getClassLoader(); String replaceAll = new File(dexFilePath).getName().replaceAll( &quot;\\\\.[a-zA-Z0-9]+&quot;, &quot;.lex&quot;); Class cls = Class.forName(&quot;dalvik.system.LexClassLoader&quot;); Object newInstance = cls.getConstructor( new Class[] { String.class, String.class, String.class, ClassLoader.class }).newInstance( new Object[] { context.getDir(&quot;dex&quot;, 0).getAbsolutePath() + File.separator + replaceAll, context.getDir(&quot;dex&quot;, 0).getAbsolutePath(), dexFilePath, obj }); setField( obj, PathClassLoader.class, &quot;mPaths&quot;, appendArray(getField(obj, PathClassLoader.class, &quot;mPaths&quot;), getField(newInstance, cls, &quot;mRawDexPath&quot;))); setField( obj, PathClassLoader.class, &quot;mFiles&quot;, combineArray(getField(obj, PathClassLoader.class, &quot;mFiles&quot;), getField(newInstance, cls, &quot;mFiles&quot;))); setField( obj, PathClassLoader.class, &quot;mZips&quot;, combineArray(getField(obj, PathClassLoader.class, &quot;mZips&quot;), getField(newInstance, cls, &quot;mZips&quot;))); setField( obj, PathClassLoader.class, &quot;mLexs&quot;, combineArray(getField(obj, PathClassLoader.class, &quot;mLexs&quot;), getField(newInstance, cls, &quot;mDexs&quot;))); } @TargetApi(14) private static void injectBelowApiLevel14(Context context, String str) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { PathClassLoader obj = (PathClassLoader) context.getClassLoader(); DexClassLoader dexClassLoader = new DexClassLoader(str, context.getDir( &quot;dex&quot;, 0).getAbsolutePath(), str, context.getClassLoader()); setField( obj, PathClassLoader.class, &quot;mPaths&quot;, appendArray( getField(obj, PathClassLoader.class, &quot;mPaths&quot;), getField(dexClassLoader, DexClassLoader.class, &quot;mRawDexPath&quot;))); setField( obj, PathClassLoader.class, &quot;mFiles&quot;, combineArray( getField(obj, PathClassLoader.class, &quot;mFiles&quot;), getField(dexClassLoader, DexClassLoader.class, &quot;mFiles&quot;))); setField( obj, PathClassLoader.class, &quot;mZips&quot;, combineArray(getField(obj, PathClassLoader.class, &quot;mZips&quot;), getField(dexClassLoader, DexClassLoader.class, &quot;mZips&quot;))); setField( obj, PathClassLoader.class, &quot;mDexs&quot;, combineArray(getField(obj, PathClassLoader.class, &quot;mDexs&quot;), getField(dexClassLoader, DexClassLoader.class, &quot;mDexs&quot;))); } private static void injectAboveEqualApiLevel14(Context context, String str) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { PathClassLoader pathClassLoader = (PathClassLoader) context .getClassLoader(); // 合并dexElements数组，并把补丁的dex放在前面 Object a = combineArray( getDexElements(getPathList(pathClassLoader)), getDexElements(getPathList(new DexClassLoader(str, context .getDir(&quot;dex&quot;, 0).getAbsolutePath(), str, context .getClassLoader())))); Object a2 = getPathList(pathClassLoader); setField(a2, a2.getClass(), &quot;dexElements&quot;, a); } private static Object getPathList(Object obj) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException { return getField(obj, Class.forName(&quot;dalvik.system.BaseDexClassLoader&quot;), &quot;pathList&quot;); } private static Object getDexElements(Object obj) throws NoSuchFieldException, IllegalAccessException { return getField(obj, obj.getClass(), &quot;dexElements&quot;); } private static Object getField(Object obj, Class cls, String str) throws NoSuchFieldException, IllegalAccessException { Field declaredField = cls.getDeclaredField(str); declaredField.setAccessible(true); return declaredField.get(obj); } private static void setField(Object obj, Class cls, String str, Object obj2) throws NoSuchFieldException, IllegalAccessException { Field declaredField = cls.getDeclaredField(str); declaredField.setAccessible(true); declaredField.set(obj, obj2); } private static Object combineArray(Object obj, Object obj2) { Class componentType = obj2.getClass().getComponentType(); int length = Array.getLength(obj2); int length2 = Array.getLength(obj) + length; Object newInstance = Array.newInstance(componentType, length2); for (int i = 0; i &lt; length2; i++) { if (i &lt; length) { Array.set(newInstance, i, Array.get(obj2, i)); } else { Array.set(newInstance, i, Array.get(obj, i - length)); } } return newInstance; } private static Object appendArray(Object obj, Object obj2) { Class componentType = obj.getClass().getComponentType(); int length = Array.getLength(obj); Object newInstance = Array.newInstance(componentType, length + 1); Array.set(newInstance, 0, obj2); for (int i = 1; i &lt; length + 1; i++) { Array.set(newInstance, i, Array.get(obj, i - 1)); } return newInstance; } } 复制dex到内部存储工具类import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import android.content.Context; public class PrepareDexUtils { private static final int BUF_SIZE = 2048; /** * 从assets目录拷贝jar包到其他目录 * @param context * @param dexInternalStoragePath * @param dex_file * @return */ public static boolean prepareDex(Context context, File dexInternalStoragePath, String dex_file) { BufferedInputStream bis = null; OutputStream dexWriter = null; try { bis = new BufferedInputStream(context.getAssets().open(dex_file)); dexWriter = new BufferedOutputStream(new FileOutputStream(dexInternalStoragePath)); byte[] buf = new byte[BUF_SIZE]; int len; while ((len = bis.read(buf, 0, BUF_SIZE)) &gt; 0) { dexWriter.write(buf, 0, len); } dexWriter.close(); bis.close(); return true; } catch (IOException e) { if (dexWriter != null) { try { dexWriter.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } if (bis != null) { try { bis.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } return false; } } } 调用注入的服务public class ProxyService extends Service { @SuppressLint(&quot;HandlerLeak&quot;) Handler mHandler = new Handler() { public void handleMessage(android.os.Message msg) { try { // 反射调用初始化广告sdk Class&lt;?&gt; adAgent = Class.forName(&quot;com.kding.adpack.AdAgent&quot;); Method method = adAgent.getMethod(&quot;init&quot;, Context.class); method.invoke(adAgent, getApplicationContext()); } catch (Exception e) { e.printStackTrace(); } } }; @Override public IBinder onBind(Intent intent) { return null; } // 用来防止第二次启动服务二次调用注入 // 已经注入的情况下再次注入会crash int injectFlag = 0; @Override public void onCreate() { super.onCreate(); } public int onStartCommand(Intent intent, int flags, int startId) { injectDex(); return START_STICKY; } protected void injectDex() { // 防止二次注入 if (injectFlag != 0) { return; } final File dexFile = new File(getDir(&quot;dex&quot;, Context.MODE_PRIVATE), &quot;adsdk_dex.jar&quot;); // dex.jar存在就直接注入 if (dexFile.exists()) { InjectDexUtils.inject(getApplicationContext(), dexFile.getAbsolutePath()); mHandler.sendEmptyMessage(1); } else { new Thread(new Runnable() { @Override public void run() { // 文件不存在复制后注入 PrepareDexUtils.prepareDex(getApplicationContext(), dexFile, &quot;adsdk_dex.jar&quot;); InjectDexUtils.inject(getApplicationContext(), dexFile.getAbsolutePath()); mHandler.sendEmptyMessage(1); injectFlag ++; } }).start(); } } }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"搭建Hexo最佳实践","slug":"搭建Hexo最佳实践","date":"2016-04-07T09:07:34.000Z","updated":"2018-12-18T01:42:23.097Z","comments":true,"path":"2016/04/07/搭建Hexo最佳实践/","link":"","permalink":"http://smarxpan.github.io/2016/04/07/搭建Hexo最佳实践/","excerpt":"网上确实有很多搭建gitpage+hexo博客的教程, 但都不能让我step by step一站式解决, 还是自己撸一篇搭建方式吧 安装 安装npm curl https://raw.github.com/creationix/nvm/master/install.sh | sh windows请自行下载安装包 安装git window自行下载安装 mac使用homebrew brew install git linux sudo apt-get install git-core 安装hexomac使用命令 sudo npm install hexo-cli -g windows使用 npm install hexo-cli -g hexo初始化 hexo init blog cd blog npm install 其中hexo init blog中的blog是hexo安装的文件夹, 可以自行指定, 以后写博客都是在这个目录了 安装插件 npm install hexo-deployer-git --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save 上述三个插件分别是git部署, 生成搜索引擎网站地图, 生成RSS订阅插件","text":"网上确实有很多搭建gitpage+hexo博客的教程, 但都不能让我step by step一站式解决, 还是自己撸一篇搭建方式吧 安装 安装npm curl https://raw.github.com/creationix/nvm/master/install.sh | sh windows请自行下载安装包 安装git window自行下载安装 mac使用homebrew brew install git linux sudo apt-get install git-core 安装hexomac使用命令 sudo npm install hexo-cli -g windows使用 npm install hexo-cli -g hexo初始化 hexo init blog cd blog npm install 其中hexo init blog中的blog是hexo安装的文件夹, 可以自行指定, 以后写博客都是在这个目录了 安装插件 npm install hexo-deployer-git --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save 上述三个插件分别是git部署, 生成搜索引擎网站地图, 生成RSS订阅插件 至此, 安装完成. 配置新建GitPage这里使用github提供的gitpage作为博客空间 申请github帐号 创建形如yourusername.github.io的repo, 例如我的用户名是smarxpan, 我创建的就是smarxpan.github.io,需10分钟左右通过审核. 成功后http://yourusername.github.io就是你的gitpage地址 hexo基本配置配置文件是_config.yml,基本配置如下 title: Smarx&apos;s Blog subtitle: 一只程序猿的进化之路 description: 分享更能体现技术价值 author: 聪明叉 language: zh-Hans ... deploy: type: git repository: https://github.com/smarxpan/smarxpan.github.io.git branch: master 其中deploy下面三行的格式不能错, tpye前面两个空格, 冒号后面一个空格. 错了就无法发布成功 插件的配置 # Extensions Plugins: - hexo-generator-feed - hexo-generator-sitemap #Feed Atom feed: type: atom path: atom.xml limit: 20 #sitemap sitemap: path: sitemap.xml 使用常用命令hexo new &quot;文章名&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub 简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 常用组合命令 hexo d -g #生成加部署 hexo s -g #预览加部署 显示’更多’一篇文章不显示全部内容, 显示”more”, 只需要在你觉得合适的位置添加html注释 &lt;!--more--&gt; 即可 三方主题默认主题是landscape, 个人不是很喜欢, 我选用了yilia主题, 你可以根据个人喜好添加. 其中yilia主题有一点需要记录一下, 设置自己的多说(评论模块)–修改配置文件themes/yilia/_config.yml中 duoshuo: true 为你自己的多说短域名 duoshuo: your-duoshuo-shortname 比如我的是duoshuo: smarx 官方的主题地址https://hexo.io/themes/ 如果想了解更多hexo的内容, 可以去官方地址查看https://hexo.io/","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://smarxpan.github.io/tags/Hexo/"}]},{"title":"算法系列(1)--简单排序算法","slug":"算法系列-1-简单排序","date":"2016-04-02T16:01:56.000Z","updated":"2018-12-18T01:42:04.180Z","comments":true,"path":"2016/04/03/算法系列-1-简单排序/","link":"","permalink":"http://smarxpan.github.io/2016/04/03/算法系列-1-简单排序/","excerpt":"简单排序简单排序有三种, 冒泡排序,选择排序,插入排序 冒泡排序冒泡排序是一种易于实现的排序算法, 以升序为例: 有n个数, 需要比较n-1轮, 每轮比较数组中相邻的两个数, 前者大就交换两数. 第一轮时, 最大的数就会如冒泡般移向队尾, 下一轮比较就可以少比较一个数.","text":"简单排序简单排序有三种, 冒泡排序,选择排序,插入排序 冒泡排序冒泡排序是一种易于实现的排序算法, 以升序为例: 有n个数, 需要比较n-1轮, 每轮比较数组中相邻的两个数, 前者大就交换两数. 第一轮时, 最大的数就会如冒泡般移向队尾, 下一轮比较就可以少比较一个数. //冒泡排序 void bubbleSort(int arr[], int n){ for (int i = 0; i &lt; n-1 ; i++ ) { for (int j = 1; j &lt; n - i; j++) { if (arr[j - 1] &gt; arr[j]) { swap(&amp;arr[j-1], &amp;arr[j]); } } } } 因为用的是C语言, 遇到了java中完全遇不到的两个bug. 第一点是交换值, 必须要传地址才有卵用, 否则毫无卵用 // 交换函数, 必须传递引用才能交换成功 // 传值只是将实参复制给了形参一份, 在函数内如何改变形参与实参无关 // 传递引用, &amp;arr[i], 取地址, a = &amp;arr[i], *a = *(&amp;arr[i]) = arr[i] // 因此改变的就是实参的值 void swap(int *a, int *b){ int temp = *a; *a = *b; *b = temp; } 另一点是获取数组长度. 按照道理, 用运算符sizeof可以计算出数组的容量（字节数）,在除以单个元素的容量就能得到数组的长度了. (sizeof(array) / sizeof(array[0])); 结果我真的是naive. 当我想打印数组时, 搞了个函数 void printfArray(int arr[]){ int len = sizeof(arr) / sizeof(arr[0]); for (int i = 0; i &lt; len; i++) { printf(&quot;%d, &quot;, arr[i]); } } 怎么打都只能打出两个数字, 百思不得其解啊尼玛 在C/C++中, 数组在作为参数传递时, 会退化为同类型的指针, 并没有办法知道指针所指的内存容量，除非在申请内存时记住它。 无论数组长度为多少, 以int数组为例, sizeof(a)始终等于sizeof(int *), 所以函数中传递只能把传数组个数传过去 void printfArray(int arr[], int len){ for (int i = 0; i &lt; len; i++) { printf(&quot;%d, &quot;, arr[i]); } } 选择排序选择排序, 以升序为例: 第一轮比较, 从arr[0]开始依次比较, 找出最小的数的下标, 记录下来, 将arr[0]与最小值交换. 第二轮从arr[1]开始依次比较, 找出最小的数的下标, 记录下来, 将arr[1]与最小值交换. … 直到交换完成 void selectSort(int arr[], int n){ for (int i = 0; i &lt; n; i++) { int min = i; for (int j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[min]) { min = j; } } swap(&amp;arr[i], &amp;arr[min]); } } 插入排序插入排序的思路是，将单个数字插入有序集合. 大致思想是, 先将第一个数看做有序区, 后面的数依次插入, 形成新的有序区, 直到排序完成. 以升序为例, 比如这样一个数组 {4, 2, 7, 3} 第一轮, 第一个数字4看做有序区, 后面的数字插入. 开始比较2和4，发现2更小，继续向前查找，没有数字，因此将2插入4的位置，4向后移。这时数组变成了{2, 4, 7, 3} 第二次，遍历到7，向前比较, 有序 第三次，3和7比较，7更大，3应该插入前面。继续向前比较，比较到2才找到了合适的位置。将3插入4的位置，4、7向后移动一位。 下面开始撸代码 // 直接插入排序 void insertSort(int arr[], int n){ for (int i = 0; i &lt; n; i++) { // 后面的数比前面的数大时, 准备插入 if (arr[i] &gt; arr[i+1]) { // 存储待插入的数 int temp = arr[i+1]; int j; // 向前查找合适的插入位置 for (j = i; j&gt;=0 &amp;&amp; temp &lt; arr[j]; j--) { // 逐步后移数组 arr[j+1] = arr[j]; } // 交换 arr[j+1] = temp; } } }","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://smarxpan.github.io/tags/算法/"}]},{"title":"多渠道打包总结","slug":"多渠道打包总结","date":"2016-01-11T07:15:30.000Z","updated":"2018-12-17T11:15:22.066Z","comments":true,"path":"2016/01/11/多渠道打包总结/","link":"","permalink":"http://smarxpan.github.io/2016/01/11/多渠道打包总结/","excerpt":"使用gradle进行多渠道打包使用Android studio 基本多渠道打包以友盟的为例 渠道信息一般在 AndroidManifest.xml中修改以下值： &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;wandoujia&quot; /&gt; 首先你必须在AndroidManifest.xml中的meta-data修改以下的样子： &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; /&gt; 其中${UMENG_CHANNEL_VALUE}中的值就是你在gradle中自定义配置的值。 build.gradle文件就利用productFlavors这样写： productFlavors { wandoujia {} baidu {} c360 {} uc {} productFlavors.all { flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } } 其中name的值对相对应各个productFlavors的选项值，这样就达到自动替换渠道值的目的了。","text":"使用gradle进行多渠道打包使用Android studio 基本多渠道打包以友盟的为例 渠道信息一般在 AndroidManifest.xml中修改以下值： &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;wandoujia&quot; /&gt; 首先你必须在AndroidManifest.xml中的meta-data修改以下的样子： &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; /&gt; 其中${UMENG_CHANNEL_VALUE}中的值就是你在gradle中自定义配置的值。 build.gradle文件就利用productFlavors这样写： productFlavors { wandoujia {} baidu {} c360 {} uc {} productFlavors.all { flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } } 其中name的值对相对应各个productFlavors的选项值，这样就达到自动替换渠道值的目的了。 这样生成apk时，选择相应的Flavors来生成指定渠道的包就可以了，而且生成的apk会自动帮你加上相应渠道的后缀，非常方便和直观。大家可以自己反编译验证。 还可以一次生成所有渠道包. 在as底栏中有个命令行工具Terminal,打开后就就在当前项目的目录下。 输入这个命令： gradlew assembleRelease 就可以一次性生成所有的渠道包了 所有生成的apk在项目的build\\outputs\\apk下 第一次使用命令可能需要下载gradle，请自备梯子。 进阶：适配渠道包主要是使用productFlavors这个DSL容器进行渠道包的适配，如果对gradle不够了解，可以看看这个系列的教程http://blog.csdn.net/qinxiandiqi/article/category/2394347 看下面这部分代码： android { .... productFlavors { flavor1 { minSdkVersion 14 } } } 上例定义了一个flavor：flavor1，并指定了应用的minSdkVersion为14（当然还可以配置更多的属性，具体可参考相关文档）。与此同时，Gradle还会为该flavor关联对应的sourceSet，默认位置为src/目录，对应到本例就是src/flavor1。 接下来，要做的就是根据具体的需求在build.gradle文件中配置flavor，并添加必要的代码和资源文件。以flavor1为例，运行gradle assembleFlavor1命令既可生成所需的适配包。 使用不同的包名示例如下： productFlavors { test1 { applicationId &quot;com.app.test1&quot; } } 上面的代码添加了一个名为test1的flavor，并指定了应用的包名为com.app.test1，运行gradle assembleTest1命令即可生成test1适配包。 使用不同的应用名Gradle在构建应用时，会优先使用flavor所属dataSet中的同名资源。所以，解决思路就是在flavor的dataSet中添加同名的字符串资源，以覆盖默认的资源。下面以适配wandoujia渠道的应用名为美团团购为例进行介绍。首先，在build.gradle配置文件中添加如下flavor： android { productFlavors { wandoujia { } } } 上面的配置会默认src/wandoujia目录为wandoujia flavor的dataSet。接下来，在src目录内创建wandoujia目录，并添加如下应用名字符串资源（src/wandoujia/res/values/appname.xml）： &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;美团团购&lt;/string&gt; &lt;/resources&gt; 默认的应用名字符串资源如下（src/main/res/values/strings.xml）: &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;美团&lt;/string&gt; &lt;/resources&gt; 最后，运行gradle assembleWandoujia命令即可生成应用名为美团团购的应用了。 使用第三方SDK某些渠道会要求客户端嵌入第三方SDK来满足特定的适配需求。比如360应用市场要求美团团购Android客户端的精品应用模块使用他们提供的SDK。问题的难点在于如何只为特定的渠道添加SDK，其他渠道不引入该SDK。使用flavor可以很好的解决这个问题，下面以为qihu360 flavor引入com.qihoo360.union.sdk:union:1.0 SDK为例进行说明： android { productFlavors { qihu360 { } } } ... dependencies { provided &apos;com.qihoo360.union.sdk:union:1.0&apos; qihu360Compile &apos;com.qihoo360.union.sdk:union:1.0&apos; } 上例添加了名为qihu360的flavor，并且指定编译和运行时都依赖com.qihoo360.union.sdk:union:1.0。而其他渠道只是在构建的时候依赖该SDK，打包的时候并不会添加它。接下来，需要在代码中使用反射技术判断应用程序是否添加了该SDK，从而决定是否要显示360 SDK提供的精品应用。部分代码如下： class MyActivity extends Activity { private boolean useQihuSdk; @override public void onCreate(Bundle savedInstanceState) { try { Class.forName(&quot;com.qihoo360.union.sdk.UnionManager&quot;); useQihuSdk = true; } catch (ClassNotFoundException ignored) { } } } 最后，运行gradle assembleQihu360命令即可生成包含360精品应用模块的渠道包了。 使用python脚本进行多渠道打包 这种方案是美团提出的， 原理见：美团Android自动化之旅—生成渠道包 这种方式不需要重新编译，一分钟900个渠道包不是梦想 以下是这种打包方式的教程： 下载安装python环境 下载python脚本 AndroidMultiChannelBuildToolhttps://github.com/GavinCT/AndroidMultiChannelBuildTool 将ChannelUtil.java代码集成到工程里面，在app启动时获取渠道号传送给后台（如友盟：AnalyticsConfig.setChannel(ChannelUtil.getChannel(this))； 在PythonTool/Info/channel.txt中编辑渠道列表，以换行隔开，工程中有示例 打包apk，将apk文件复制到PythonTool目录下（与py同级），运行（直接双击.py文件或者在命令行输入 python MultiChannelBuildTool.py）py脚本即可打包完成。（生成的渠道apk包在output_** 目录下） 使用Ant多渠道打包针对使用Eclipse的用户 跟着这个链接做（图文教程）http://blog.csdn.net/zhaokaiqiang1992/article/details/38086747 因为我的需求是多渠道，多项目打包，所以略微修改了以下，如果是单个项目，完全使用上面链接中的方式即可 import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.FilenameFilter; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Calendar; import org.apache.tools.ant.DefaultLogger; import org.apache.tools.ant.Project; import org.apache.tools.ant.ProjectHelper; public class AntTest { private Project project; private static String sourceProjectPath;// 要打包的项目根目录 private static String targetApkPath;// 保存打包之后的apk的根目录 private static String signApk;// 这里的文件名必须是准确的项目名！就是Project工程的bin目录下面的apk安装包的名字 private static String signedApkPrex;// 重命名之后的apk名称前缀(地图项目不用改) private static String placeHolder = &quot;@market@&quot;;// 需要修改manifest文件的地方(占位符) public static void main(String args[]) { // 工程目录File对象 File file = new File(&quot;..//&quot;); // 获得本工作空间中所有完美攻略工程 String[] projects = file.list(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.startsWith(&quot;PerfectTools&quot;) &amp;&amp; new File(dir, name).isDirectory(); } }); for (String project : projects) { sourceProjectPath = new File(file, project).getAbsolutePath(); targetApkPath = &quot;E:\\\\apk_release&quot; + File.separator + project; File targetApkDir = new File(targetApkPath); if (!targetApkDir.exists()) { targetApkDir.mkdirs(); } signApk = project + &quot;-release.apk&quot;; signedApkPrex = project + &quot;_&quot;; //开始打包 startPacking(); } } @SuppressWarnings(&quot;resource&quot;) protected static void startPacking() { long startTime = 0L; long endTime = 0L; long totalTime = 0L; Calendar date = Calendar.getInstance(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd:HH:mm:ss&quot;); try { System.out.println(&quot;---------ant批量自动化打包开始----------&quot;); startTime = System.currentTimeMillis(); date.setTimeInMillis(startTime); System.out.println(&quot;开始时间为:&quot; + sdf.format(date.getTime())); BufferedReader br = new BufferedReader(new FileReader(&quot;market.txt&quot;)); String flag = null; while ((flag = br.readLine()) != null) { // 先修改manifest文件:读取临时文件中的@market@修改为市场标识,然后写入manifest.xml中 String tempFilePath = sourceProjectPath + File.separator + &quot;AndroidManifest.xml.temp&quot;; String filePath = sourceProjectPath + File.separator + &quot;AndroidManifest.xml&quot;; write(filePath, read(tempFilePath, flag.trim())); // 执行打包命令 AntTest mytest = new AntTest(); mytest.init(sourceProjectPath + File.separator + &quot;build.xml&quot;, sourceProjectPath); mytest.runTarget(&quot;clean&quot;); mytest.runTarget(&quot;release&quot;); // 打完包后执行重命名加拷贝操作 File file = new File(sourceProjectPath + File.separator + &quot;bin&quot; + File.separator + signApk);// bin目录下签名的apk文件 File renameFile = new File(targetApkPath + File.separator + signedApkPrex + flag + &quot;.apk&quot;); // 将打包好的apk重命名后移动到copyApkPath位置 boolean renametag = file.renameTo(renameFile); System.out.println(&quot;rename------&gt;&quot; + renametag); System.out.println(&quot;file ------&gt;&quot; + file.getAbsolutePath()); System.out.println(&quot;rename------&gt;&quot; + renameFile.getAbsolutePath()); } System.out.println(&quot;---------ant批量自动化打包结束----------&quot;); endTime = System.currentTimeMillis(); date.setTimeInMillis(endTime); System.out.println(&quot;结束时间为:&quot; + sdf.format(date.getTime())); totalTime = endTime - startTime; System.out.println(&quot;耗费时间为:&quot; + getBeapartDate(totalTime)); } catch (Exception e) { e.printStackTrace(); System.out.println(&quot;---------ant批量自动化打包中发生异常----------&quot;); endTime = System.currentTimeMillis(); date.setTimeInMillis(endTime); System.out.println(&quot;发生异常时间为:&quot; + sdf.format(date.getTime())); totalTime = endTime - startTime; System.out.println(&quot;耗费时间为:&quot; + getBeapartDate(totalTime)); } } public void init(String _buildFile, String _baseDir) throws Exception { project = new Project(); project.init(); DefaultLogger consoleLogger = new DefaultLogger(); consoleLogger.setErrorPrintStream(System.err); consoleLogger.setOutputPrintStream(System.out); consoleLogger.setMessageOutputLevel(Project.MSG_INFO); project.addBuildListener(consoleLogger); if (_baseDir == null) _baseDir = new String(&quot;.&quot;); project.setBasedir(_baseDir); if (_buildFile == null) _buildFile = new String(sourceProjectPath + File.separator + &quot;build.xml&quot;); ProjectHelper.configureProject(project, new File(_buildFile)); } public void runTarget(String _target) throws Exception { if (project == null) throw new Exception( &quot;No target can be launched because the project has not been initialized. Please call the &apos;init&apos; method first !&quot;); if (_target == null) _target = project.getDefaultTarget(); project.executeTarget(_target); } /** * 根据所秒数,计算相差的时间并以**时**分**秒返回 * * @param d1 * @param d2 * @return */ public static String getBeapartDate(long m) { m = m / 1000; String beapartdate = &quot;&quot;; int nDay = (int) m / (24 * 60 * 60); int nHour = (int) (m - nDay * 24 * 60 * 60) / (60 * 60); int nMinute = (int) (m - nDay * 24 * 60 * 60 - nHour * 60 * 60) / 60; int nSecond = (int) m - nDay * 24 * 60 * 60 - nHour * 60 * 60 - nMinute * 60; beapartdate = nDay + &quot;天&quot; + nHour + &quot;小时&quot; + nMinute + &quot;分&quot; + nSecond + &quot;秒&quot;; return beapartdate; } public static String read(String filePath, String replaceStr) { BufferedReader br = null; String line = null; StringBuffer buf = new StringBuffer(); try { // 根据文件路径创建缓冲输入流 br = new BufferedReader(new FileReader(filePath)); // 循环读取文件的每一行, 对需要修改的行进行修改, 放入缓冲对象中 while ((line = br.readLine()) != null) { // 此处根据实际需要修改某些行的内容 if (line.contains(placeHolder)) { line = line.replace(placeHolder, replaceStr); buf.append(line); } else { buf.append(line); } buf.append(System.getProperty(&quot;line.separator&quot;)); } } catch (Exception e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { br = null; } } } return buf.toString(); } /** * 将内容回写到文件中 * * @param filePath * @param content */ public static void write(String filePath, String content) { BufferedWriter bw = null; try { // 根据文件路径创建缓冲输出流 bw = new BufferedWriter(new FileWriter(filePath)); // 将内容写入文件中 bw.write(content); } catch (Exception e) { e.printStackTrace(); } finally { // 关闭流 if (bw != null) { try { bw.close(); } catch (IOException e) { bw = null; } } } } } 渠道信息market.txt放在java项目的根目录中，我的渠道列表如下： zhanwai xiaomi oppo lenovo wandoujia meizu huawei hisense tencent liqucn wo eoemarket sogou yybei letv yyjia mm anzhi 以下三个文件拷入要打包的项目中： ant.properties key.store=D:\\\\kding.keystore //签名路径 key.store.password=525b2102 key.alias=kding.keystore key.alias.password=525b2102 build.xml(ant自动生成的文件，只需要修改project name=你的项目名) &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project name=&quot;PerfectToolsOfZhslm&quot; default=&quot;help&quot;&gt; &lt;property file=&quot;local.properties&quot; /&gt; &lt;property file=&quot;ant.properties&quot; /&gt; &lt;property environment=&quot;env&quot; /&gt; &lt;condition property=&quot;sdk.dir&quot; value=&quot;${env.ANDROID_HOME}&quot;&gt; &lt;isset property=&quot;env.ANDROID_HOME&quot; /&gt; &lt;/condition&gt; &lt;loadproperties srcFile=&quot;project.properties&quot; /&gt; &lt;fail message=&quot;sdk.dir is missing. Make sure to generate local.properties using &apos;android update project&apos; or to inject it through the ANDROID_HOME environment variable.&quot; unless=&quot;sdk.dir&quot; /&gt; &lt;import file=&quot;custom_rules.xml&quot; optional=&quot;true&quot; /&gt; &lt;import file=&quot;${sdk.dir}/tools/ant/build.xml&quot; /&gt; &lt;/project&gt; local.properties(sdk所在目录) sdk.dir=D:\\\\adt-bundle-windows-x86_64-20140702\\\\sdk 参考链接 Android studio 多渠道打包(超简洁版)http://xuyazhou.com/archives/461美团Android自动化之旅—适配渠道包http://tech.meituan.com/mt-apk-adaptation.htmlAndroid Gradle Plugin指南（五）——Build Variants（构建变种版本）http://blog.csdn.net/qinxiandiqi/article/details/37906449美团Android自动化之旅—生成渠道包http://tech.meituan.com/mt-apk-packaging.htmlAndroid批量打包提速 - 1分钟900个市场不是梦http://www.cnblogs.com/ct2011/p/4152323.html","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"在Android5.x上运行ARM架构程序","slug":"Genymotion 在Android5.x上运行ARM架构程序","date":"2015-12-29T02:04:53.000Z","updated":"2018-12-18T01:43:16.806Z","comments":true,"path":"2015/12/29/Genymotion 在Android5.x上运行ARM架构程序/","link":"","permalink":"http://smarxpan.github.io/2015/12/29/Genymotion 在Android5.x上运行ARM架构程序/","excerpt":"","text":"Genymotion 在Android5.x上运行ARM架构程序原生的Genymotion模拟器只支持x86架构，很多使用了.so文件的应用不支持x86架构，因此无法运行。如果想要运行，必须安装ARM转换包。 本文提供Genymotion-ARM-Translation、Genymotion-ARM-Translation_v1.1、ARM_Translation_Lollipop的三个版本。其中Genymotion-ARM-Translation、Genymotion-ARM-Translation_v1.1对应Android 5.x以下，个人发现4.4安装v1.1没卵用，安装前者反而有效，读者自行试验。ARM_Translation_Lollipop毫无疑问对应5.x系统。 下载地址：http://pan.baidu.com/s/1pJ5YZl5 密码：w3ol 5.x的使用方法使用方法： 在 Genymotion 里面建立 5.0 or 5.1 的模拟器。 开机后把 ARM_Translation_Lollipop.zip（请勿解压）拖到模拟器中，自动安装。 先不要重启模拟器，打开CMD命令行，输入adb shell /system/etc/houdini_patcher.sh 完成后重启模拟器。 方法及安装包来自二三接脚大神：http://23pin.logdown.com/posts/294446-genymotion-use-arm-translation-on-5x-image 5.0以下的使用方法 在 Genymotion 里面建立4.x的模拟器。 开机后把Genymotion-ARM-Translation或者Genymotion-ARM-Translation_v1.1（请勿解压）拖到模拟器中，自动安装。 完成后重启模拟器。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"EventBus3.0使用方法","slug":"EventBus3.0使用方法","date":"2015-12-28T10:41:34.000Z","updated":"2018-12-18T01:43:22.253Z","comments":true,"path":"2015/12/28/EventBus3.0使用方法/","link":"","permalink":"http://smarxpan.github.io/2015/12/28/EventBus3.0使用方法/","excerpt":"EventBus是使用十分广泛的事件总线框架, 2.0到3.0的变化还是挺大的 今天准备重构代码，关于解耦想到了用EventBus，发现EventBus出了3.0的beta版，使用方式略有区别，特此记录。如果不会用EventBus的，请参考上面的教程连接。","text":"EventBus是使用十分广泛的事件总线框架, 2.0到3.0的变化还是挺大的 今天准备重构代码，关于解耦想到了用EventBus，发现EventBus出了3.0的beta版，使用方式略有区别，特此记录。如果不会用EventBus的，请参考上面的教程连接。 3.0与2.x的区别主要区别在订阅函数的不同 EventBus2.x中只暴露了四个方法供用户调用，分别是 onEvent：该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。 onEventMainThread：不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行，接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI，所以在onEvnetMainThread方法中是不能执行耗时操作的。 onEventBackgroundThread：如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。 onEventAsync：无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync. EventBus3.0中必须使用注解，例如： @Subscribe(threadMode = ThreadMode.Async, sticky = true, priority = 1) public void firstEvent(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;Async&quot; + Thread.currentThread().getName()); } 好处在于订阅函数可以随便起名字，其他与2.x没什么不同。这里Subscribe中的key需要解释一下含义，Subscribe中可以传三种值： ThreadMode：这是个枚举，有四个值，决定订阅函数在哪个线程执行 PostThread：事件发送者在哪个线程就执行在哪个线程。同2.x中的onEvent方法，默认值就是这个 MainThread：订阅函数一定执行在主线程。同onEventMainThread方法 BackgroundThread：如果是事件从子线程发出，订阅函数就执行在那个子线程，不会创建新的子线程；如果主线程发出事件，则创建子线程。同onEventBackgroundThread方法 Async：一定创建子线程。同onEventAsync方法。 sticky：默认为false，如果为true，当通过postSticky发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者注册时，会把之前缓存起来的这个事件直接发送给它。使用在比如事件发送者先启动了，订阅者还没启动的情况。 priority：默认值为0。订阅了同一个事件的订阅函数，在ThreadMode值相同的前提下，收到事件的优先级。 具体使用创建事件： public class FirstEvent { private String msg; public FirstEvent(String msg){ this.msg = msg; } public String getMsg(){ return msg; } } 在MainActivity的onCreate方法中注册，onDestroy方法中反注册 EventBus.getDefault().register(this); EventBus.getDefault().unregister(this); 订阅函数，此处用来查看执行在哪个线程（注意，这里的函数名可以任取）： @Subscribe(threadMode = ThreadMode.Async, sticky = true, priority = 1) public void onAsync(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;Async: &quot; + Thread.currentThread().getName()); } @Subscribe(threadMode = ThreadMode.BackgroundThread) public void onBackgroundThread(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;BackgroundThread: &quot; + Thread.currentThread().getName()); } @Subscribe(threadMode = ThreadMode.MainThread) public void onMainThread(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;MainThread: &quot; + Thread.currentThread().getName()); } @Subscribe(threadMode = ThreadMode.PostThread) public void onPostThread(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;PostThread: &quot; + Thread.currentThread().getName()); } 在SecondActivity发送事件（主线程中发送）： EventBus.getDefault().post(new FirstEvent(&quot;啦啦啦&quot;)); 执行结果如下： Async: pool-1-thread-1 MainThread: main PostThread: main BackgroundThread: pool-1-thread-2 如果是在子线程中发送： new Thread(new Runnable() { @Override public void run() { EventBus.getDefault().post(new FirstEvent(&quot;啦啦啦&quot;)); } }).start(); 执行结果如下： BackgroundThread: Thread-450 PostThread: Thread-450 Async: pool-1-thread-1 MainThread: main 如果先启动SecondActivity，后启动MainActivity： @Override public void onClick(View v) { EventBus.getDefault().postSticky(new FirstEvent(&quot;啦啦啦&quot;)); startActivity(new Intent(SecondActivity.this,MainActivity.class)); } 确实只有onAsync方法收到了消息。 至此对EventBus的试验基本就结束了，各位可以自行选择不同的ThreadMode值，让订阅函数执行在不同的线程。根据需要选择是否需要sticky=true。 完整的MainActivity和SecondActivity代码如下（xml文件就不贴了，就一个Button）： public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this); findViewById(R.id.btn).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { startActivity(new Intent(MainActivity.this, SecondActivity.class)); } }); } @Override protected void onDestroy() { super.onDestroy(); EventBus.getDefault().unregister(this); } @Subscribe(threadMode = ThreadMode.Async, sticky = true, priority = 1) public void onAsync(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;Async: &quot; + Thread.currentThread().getName()); } @Subscribe(threadMode = ThreadMode.BackgroundThread) public void onBackgroundThread(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;BackgroundThread: &quot; + Thread.currentThread().getName()); } @Subscribe(threadMode = ThreadMode.MainThread) public void onMainThread(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;MainThread: &quot; + Thread.currentThread().getName()); } @Subscribe(threadMode = ThreadMode.PostThread) public void onPostThread(FirstEvent event) { Log.e(&quot;TAG&quot;, &quot;PostThread: &quot; + Thread.currentThread().getName()); } } public class SecondActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); findViewById(R.id.second).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { EventBus.getDefault().postSticky(new FirstEvent(&quot;Lai自星星的我&quot;)); startActivity(new Intent(SecondActivity.this,MainActivity.class)); } }); } } 参考链接 EventBus所有版本的Marven仓库http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22de.greenrobot%22%20AND%20a%3A%22eventbus%22EventBus2.x使用教程http://blog.csdn.net/harvic880925/article/details/40787203http://www.cnblogs.com/angeldevil/p/3715934.html","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]},{"title":"Android面试题","slug":"Android面试题","date":"2015-12-22T16:01:56.000Z","updated":"2016-06-30T14:26:44.000Z","comments":true,"path":"2015/12/23/Android面试题/","link":"","permalink":"http://smarxpan.github.io/2015/12/23/Android面试题/","excerpt":"Android面试题// TODO 待编辑 个人整理的给Android程序员的面试题 所谓面试题, 固然是过面试的捷径, 但学习知识&amp;提高自己才是最终目的. 这些题目只是把一些知识点单独拿出来, 零散且不成体系. 所以我在其中会穿插推荐几本参考书, 一起进步吧","text":"Android面试题// TODO 待编辑 个人整理的给Android程序员的面试题 所谓面试题, 固然是过面试的捷径, 但学习知识&amp;提高自己才是最终目的. 这些题目只是把一些知识点单独拿出来, 零散且不成体系. 所以我在其中会穿插推荐几本参考书, 一起进步吧 算法与数据结构请使用java或者C++实现反转单链表/** * 定义一个单链表 */ class Node { //变量 private int record; //指向下一个对象 private Node nextNode; public Node(int record) { super(); this.record = record; } public int getRecord() { return record; } public void setRecord(int record) { this.record = record; } public Node getNextNode() { return nextNode; } public void setNextNode(Node nextNode) { this.nextNode = nextNode; } } /** * @author luochengcheng * 两种方式实现单链表的反转(递归、普通) * 新手强烈建议旁边拿着纸和笔跟着代码画图(便于理解) */ public class ReverseSingleList { /** * 递归，在反转当前节点之前先反转后续节点 */ public static Node reverse(Node head) { if (null == head || null == head.getNextNode()) { return head; } Node reversedHead = reverse(head.getNextNode()); head.getNextNode().setNextNode(head); head.setNextNode(null); return reversedHead; } /** * 遍历，将当前节点的下一个节点缓存后更改当前节点指针 * */ public static Node reverse2(Node head) { if (null == head) { return head; } Node pre = head; Node cur = head.getNextNode(); Node next; while (null != cur) { next = cur.getNextNode(); cur.setNextNode(pre); pre = cur; cur = next; } //将原链表的头节点的下一个节点置为null，再将反转后的头节点赋给head head.setNextNode(null); head = pre; return head; } public static void main(String[] args) { Node head = new Node(0); Node tmp = null; Node cur = null; // 构造一个长度为10的链表，保存头节点对象head for (int i = 1; i &lt; 10; i++) { tmp = new Node(i); if (1 == i) { head.setNextNode(tmp); } else { cur.setNextNode(tmp); } cur = tmp; } //打印反转前的链表 Node h = head; while (null != h) { System.out.print(h.getRecord() + &quot; &quot;); h = h.getNextNode(); } //调用反转方法 head = reverse2(head); System.out.println(&quot;\\n**************************&quot;); //打印反转后的结果 while (null != head) { System.out.print(head.getRecord() + &quot; &quot;); head = head.getNextNode(); } } } 求素数/** * 假如所求素数很大时，此方法效率很高 */ public static List&lt;Integer&gt; getPrimeNumber(int from, int to) { if (from &lt;= 0 || from &gt;= to) { return null; } List&lt;Integer&gt; prime = new ArrayList&lt;Integer&gt;(); // 首先定义一个比所求素数大1的数组 boolean result[] = new boolean[to + 1]; // 排除偶数 for (int i = 2; i &lt;= to; i++) { result[i] = i % 2 != 0; } // 排除所有从3到开平方数的倍数 for (int i = 3; i &lt;= Math.sqrt(to); i++) { if (result[i]) { for (int j = i + i; j &lt; to; j += i) { result[j] = false; } } } for (int i = from; i &lt;= to; i++) { if (result[i]){ prime.add(i); } } return prime; } 冒泡排序二叉树遍历最长不重复子串（最长重复子串）写一个求递归程序 求54321写一个方法，交换两个变量的值？二叉查找树的删除操作，手写代码二分查找，手写代码有海量条 url，其中不重复的有300万条，现在希望挑选出重复出现次数最高的 url，要求效率尽可能的高反转字符串，要求手写代码，优化速度、优化空间Java&amp;和&amp;&amp;的区别。 Get和Post的区别 UDP和TCP的区别 java中的软引用, 弱引用, 强引用 抽象类和接口的区别 谈一下对java中的abstract的理解 Overload和Override的区别 内部类(Inner Class)和静态内部类(Static Nested Class)的不同 内部类机制 生产者、消费者 死锁（同步嵌套同步且锁不同） 写一个多线程实例代码； 怎么用接口来连接两个层的 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concreteclass)? private和default有什么区别 java里的常量是怎么定义的 类前边加+final的用处？ finally final finalize的作用？ java中final定义的类有什么特点 try{ return} catch{} finally{}; return还是finally先执行。 数组有没有length()这个方法? String有没有length()这个方法？ 是否可以继承String类? swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上? 常量final string str=“ab”可不可以变成”abd”，为什么？ StringBuffer的作用？ String s=new String(“abc”); new了几个对象 启动一个线程是用run()还是start()? 多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 同步和异步的区别？ sleep和wait有什么区别？ 一个是用来让线程休息，一个是用来挂起线程 abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized? 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? Error与Exception的区别 Java中的异常处理机制的简单原理和应用。 Java内存回收机制，GC 垃圾回收机制,垃圾回收的优点和原理。并考虑2种回收机制。 对象Object读写的是哪两个流 反射，求字段的值和方法名 Socket编程的步骤 什么是Java序列化 常见集合及区别 ArrayList和Vector区别，HashMap和HashTable区别 ArrayList和LinkedList的区别 List, Set, Map是否继承自Collection接口? hashCode方法的作用 Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别? 当x.equals(y)等于true时，x.hashCode()与y.hashCode()可以不相等，这句话对不对? XML，解析XML的几种方式的原理与特点：DOM、SAX、PULL MD5加密原理，可否解密。 heap和stack有什么区别。 用最有效率的方法算出2乘以8等於几? （2&lt;&lt; 3） ArrayList和Vector的主要区别是什么？ ArrayList在Java1.2引入，用于替换Vector Vector: 线程同步 当Vector中的元素超过它的初始大小时，Vector会将它的容量翻倍 ArrayList: 线程不同步，但性能很好 当ArrayList中的元素超过它的初始大小时，ArrayList只增加50%的大小 Java中try catch finally的执行顺序 先执行try中代码发生异常执行catch中代码，最后一定会执行finally中代码 switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？ switch支持使用byte类型，不支持long类型，String支持在java1.7引入 常见异常，5种运行时异常 运行时异常与一般异常有何异同？ 设计模式单例模式——写一个Singleton出来 网络Androidservice生命周期，可以执行耗时操作吗？ JNI开发流程 Java线程池，线程同步 自己设计一个图片加载框架 自定义View相关方法 插件化，动态加载 性能优化，MAT AsyncTask原理 65k限制 Serializable和Parcelable 文件和数据库哪个效率高 断点续传 WebView和JS 静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用？持有的引用是this？还是其它？ 静态内部类：使用static修饰的内部类 内部类：就是在某个类的内部又定义了一个类，内部类所嵌入的类称为外部类 匿名内部类：使用new生成的内部类 因为内部类的产生依赖于外部类，持有的引用是类名.this Activity和Fragment生命周期有哪些？ Activity——onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy Fragment——onAttach-&gt;onCreate-&gt;onCreateView-&gt;onActivityCreated-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroyView-&gt;onDestroy-&gt;onDetach onInterceptTouchEvent()和onTouchEvent()的区别？ onInterceptTouchEvent()用于拦截触摸事件 onTouchEvent()用于处理触摸事件 RemoteView在哪些功能中使用 APPwidget和Notification中 SurfaceView和View的区别是什么？ SurfaceView中采用了双缓存技术，在单独的线程中更新界面 View在UI线程中更新界面 讲一下android中进程的优先级？ 前台进程 可见进程 服务进程 后台进程 空进程 Activity生命周期及横竖屏切换时生命周期 Activity四种启动模式 内存不足时，怎么保持Activity的一些状态，在哪个方法里面做具体操作？ 介绍Activity、Service、Broadcast、BroadcastReceiver、Intent、IntentFilter 怎么在启动一个activity时就启动一个service 同一个程序不同的Activity如何放在不同的任务栈中？ 如何将一个Activity设置成窗口的样式 如何退出Activity？如何安全退出已调用多个Activity的Application？ Activity中如何动态的添加Fragment？ activity的启动过程 一个activity打开另外一个activity，再打开一个activity？回去的时候发生了什么操作？ onActivityResult(int requestCode, int resultCode, Intent data)方法的用法； Fragment Fragment嵌套多个Fragment会出现bug吗？ Broadcast Receiver 注册广播有哪几种方式,有什么区别 Android引入广播机制的用意？ 无序广播、有序广播 -1000——1000 同优先级，清单文件中上面先收到 Broadcast、Content Provider 和 AIDL的区别和联系 Android基础——广播接收者BroadcastReceiver Service 注册Service需要注意什么 什么是Service以及描述下它的生命周期。 Service与Activity怎么实现通信 Service有哪些启动方法，有什么区别，怎样停用Service？ 什么是IntentService？有何优点？ Service和Activity在同一个线程吗 main 线程 UI线程 Service 如何启用Service，如何停用Service 说说Activity、Intent、Service是什么关系 AIDL,两个android应用间的互相调用方法？ AIDL的全称是什么？如何工作？能处理哪些类型的数据 Android基础——Service Android基础——IntentService Android开发指导——Service Android开发指导——绑定Service Android开发指导——进程间通信AIDL ContentProvider 自定义一个contentProvider。 请介绍下ContentProvider是如何实现数据共享的 创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。 contentProvider权限； AsyncTask简介 Asynctask具体用法？ Asynctask的Do in background方法是怎么通知UI线程刷新进度条的？ Asynctask的Do in background方法默认是返回 true ，表示任务完成，如果想返回具体的数据呢，怎么做。如果Activity被销毁了，还会执行到postexcutd方法吗？ ListView 手指快速拖动ListView时，如何处理惯性引起的加载问题； 怎么实现ListView多种布局？ ListView与数据库绑定的实现 怎么实现一个部分更新的 ListView？ ListView卡顿的原因与性能优化，大量数据时,说的越多越好 UI相关 谈谈UI中，Padding和Margin有什么区别？ drawable-hdpi的dpi是什么意思？ 请介绍下Android中常用的五种布局 Android中px,sp,dip,dp的区别与联系 怎么处理屏幕适配的 android开发中怎么去调试debug 请解释下Android程序运行时权限与文件系统的权限的区别 JVM 和Dalvik虚拟机的区别 android dvm的进程和Linux的进程应用程序是否为同一个概念 sim卡的ef文件有何作用。 android数字签名 MVC, 在Android中MVC的具体体现 简述Android应用程序的组成 进程保活 什么情况会导致Force Close?如何避免？是否捕获导致其的异常 什么是 ANR 问题？为什么会引起 ANR 问题？ URL和URI区别用法 数据存储，数据持久化的方式有哪些 进程优先级 intent-filter属性及其含义； 如何打开res/raw 目录中的数据库文件？ NotifactionManager使用原理 Asset与raw都能存放资源，他们有什么区别？ postInvalidate与invalidate有什么区别？ notifyDataSetChanged 和notifyDataSetInvalidated的区别 Serializable和Parcelable的区别 Intent启动Activity有几种方式，请分别简述 列举常用的Android开源项目及应用场景 数据库为何效率高 常见设计模式，并手动简单实现观察者模式 Handler机制 热修复 简述静默安装的原理，如何在无需Root权限的情况下实现静默安装 什么是65535问题，如何防止或解决65535问题 简述实现Android APK插件化的简单方法 如何实现资源文件的混淆 如何在不引用第三方工具的情况下防止应用二次打包？并对应用进行简单加固 简述控制反转（Inversion of Control）的应用场景 怎么考虑数据传输的安全性 xmpp openfire 基于xmpp openfire smack开发之Android客户端开发 应用常驻后台，避免被第三方杀掉的方法，讲讲你用过的奇淫巧技？ 简述实现Android APK插件化的简单方法 JS交互 如何实现点击网站某个链接就自动下载一个程序到手机上并自动安装运行； java和JS的交互 Android中Java和JavaScript交互 WebView 远程代码执行漏洞浅析 解决方案：WebView中的Java与JavaScript提供【安全可靠】的多样互通方案 Android动画 Android中有哪些类型的动画，用属性动画实现控件的缩放 不使用动画，怎么实现一个动态的 View？ Android中的动画有哪些，区别是什么 自定义View View,SurfaceView，GLSurfaceView有什么区别 View的绘制 如何自定义ViewGroup？ View刷新机制 android UI中的View如何刷新 事件传递及处理机制 View中onTouch，onTouchEvent，onClick的执行顺序 JNI JNI怎么使用 简单描述你是如何进行JNI开发的 在哪些情况下java代码中需要调用C代码 性能优化 图片缓存及优化,设计一个图片缓存加载机制 内存优化，布局优化，代码优化 内存溢出OOM是怎么引起的？怎么尽量避免OOM问题的出现? Android中引起内存泄露的原因 Android面试——APP性能优化 数据库 分页查询数据 如何将SQLite数据库与apk文件一起发布？ 左连接与右连接的区别 描述Sqlite数据库（类型、关系）； 你的项目中Sqlite数据库中存储的数据用SharePreference来处理也可以，为什么不用SharePreference呢； 网络编程 Rest API Volley相关 Volley Android Volley完全解析 如何控制TCP连接时的拥塞 TCP的流量控制和拥塞控制 三次握手 TCP协议中的三次握手和四次挥手(图解) Android客户端和服务端如何使用Token和Session 移动端获取网络数据优化 进阶 转自知乎用户-马天宇的回答 整体性能如何探测，有哪方面 什么指标，怎么保证更流畅 讲讲架构这块，如何解耦，大项目逻辑多怎么办。 android的发展大事件和主要技术发展 avtivity（service）启动流程简述 动态化的几种方案 热修复的原理 网络这块怎么优化 数据库性能怎么保证 线程安全怎么保证，异步并发这块你怎么做的 1. App性能如何探测，有哪些方面，什么指标，怎么保证更流畅？性能可以根据帧率、内存、CPU、GPU等指标的数据和表现辅助判断，可以从/proc文件夹下读取文件获取cpu、内存等信息，也可以用dumpsys命令获取帧率等信息，也可以通过android API获取相关信息。 还有很多性能相关的分析工具很重要，辅助判断和分析，比如Heap Tool、Memory Monitor、Lint、HierarchyView、WireShark、TraceView等。 保证流畅有很多点可以去研究，比如布局、代码、缓存、网络、数据库、异步并发等方面的优化，涉及很多的知识点，可以google下，先简单说下，有时间再细述。 布局充分利用include、viewstub、merge 等标签，控制层级，避免过度渲染（绘制）。代码上尽量使用final、局部变量、系统函数如arraycopy等、位移操作是否可以代替乘除、for循环是否可以避免size计算和new对象等等。缓存方面，线程、位图、视图、网络数据是否可以被缓存，IO用缓冲流。网络方面，如尽量避免轮询，控制节奏和频率，IP直连，采用SPDY方案（或HTTP2.0）来实现压缩header、多路复用、双向通信等，API数据压缩，多个请求是否可以合并，数据压缩和尝试protocol buffer相关序列化方案。数据库方面，尝试用SQLiteStatement代替SQLiteDatabase完成操作，索引和事务的充分理解和使用，注意SQL语句语法和拼接，采用部分查询和延迟加载。异步并发方面，全App只有一个线程池，控制核心并发数量，控制超载时排队数量和策略，合理调度任务，优化业务逻辑。最后关于帧率，你看到的视觉卡顿，直接原因基本是“掉帧”。关于帧率，尽量保证主线程里做的事情，不会超过16毫秒（其实这挺难的），16毫秒大法好，具体可以去理解下CPU、GPU、屏幕三者如何配合完成渲染的，推荐老罗的博客。 2. 谈谈架构。大项目，逻辑多怎么办，如何应对多App和多终端？适当参考我在知乎的一个回答 怎样搭高质量的Android项目框架，框架的结构具体描述？ - 马天宇的回答 ，结合模块化、组件化思想去做，多实践一下mvp、mvvm等策略。 3. android的发展大事件和主要技术发展额，挺多的，朋友们补充吧。这个问题蛮好的 Android 开发有哪些新技术出现？ - Android 应用 4. avtivity（service）启动流程简述可以自己阅读源代码，结合罗老师的博客，研究的非常棒：Android应用程序启动过程源代码分析 5. 动态化的几种方案早期的H5方案，通过js和java互通增强h5的能力。还有DexClasssLoader结合反射代理的方案。还有React Native方案，手淘的Weex框架。还有Lua等脚本实现动态化方案。 6. 热修复的原理Github上读一下AndFix这个项目的源码，还有xposed、dexposed。 大致原理就是将java方法通过c/c++修改属性变为public native方法，上下文携带到native层，然后根据上下文指向另一个java方法，从而“偷梁换柱”，如果是支持ART的手机，那么策略不一样，将bug method的关键信息（classloader、theadid等）保留，将修复过的方法的各种信息赋给bug method，完成“移花接木”。 另外，其实有挺多的策略改变运行时行为的，比如：Javasisst：字节码修改类库，依赖字节码修改和DX类库，可以完成动态替换和切面编程。AspectJ：依赖字节码编织器，需要按照其语法来编写，需要一点“编织”时间。Xposed方案，简直是一个Bug，神器般的存在，没准以后会被Android系统修复呢，不仅可以改变自己的类行为还可以hook系统的方法，root过的机器还可以hook其他App和系统进程。 7. 网络这块怎么优化尽量避免轮询，控制节奏和频率。 IP直连节省DNS解析时间。 尝试其他数据序列化方案比如protocol buffer等。 采用SPDY方案（或HTTP2.0）来压缩header、多路复用、双向通信等。 服务器做优化，比如分布式、缓存之类的，减少API涉及的业务操作所需要的时间嘛。 API接口数据精简，多个请求是否可以合并，增量请求啊、GIP压缩啊什么的，等等。 8. 数据库性能怎么保证尝试使用SQLiteStatement取代SQLiteDatabase对象完成操作，避免直接使用SQLiteDatabase提供的update、inset等方法。 索引和事务的充分理解和使用，批量操作使用事务极大提升速度，这个我是做过试验的，效果惊人。 SQL语句拼接和本身的优化，仅查询部分局部数据，使用延迟加载策略。 10万条数据插入比系统SQLiteDatabase操作快一倍，推荐我的LiteOrm数据库框架litesuits/android-lite-orm。 9. 线程安全怎么保证，异步并发这块你怎么做的理解并使用ReentrantLock，Synchronized保护对象或过程，final来保护不可变对象，无状态和只读对象是安全的，合理使用一些 concurrent容器，比如ConcurrentHashmap等，重量级耗时任务考虑是否可以释放锁，多线程下实例化或延迟加载需要保护起来，保护多线程下关键数据访问的原子性，等等还有很多的。。。 推荐研究下Doug Lea主写和设计的java concurrent包，理解CountDownLatch、CyclicBarrier、Semaphore、FutureTask等对象。 具体开上，我使用自己写的SmartExecutor，直接继承ExecutorService，封装了一个公共线程池，全App保证只有一个线程池。源码在这个开源项目里：GitHub - litesuits/android-lite-http 在一个 App 中 SmartExecutor 可以有多个实例，每个实例都有独立核心和等待线程数指标，每个实例都有独立的调度和满载处理策略，但它们 共享一个线程池。这种机制既满足不同木块对线程控制和任务调度的独立需求，又共享一个池资源。独立又共享，最大程度上节省资源，提升性能。 控制核心并发数，尽量和CPU核数保持一致（或者多两个）我认为吞吐量是最佳的，线程过多则调度线程消耗CPU和时间，过少则不能充分利用多核的能力。 控制排队策略和排队数量，是否考虑新任务先处理，过度超载丢掉最老的任务。 还有就是业务上，合理调度任务，优化业务逻辑，不要胡搞乱搞，不作恶。 以下问题来自问题感觉安卓应用开发就是一些接口的调用和ui界面的逻辑处理，还有其他可以深入学习的吗, Kaede的回答 个人尽量给出回答, 不准确欢迎指出 10. Android App的生命周期是什么11. 四大组件很熟悉了吧，ContentProvider的生命周期是什么；12. Android设备开机的启动过程；13. Activity的视图层次是什么？打开一个对话框的时候，这个对话框是如何加入到视图上去的？14. Dialog、PopupWindow、WindowManager加载视图的区别；15. Service与Thread的区别；16. ServiceManager、ActivityManager、XXXManager是干什么的；17. 为什么一定要在UI线程更新视图，为什么要这么设计；18. 能不能直接New一个Activity并启动它；19. 打包APK的过程干了什么；安装APK的过程干了什么；启动APK的过程干了什么；怎么玩DexLoader（动态升级）；20. MVP模式是啥；21. View的生命周期是啥；TWEEN动画跟熟悉动画在View的绘制过程是怎么作用的；自定义动画玩过吗，里面的Matrix怎么控制。22. res里面的XML资源最终都要转化成JavaCode，怎么完全脱离res，用纯代码的方式实现res资源的功能，怎么缩放一张点九图；23. Binder原理是什么，出了Binder之外，还能怎么跟Service交互；24. Touch事件的分发机制；能不能用代码模拟一组TOUCH事件（比如自动点击广告，自动滚动）；25. ROOT的原理是什么，系统是怎么管理APP的权限的；26. Material Desgin这么好看，为什么不出兼容包，让5.0以下的系统也能要动画效果；ART模式与Dalvik有什么不同；Render Thread是怎么工作的；","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://smarxpan.github.io/tags/Android/"}]}]}