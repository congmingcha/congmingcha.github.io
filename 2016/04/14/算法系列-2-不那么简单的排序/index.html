<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>算法系列(2)--不那么简单的排序之希尔、归并、快速排序 | Smarx&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="也不知道与简单排序对应的应该叫什么, 就叫不那么简单的排序好了.
本篇博客主要学习了希尔排序、归并排序and快速排序。
注: 这一篇和上一篇简单排序都算是学习白话算法系列的学习笔记吧
希尔排序希尔排序是基于插入排序而来, 插入排序的最好时间复杂度是O(n), 当数组基本有序时, 效率是很高的. 而希尔排序, 设定一个增量, 按增量将数组分组.
例如数组{1,2,3,4}, 增量是2, 那么数组就可">
<meta property="og:type" content="article">
<meta property="og:title" content="算法系列(2)--不那么简单的排序之希尔、归并、快速排序">
<meta property="og:url" content="http://yoursite.com/2016/04/14/算法系列-2-不那么简单的排序/index.html">
<meta property="og:site_name" content="Smarx's Blog">
<meta property="og:description" content="也不知道与简单排序对应的应该叫什么, 就叫不那么简单的排序好了.
本篇博客主要学习了希尔排序、归并排序and快速排序。
注: 这一篇和上一篇简单排序都算是学习白话算法系列的学习笔记吧
希尔排序希尔排序是基于插入排序而来, 插入排序的最好时间复杂度是O(n), 当数组基本有序时, 效率是很高的. 而希尔排序, 设定一个增量, 按增量将数组分组.
例如数组{1,2,3,4}, 增量是2, 那么数组就可">
<meta property="og:updated_time" content="2016-04-14T14:59:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法系列(2)--不那么简单的排序之希尔、归并、快速排序">
<meta name="twitter:description" content="也不知道与简单排序对应的应该叫什么, 就叫不那么简单的排序好了.
本篇博客主要学习了希尔排序、归并排序and快速排序。
注: 这一篇和上一篇简单排序都算是学习白话算法系列的学习笔记吧
希尔排序希尔排序是基于插入排序而来, 插入排序的最好时间复杂度是O(n), 当数组基本有序时, 效率是很高的. 而希尔排序, 设定一个增量, 按增量将数组分组.
例如数组{1,2,3,4}, 增量是2, 那么数组就可">
  
    <link rel="alternative" href="/atom.xml" title="Smarx&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xqnsv.com1.z0.glb.clouddn.com/20150422113520402.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">聪明叉</a></h1>
		</hgroup>

		
		<p class="header-subtitle">一只程序猿的进化之路</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/smarxpan" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/5332818993?is_all=1" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/pan-li-ming-15" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ARM-Translation/" style="font-size: 10px;">ARM-Translation</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/EventBus/" style="font-size: 10px;">EventBus</a> <a href="/tags/Genymotion/" style="font-size: 10px;">Genymotion</a> <a href="/tags/多渠道打包/" style="font-size: 10px;">多渠道打包</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">一只不怎么强大的Android程序猿</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">聪明叉</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xqnsv.com1.z0.glb.clouddn.com/20150422113520402.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">聪明叉</h1>
			</hgroup>
			
			<p class="header-subtitle">一只程序猿的进化之路</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/smarxpan" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5332818993?is_all=1" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/pan-li-ming-15" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-算法系列-2-不那么简单的排序" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/14/算法系列-2-不那么简单的排序/" class="article-date">
  	<time datetime="2016-04-14T14:48:23.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      算法系列(2)--不那么简单的排序之希尔、归并、快速排序
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>也不知道与简单排序对应的应该叫什么, 就叫不那么简单的排序好了.</p>
<p>本篇博客主要学习了希尔排序、归并排序and快速排序。</p>
<p><em>注: 这一篇和上一篇<a href="http://smarxpan.github.io/2016/04/03/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97-1-%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">简单排序</a>都算是学习<a href="http://blog.csdn.net/column/details/algorithm-easyword.html" target="_blank" rel="external">白话算法系列</a>的学习笔记吧</em></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是基于插入排序而来, 插入排序的最好时间复杂度是O(n), 当数组基本有序时, 效率是很高的. 而希尔排序, 设定一个增量, 按增量将数组分组.</p>
<p>例如数组{1,2,3,4}, 增量是2, 那么数组就可以分为{1,3}, {2,4}两组, 增量是1那就是1,2,3,4四组.</p>
<p>分组之后在组内进行插入排序, 再缩小增量重新分组再次排序, 直到增量是1(等同于正常的插入排序), 再插入排序一次, 排序完成. </p>
<pre><code>void shellSort(int arr[], int n){

    for (int gap = n/2; gap&gt;0; gap/=2) {
        for (int i = gap; i&lt;n; i++) {
            if (arr[i] &lt; arr[i - gap]) {
                int temp = arr[i];
                int j;
                // 思路与插入排序相同, 用临时变量保存要插入的数, 向数组前面查找插入的位置, 一边查找, 一边将前面较大的数字后移
                // 临时变量不小于前面的某数时, 说明找到了正确的位置, 只要放在那个数后面就可以了
                for (j = i-gap; j&gt;=0 &amp;&amp; temp&lt;arr[j]; j-=gap) {
                    arr[j+gap] = arr[j];
                }
                arr[j+gap] = temp;
            }
        }
    }
}
</code></pre><a id="more"></a>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并二字就是递归&amp;合并</p>
<p>归并排序的关键在于合并有序数组, 合并两个有序数组的方式是先比较两数组的第一个元素, 更小的取出放入新数组, 再依次向后比较, 直到某个数组的元素取光, 把另一个数组的元素依次放入新数组既可.</p>
<pre><code>//先来演示合并数组
void mergeArray(int a[], int m, int b[], int n){
    int c[m+n];

    int i, j, k;
    //必须初始化, 否则会有残值
    i = j = k = 0;

    // 此处不能用for循环, 除非只写第二个表达式, 否则ijk哪个做自增都不合适
    // 其中k看似合适, 但for循环最后会执行一次第三个表达式, k会+1
    while (i &lt; m &amp;&amp; j &lt; n) {
        if (a[i] &lt; b[j]) {
            c[k++] = a[i++];
        }else{
            c[k++] = b[j++];
        }
    }

    while (i &lt; m) {
        c[k++] = a[i++];
    }

    while (j &lt; n) {
        c[k++] = b[j++];
    }

    printfArray(c, m+n);
}
</code></pre><p>下面开始撸正式的归并排序</p>
<pre><code>// 合并有序序列
void mergearray(int arr[], int first, int last, int mid, int temp[]){
    int tempIndex = 0;

    int firstSequenceIndex = first;
    int secondSequeceIndex = mid + 1;

    // 因为这里用的是数组角标, 而不是长度, 所以用&lt;= 而不是&lt;
    while (firstSequenceIndex &lt;= mid &amp;&amp; secondSequeceIndex &lt;= last) {
        // 取较小值放入临时数组
        if (arr[firstSequenceIndex] &lt; arr[secondSequeceIndex] ) {
            temp[tempIndex++] = arr[firstSequenceIndex++];
        }else{
            temp[tempIndex++] = arr[secondSequeceIndex++];
        }
    }
    // 如果前一个序列还有值, 依次放入临时数组
    while (firstSequenceIndex &lt;= mid) {
        temp[tempIndex++] = arr[firstSequenceIndex++];
    }
    // 如果后一个序列还有值, 依次放入临时数组
    while (secondSequeceIndex &lt;= last) {
        temp[tempIndex++] = arr[secondSequeceIndex++];
    }
    // 将排好序的部分赋值给原数组
    for (int i = 0; i &lt; tempIndex; i++) {
        arr[first++] = temp[i];
    }

}

// 搞清归并排序, 主要搞清以下两点
// 1. 递归到只有一个数时, 递归函数开始出栈, 一个数肯定是有序序列
// 2. 合并两个有序序列, 可以形成新的有序序列
void mergeSort(int arr[], int first, int last, int temp[]){
    if(first &lt; last){
        // 将数组分成两部分
        int mid = (first + last)/2;
        // 前一半排序
        mergeSort(arr, first, mid, temp);
        // 后一半排序
        mergeSort(arr, mid+1, last, temp);
        // 合并有序序列
        mergearray(arr, first, last, mid, temp);
    }
}
</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是时间复杂度O(logN*N)的排序算法中比较出名的, 面试算法常常会问, 而手写出来是很有难度的事情. 这里非常感谢<a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="external">白话经典算法系列</a>的作者, 讲解通俗易懂.</p>
<p>快速排序的基本思想一句话概括就是<font color="red"><strong>挖坑填数+分治法</strong></font>, 下面详细描述:</p>
<ol>
<li>先取左边第一个数作为基准数</li>
<li>与基准数比较, 比基准数大的换到右边, 小的换到左边</li>
<li>左右两边分成两个部分, 再进行一次前两步的操作. 重复对左右两边拆分, 进行前两步操作, 直到只剩一个数.</li>
</ol>
<p>这样说还是太抽象, 举个栗子吧</p>
<p>数组a = {3, 1, 4, 2, 0}</p>
<ol>
<li>取a[0]作为基准数, 使用新变量baseNumber存储</li>
<li>从右向左比较, 比基准数小的放在基准数的位置上, 数组变成{<font color="red"><strong>0</strong></font>, 1, 4, 2, <font color="red"><strong>0</strong></font>}, 此时出现一个坑a[4] </li>
<li>从左往右比较, 比基准数大的填入上一个坑a[4], 数组变成{0, 1, <font color="red"><strong>4</strong></font>, 2, <font color="red"><strong>4</strong></font>}, 此时的新坑是a[2]</li>
<li>再从右向左比较, 比基准数小的填入上一个坑a[2], 数组变成{0, 1, <font color="red"><strong>2</strong></font>, <font color="red"><strong>2</strong></font>, 4}, 此时的坑是a[3]</li>
<li>再从左向右比较时, 发现左右相遇了, 将baseNumber赋值给a[3], 数组变成{0, 1, 2, 3, 4}</li>
</ol>
<p>因为数组元素较少, 这样就排序完成了, 但足够大家了解挖坑填数的思路了. </p>
<p>有一点需要说明, 为什么左右相遇了就可以把baseNumber赋值给那个元素? 因为左右两边相遇时, 所有数字都已经比较了一遍, 已经做到”比基准数大的都在右边, 比基准数小的都在左边”.</p>
<p>根据上面的分析, 可以很容易写出挖坑填数的代码:</p>
<pre><code>void changeArray(int arr[], int left, int right){
    int i = left;
    int j = right;

    // 使用变量存储最左边的数做基准数
    // 基准数也可不使用最左边的, 中间和最后一个当然都可以
    int baseNumber = arr[left];

    // 当i=j时意味着数列中所有数都与基准数比较过了, 故结束比较
    while (i &lt; j) {

        // 从右往左比较, 找到比基准数小的数的下标
        while (arr[j] &gt; baseNumber &amp;&amp; i &lt; j) {
            j--;
        }
        arr[i] = arr[j];

        // 从左往右比较, 找到比基准数大的数的下标
        while (arr[i] &lt; baseNumber &amp;&amp; i &lt; j) {
            i++;
        }
        arr[j] = arr[i];
    }
    // 将基准数赋值给a[i](也可以是a[j], 此时i=j)
    arr[i] = baseNumber;

}
</code></pre><p>最后baseNumber赋值,<code>arr[i] = baseNumber</code>,可能会有人对这句疑惑, 为何可以直接赋值, 不会少一个数吗? </p>
<p>答案是不会, 从上面的代码看出, 即便<code>while (arr[i] &lt; baseNumber &amp;&amp; i &lt; j)</code>这个循环没有走, <code>arr[i]</code>的值也会赋值给<code>arr[j]</code>, 这样<code>arr[i]</code>的值必定有两个, 当然可以直接赋值. </p>
<p>接下来彻底完成递归调用:</p>
<pre><code>void quickSort(int arr[], int left, int right){
    // 递归的结束条件, left=right, 也就是只剩一个数的时候
    if (left &lt; right) {

        int i = left;
        int j = right;
        int baseNumber = arr[left];

        while (i &lt; j) {  
            while (arr[j] &gt; baseNumber &amp;&amp; i &lt; j) {
                j--;
            }
            arr[i] = arr[j];

            while (arr[i] &lt; baseNumber &amp;&amp; i &lt; j) {
                i++;
            }
            arr[j] = arr[i];
        }

        arr[i] = baseNumber;

        // 递归调用
        quickSort(arr, left, i - 1);
        quickSort(arr, i + 1, right);
    } 
}
</code></pre>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/04/12/Dagger2探索之Hello-Dagger/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Dagger2探索之Hello Dagger</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="算法系列-2-不那么简单的排序" data-title="算法系列(2)--不那么简单的排序之希尔、归并、快速排序" data-url="http://yoursite.com/2016/04/14/算法系列-2-不那么简单的排序/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"smarx"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 聪明叉
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>